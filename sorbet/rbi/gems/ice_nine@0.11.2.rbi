# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ice_nine` gem.
# Please instead update this file by running `bin/tapioca gem ice_nine`.

# Base IceNine module
module IceNine
  class << self
    # Deep Freeze an object
    #
    # @api public
    # @example
    #   object = IceNine.deep_freeze(object)
    # @param object [Object]
    # @return [Object]
    def deep_freeze(object); end

    # Deep Freeze an object
    #
    # This method uses a faster algorithm that will assume objects that are
    # `frozen?` do not need to be frozen deeply. Use this method when `object`
    # contains no shallowly frozen objects that need deep freezing.
    #
    # @api public
    # @example
    #   IceNine.deep_freeze!(['a', 'b']).map(&:frozen?) # [true, true]
    # @example
    #   IceNine.deep_freeze!(['a', 'b'].freeze).map(&:frozen?) # [false, false]
    # @param object [Object]
    # @return [Object]
    def deep_freeze!(object); end
  end
end

# The default class that handles freezing objects
class IceNine::Freezer
  class << self
    # Look up the Freezer descendant by object type
    #
    # @api public
    # @example
    #   freezer_class = IceNine::Freezer[mod]
    # @param mod [Module]
    # @return [Class<Freezer>]
    def [](mod); end

    # Deep freeze an object with a particular Freezer
    #
    # @api public
    # @param object [Object]
    # @return [Object]
    # @see IceNine.deep_freeze
    def deep_freeze(object); end

    # Deep freeze an object with a particular Freezer
    #
    # @api public
    # @param object [Object]
    # @return [Object]
    # @see IceNine.deep_freeze!
    def deep_freeze!(object); end

    protected

    # Look up a constant in the namespace
    #
    # @api private
    # @param namespace [String]
    # @return [Module] returned if a matching constant is found
    # @return [nil] returned if no matching constant is found
    def const_lookup(namespace); end

    # Deep freeze an object with a particular Freezer and RecursionGuard
    #
    # @api private
    # @param object [Object]
    # @param recursion_guard [RecursionGuard]
    # @return [Object]
    def guarded_deep_freeze(object, recursion_guard); end

    private

    # Find a Freezer descendant by name
    #
    # @api private
    # @param name [String]
    # @return [Class<Freezer>] returned if a matching freezer is found
    # @return [nil] returned if no matching freezer is found
    def find(name); end
  end
end

# A freezer class for handling Array objects
class IceNine::Freezer::Array < ::IceNine::Freezer::Object
  class << self
    # Deep Freeze an Array
    #
    # @example
    #   array = IceNine:Freezer::Array.deep_freeze(%w[a b c])
    #   array.select(&:frozen?)  # => ['a', 'b', 'c']
    # @param array [Array]
    # @param recursion_guard [RecursionGuard]
    # @return [Array]
    def guarded_deep_freeze(array, recursion_guard); end
  end
end

# Object
IceNine::Freezer::BasicObject = IceNine::Freezer::Object

# Skip freezing false objects
class IceNine::Freezer::FalseClass < ::IceNine::Freezer::NoFreeze; end

# A freezer class for handling Hash objects
class IceNine::Freezer::Hash < ::IceNine::Freezer::Object
  class << self
    # Deep Freeze a Hash
    #
    # @example
    #   hash = IceNine::Freezer::Hash.deep_freeze('a' => '1', 'b' => '2')
    #   hash.keys.select(&:frozen?)    # => ['a', 'b']
    #   hash.values.select(&:frozen?)  # => ['1', '2']
    # @param hash [Hash]
    # @param recursion_guard [RecursionGuard]
    # @return [Hash]
    def guarded_deep_freeze(hash, recursion_guard); end

    private

    # Handle freezing the key/value pairs
    #
    # @api private
    # @param hash [Hash]
    # @param recursion_guard [RecursionGuard]
    # @return [undefined]
    def freeze_key_value_pairs(hash, recursion_guard); end
  end
end

# Skip freezing Hash::State objects on Rubinius
class IceNine::Freezer::Hash::State < ::IceNine::Freezer::NoFreeze; end

# Skip freezing Module objects
class IceNine::Freezer::Module < ::IceNine::Freezer::NoFreeze; end

# Skip freezing nil objects
class IceNine::Freezer::NilClass < ::IceNine::Freezer::NoFreeze; end

# A freezer class that does not freeze anything
class IceNine::Freezer::NoFreeze < ::IceNine::Freezer
  class << self
    # Pass through the object without freezing it
    #
    # @example
    #   object = IceNine::Freezer::NoFreeze.deep_freeze(object)
    #   object.frozen?  # => false
    # @param object [Object]
    # @param _recursion_guard [RecursionGuard]
    # @return [Object]
    def guarded_deep_freeze(object, _recursion_guard); end
  end
end

# Skip freezing Numeric objects
class IceNine::Freezer::Numeric < ::IceNine::Freezer::NoFreeze; end

# A freezer class for handling Object instances
class IceNine::Freezer::Object < ::IceNine::Freezer
  class << self
    # Deep Freeze an object
    #
    # @example
    #   object = IceNine.deep_freeze(Object.new)
    # @param object [Object]
    # @param recursion_guard [RecursionGuard]
    # @return [Object]
    def guarded_deep_freeze(object, recursion_guard); end

    private

    # Handle freezing the object's instance variables
    #
    # @api private
    # @param object [Object]
    # @param recursion_guard [RecursionGuard]
    # @return [undefined]
    def freeze_instance_variables(object, recursion_guard); end
  end
end

# A freezer class for handling Range objects
class IceNine::Freezer::Range < ::IceNine::Freezer::Object
  class << self
    # Deep Freeze a Range
    #
    # @example
    #   range = IceNine:Freezer::Range.deep_freeze('a'..'z')
    #   range.begin.frozen?  # => true
    #   range.end.frozen?    # => true
    # @param range [Range]
    # @param recursion_guard [RecursionGuard]
    # @return [Range]
    def guarded_deep_freeze(range, recursion_guard); end
  end
end

# Skip freezing Rubinius objects
class IceNine::Freezer::Rubinius < ::IceNine::Freezer::NoFreeze; end

# A freezer class for handling Struct objects
class IceNine::Freezer::Struct < ::IceNine::Freezer::Array; end

# Skip freezing Symbol objects
class IceNine::Freezer::Symbol < ::IceNine::Freezer::NoFreeze; end

# Skip freezing true objects
class IceNine::Freezer::TrueClass < ::IceNine::Freezer::NoFreeze; end

# Protect against infinite recursion
#
# @private
class IceNine::RecursionGuard; end

# Protects against infinite recursion by not yielding with frozen objects
class IceNine::RecursionGuard::Frozen < ::IceNine::RecursionGuard
  # Guard against recursively calling a block with the same frozen object
  #
  # @param object [Object]
  # @return [Object]
  def guard(object); end
end

# Protects against infinite recursion by never yielding with the same
# object more than once.
class IceNine::RecursionGuard::ObjectSet < ::IceNine::RecursionGuard
  # Initialize a recursion guard
  #
  # @return [undefined]
  def initialize; end

  # Guard against recursively calling a block with the same object
  #
  # @example
  #   recursion_guard = IceNine::RecursionGuard::ObjectSet.new
  #   recursion_guard.guard(object) do
  #   logic_which_may_be_recursively_called_with_object(recursion_guard)
  #   end
  # @param object [Object]
  # @return [Object]
  def guard(object); end
end

# Gem version
IceNine::VERSION = T.let(T.unsafe(nil), String)
