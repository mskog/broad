# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rb-readline` gem.
# Please instead update this file by running `bin/tapioca gem rb-readline`.

module RbReadline
  # Sets the attribute history_base
  #
  # @param value the value to set the attribute history_base to.
  def history_base=(_arg0); end

  # Sets the attribute history_length
  #
  # @param value the value to set the attribute history_length to.
  def history_length=(_arg0); end

  # Sets the attribute rl_point
  #
  # @param value the value to set the attribute rl_point to.
  def rl_point=(_arg0); end

  private

  # Fix up point so that it is within the line boundaries after killing
  #   text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
  #   boundaries also.
  def __rl_fix_point(x); end

  def _extract_last_quote(string, quote_char); end

  # How to abort things.
  def _rl_abort_internal; end

  # adjust pointed byte and find mbstate of the point of string.
  #   adjusted point will be point <= adjusted_point, and returns
  #   differences of the byte(adjusted_point - point).
  #   if point is invalied (point < 0 || more than string length),
  #   it returns -1
  def _rl_adjust_point(string, point); end

  def _rl_any_typein; end

  # Process C as part of the current numeric argument.  Return -1 if the
  #   argument should be aborted, 0 if we should not read any more chars, and
  #   1 if we should continue to read chars.
  def _rl_arg_dispatch(cxt, c); end

  def _rl_arg_getchar; end
  def _rl_arg_init; end
  def _rl_arg_overflow; end

  # Move the cursor back.
  def _rl_backspace(count); end

  def _rl_bind_tty_special_chars(kmap); end
  def _rl_char_search(count, fdir, bdir); end
  def _rl_char_search_internal(count, dir, smbchar, len); end
  def _rl_char_value(buf, ind); end
  def _rl_clean_up_for_exit; end
  def _rl_clear_screen; end

  # Clear to the end of the line.  COUNT is the minimum
  #   number of character spaces to clear,
  def _rl_clear_to_eol(count); end

  def _rl_col_width(string, start, _end); end

  # compare the specified two characters. If the characters matched,
  #   return true. Otherwise return false.
  def _rl_compare_chars(buf1, pos1, buf2, pos2); end

  def _rl_control_keypad(on); end

  # Add TEXT to the kill ring, allocating a new kill ring slot as necessary.
  #   This uses TEXT directly, so the caller must not free it.  If APPEND is
  #   non-zero, and the last command was a kill, the text is appended to the
  #   current kill ring slot, otherwise prepended.
  def _rl_copy_to_kill_ring(text, append); end

  # return the `current display line' of the cursor -- the number of lines to
  #   move up to get to the first screen line of the current readline line.
  def _rl_current_display_line; end

  # Do the command associated with KEY in MAP.
  #   If the associated command is really a keymap, then read
  #   another key, and dispatch into that map.
  def _rl_dispatch(key, map); end

  def _rl_dispatch_subseq(key, map, got_subseq); end
  def _rl_enable_meta_key; end

  # Quick redisplay hack when erasing characters at the end of the line.
  def _rl_erase_at_end_of_line(l); end

  def _rl_erase_entire_line; end
  def _rl_find_completion_word; end

  # Find next `count' characters started byte point of the specified seed.
  #   If flags is MB_FIND_NONZERO, we look for non-zero-width multibyte
  #   characters.
  def _rl_find_next_mbchar(string, seed, count, flags); end

  # Find previous character started byte point of the specified seed.
  #   Returned point will be point <= seed.  If flags is MB_FIND_NONZERO,
  #   we look for non-zero-width multibyte characters.
  def _rl_find_prev_mbchar(string, seed, flags); end

  def _rl_fix_point(fix_mark_too); end

  # return the number of bytes parsed from the multibyte sequence starting
  # at src, if a non-L'\0' wide character was recognized. It returns 0,
  # if a L'\0' wide character was recognized. It  returns (size_t)(-1),
  # if an invalid multibyte sequence was encountered. It returns (size_t)(-2)
  # if it couldn't parse a complete  multibyte character.
  def _rl_get_char_len(src); end

  # Get readline's idea of the screen size.  TTY is a file descriptor open
  #   to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
  #   values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
  #   non-null serve to check whether or not we have initialized termcap.
  def _rl_get_screen_size(tty, ignore_env); end

  def _rl_history_set_point; end
  def _rl_init_eightbit; end
  def _rl_init_line_state; end
  def _rl_init_terminal_io(terminal_name); end
  def _rl_input_available; end

  # Insert the character C at the current location, moving point forward.
  #   If C introduces a multibyte sequence, we read the whole sequence and
  #   then insert the multibyte char into the line buffer.
  def _rl_insert_char(count, c); end

  # Insert the next typed character verbatim.
  def _rl_insert_next(count); end

  def _rl_insert_typein(c); end
  def _rl_internal_char_cleanup; end
  def _rl_internal_pager(lines); end
  def _rl_is_mbchar_matched(string, seed, _end, mbchar, length); end
  def _rl_isearch_cleanup(cxt, r); end

  # Process just-read character C according to isearch context CXT.  Return
  #   -1 if the caller should just free the context and return, 0 if we should
  #   break out of the loop, and 1 if we should continue to read characters.
  def _rl_isearch_dispatch(cxt, c); end

  def _rl_isearch_fini(cxt); end
  def _rl_isearch_init(direction); end
  def _rl_make_prompt_for_search(pchar); end

  # Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.
  #   (Well, when we don't have multibyte characters, _rl_last_c_pos is a
  #   buffer index.)
  #   DATA is the contents of the screen line of interest; i.e., where
  #   the movement is being done.
  def _rl_move_cursor_relative(new, data, start = T.unsafe(nil)); end

  # PWP: move the cursor up or down.
  def _rl_move_vert(to); end

  def _rl_nsearch_abort(cxt); end
  def _rl_nsearch_cleanup(cxt, r); end

  # Process just-read character C according to search context CXT.  Return -1
  #   if the caller should abort the search, 0 if we should break out of the
  #   loop, and 1 if we should continue to read characters.
  def _rl_nsearch_dispatch(cxt, c); end

  # Perform one search according to CXT, using NONINC_SEARCH_STRING.  Return
  #   -1 if the search should be aborted, any other value means to clean up
  #   using _rl_nsearch_cleanup ().  Returns 1 if the search was successful,
  #   0 otherwise.
  def _rl_nsearch_dosearch(cxt); end

  def _rl_nsearch_init(dir, pchar); end

  # Write COUNT characters from STRING to the output stream.
  def _rl_output_some_chars(string, start, count); end

  # Overwrite the character at point (or next COUNT characters) with C.
  #   If C introduces a multibyte character sequence, read the entire sequence
  #   before starting the overwrite loop.
  def _rl_overwrite_char(count, c); end

  # This is different from what vi does, so the code's not shared.  Emacs
  #   rubout in overwrite mode has one oddity:  it replaces a control
  #   character that's displayed as two characters (^X) with two spaces.
  def _rl_overwrite_rubout(count, key); end

  def _rl_read_init_file(filename, include_level); end

  # read multibyte char
  def _rl_read_mbchar(mbchar, size); end

  # Read a multibyte-character string whose first character is FIRST into
  #   the buffer MB of length MLEN.  Returns the last character read, which
  #   may be FIRST.  Used by the search functions, among others.  Very similar
  #   to _rl_read_mbchar.
  def _rl_read_mbstring(first, mb, mlen); end

  # Redisplay the current line after a SIGWINCH is received.
  def _rl_redisplay_after_sigwinch; end

  # Replace the contents of the line buffer between START and END with
  #   TEXT.  The operation is undoable.  To replace the entire line in an
  #   undoable mode, use _rl_replace_text(text, 0, rl_end)
  def _rl_replace_text(text, start, _end); end

  # Create a default argument.
  def _rl_reset_argument; end

  def _rl_rubout_char(count, key); end
  def _rl_scxt_alloc(type, flags); end
  def _rl_search_getchar(cxt); end

  # Function for the rest of the library to use to set insert/overwrite mode.
  def _rl_set_insert_mode(im, force); end

  # Set the mark at POSITION.
  def _rl_set_mark_at_pos(position); end

  # Set the history pointer back to the last entry in the history.
  def _rl_start_using_history; end

  def _rl_strip_prompt(pmt); end
  def _rl_subseq_getchar(key); end
  def _rl_to_lower(char); end

  # Stuff KEY into the *front* of the input buffer.
  #   Returns non-zero if successful, zero if there is
  #   no space left in the buffer.
  def _rl_unget_char(key); end

  def _rl_update_final; end
  def _rl_vi_done_inserting; end
  def _rl_vi_initialize_line; end
  def _rl_vi_reset_last; end
  def _rl_vi_save_insert(up); end

  # Is the command C a VI mode text modification command?
  def _rl_vi_textmod_command(c); end

  def _rl_walphabetic(c); end

  # Place STRING at the end of the history list.  The data field
  #   is  set to NULL.
  def add_history(string); end

  def alloc_history_entry(string, ts); end
  def alloc_undo_entry(what, start, _end, text); end

  # Append any necessary closing quote and a separator character to the
  # just-inserted match.  If the user has specified that directories
  # should be marked by a trailing `/', append one of those instead.  The
  # default trailing character is a space.  Returns the number of characters
  # appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
  # has them) and don't add a suffix for a symlink to a directory.  A
  # nontrivial match is one that actually adds to the word being completed.
  # The variable rl_completion_mark_symlink_dirs controls this behavior
  # (it's initially set to the what the user has chosen, indicated by the
  # value of _rl_complete_mark_symlink_dirs, but may be modified by an
  # application's completion function).
  def append_to_match(text, delimiter, quote_char, nontrivial_match); end

  # Try and bind the common arrow key prefixes after giving termcap and
  #   the inputrc file a chance to bind them and create `real' keymaps
  #   for the arrow key prefix.
  def bind_arrow_keys; end

  # Bind some common arrow key sequences in MAP.
  def bind_arrow_keys_internal(map); end

  # Bind the arrow key sequences from the termcap description in MAP.
  def bind_termcap_arrow_keys(map); end

  def block_sigint; end
  def clear_history; end

  # Find the common prefix of the list of matches, and put it into
  #   matches[0].
  def compute_lcd_of_matches(match_list, matches, text); end

  # Move to the start of the current line.
  def cr; end

  def cr_faster(new, cur); end
  def ctrl_char(c); end

  # Return the history entry at the current position, as determined by
  #   history_offset.  If there is no entry there, return a NULL pointer.
  def current_history; end

  # Delete COUNT characters from the display line.
  def delete_chars(count); end

  # Display MATCHES, a list of matching filenames in argv format.  This
  # handles the simple case -- a single match -- first.  If there is more
  # than one match, we compute the number of strings in the list and the
  # length of the longest string, which will be needed by the display
  # function.  If the application wants to handle displaying the list of
  # matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the
  # address of a function, and we just call it.  If we're handling the
  # display ourselves, we just call rl_display_match_list.  We also check
  # that the list of matches doesn't exceed the user-settable threshold,
  # and ask the user if he wants to see the list if there are more matches
  # than RL_COMPLETION_QUERY_ITEMS.
  def display_matches(matches); end

  def endsrch_char(c); end

  # Current implementation:
  #    \001 (^A) start non-visible characters
  #    \002 (^B) end non-visible characters
  #   all characters except \001 and \002 (following a \001) are copied to
  #   the returned string all characters except those between \001 and
  #   \002 are assumed to be `visible'.
  def expand_prompt(pmt); end

  def fnprint(to_print); end

  # Compute width of STRING when displayed on screen by print_filename
  def fnwidth(string); end

  def gen_completion_matches(text, start, _end, our_func, found_quote, quote_char); end
  def get_term_capabilities(buffer); end

  # The user must press "y" or "n". Non-zero return means "y" pressed.
  def get_y_or_n(for_pager); end

  # Handle a parser directive.  STATEMENT is the line of the directive
  #   without any leading `$'.
  def handle_parser_directive(statement); end

  def hist_inittime; end
  def history_arg_extract(first, last, string); end

  # Returns the value of attribute history_base.
  def history_base; end

  # Return the history entry which is logically at OFFSET in the history array.
  #   OFFSET is relative to history_base.
  def history_get(offset); end

  def history_is_stifled; end

  # Returns the value of attribute history_length.
  def history_length; end

  def history_list; end

  # Search for STRING in the history list.  DIR is < 0 for searching
  #   backwards.  POS is an absolute index into the history list at
  #   which point to begin searching.
  def history_search_pos(string, dir, pos); end

  # Do an anchored search for string through the history in DIRECTION.
  def history_search_prefix(string, direction); end

  # Make the current history item be the one at POS, an absolute index.
  #   Returns zero if POS is out of range, else non-zero.
  def history_set_pos(pos); end

  # Return the amount of space available in the buffer for stuffing
  #   characters.
  def ibuffer_space; end

  # Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated
  #   arrays of line break markers.  MINSIZE is the minimum size of VISIBLE_LINE
  #   and INVISIBLE_LINE; if it is greater than LINE_SIZE, LINE_SIZE is
  #   increased.  If the lines have already been allocated, this ensures that
  #   they can hold at least MINSIZE characters.
  def init_line_structures(minsize); end

  def insert_all_matches(matches, point, qc); end
  def insert_match(match, start, mtype, qc); end

  # Insert COUNT characters from STRING to the output stream at column COL.
  def insert_some_chars(string, count, col); end

  def inv_line(line); end
  def inv_llen(l); end
  def isascii(c); end
  def isprint(c); end
  def m_offset(margin, offset); end

  # Make the data from the history entry ENTRY be the contents of the
  #   current line.  This doesn't do anything with rl_point; the caller
  #   must set it.
  def make_history_line_current(entry); end

  def make_quoted_replacement(match, mtype, qc); end
  def meta_char(c); end

  # Move history_offset forward to the next history entry, and return
  #   a pointer to that entry.  If there is no next entry then return a
  #   NULL pointer.
  def next_history; end

  def no_terminal?; end

  # Search for a line in the history containing STRING.  If DIR is < 0, the
  #   search is backwards through previous entries, else through subsequent
  #   entries.  Returns 1 if the search was successful, 0 otherwise.
  def noninc_dosearch(string, dir); end

  # Search non-interactively through the history list.  DIR < 0 means to
  #   search backwards through the history of previous commands; otherwise
  #   the search is for commands subsequent to the current position in the
  #   history list.  PCHAR is the character to use for prompting when reading
  #   the search string; if not specified (0), it defaults to `:'.
  def noninc_search(dir, pchar); end

  # Search the history list for STRING starting at absolute history position
  #   POS.  If STRING begins with `^', the search must match STRING at the
  #   beginning of a history line, otherwise a full substring match is performed
  #   for STRING.  DIR < 0 means to search backwards through the history list,
  #   DIR >= 0 means to search forward.
  def noninc_search_from_pos(string, pos, dir); end

  # Invert the current parser state if there is anything on the stack.
  def parser_else(args); end

  # Terminate a conditional, popping the value of
  #   _rl_parsing_conditionalized_out from the stack.
  def parser_endif(args); end

  # Push _rl_parsing_conditionalized_out, and set parser state based
  #   on ARGS.
  def parser_if(args); end

  def parser_include(args); end
  def path_isdir(filename); end
  def postprocess_matches(matchesp, matching_filenames); end
  def prepare_terminal_settings(meta_flag); end

  # Back up history_offset to the previous history entry, and return
  #   a pointer to that entry.  If there is no previous entry then return
  #   a NULL pointer.
  def previous_history; end

  # Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
  #   are using it, check for and output a single character for `special'
  #   filenames.  Return the number of characters we output.
  def print_filename(to_print, full_pathname); end

  # Return the portion of PATHNAME that should be output when listing
  #   possible completions.  If we are hacking filename completion, we
  #   are only interested in the basename, the portion following the
  #   final slash.  Otherwise, we return what we were passed.  Since
  #   printing empty strings is not very informative, if we're doing
  #   filename completion, and the basename is the empty string, we look
  #   for the previous slash and return the portion following that.  If
  #   there's no previous slash, we just return what we were passed.
  def printable_part(pathname); end

  # * _rl_last_c_pos is an absolute cursor position in multibyte locales and a
  #   buffer index in others.  This macro is used when deciding whether the
  #   current cursor position is in the middle of a prompt string containing
  #   invisible characters.
  def prompt_ending_index; end

  # Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
  #   none.  A return value of NULL means that EOF was encountered.
  def readline(prompt); end

  # If this system allows us to look at the values of the regular
  #   input editing characters, then bind them to their readline
  #   equivalents, iff the characters are not bound to keymaps.
  def readline_default_bindings; end

  # Initialize the entire state of the world.
  def readline_initialize_everything; end

  # Read a line of input from the global rl_instream, doing output on
  #   the global rl_outstream.
  #   If rl_prompt is non-null, then that is our prompt.
  def readline_internal; end

  def readline_internal_charloop; end
  def readline_internal_setup; end
  def readline_internal_teardown(eof); end

  # Redraw the last line of a multi-line prompt that may possibly contain
  # terminal escape sequences.  Called with the cursor at column 0 of the
  # line to draw the prompt on.
  def redraw_prompt(t); end

  def release_sigint; end

  # Filter out duplicates in MATCHES.  This frees up the strings in
  #   MATCHES.
  def remove_duplicate_matches(matches); end

  # Remove history element WHICH from the history.  The removed
  #   element is returned to you so you can free the line, data,
  #   and containing structure.
  def remove_history(which); end

  # Replace the DATA in the specified history entries, replacing OLD with
  #   NEW.  WHICH says which one(s) to replace:  WHICH == -1 means to replace
  #   all of the history entries where entry->data == OLD; WHICH == -2 means
  #   to replace the `newest' history entry where entry->data == OLD; and
  #   WHICH >= 0 means to replace that particular history entry's data, as
  #   long as it matches OLD.
  def replace_history_data(which, old, new); end

  # Make the history entry at WHICH have LINE and DATA.  This returns
  #   the old entry so you can dispose of the data.  In the case of an
  #   invalid WHICH, a NULL pointer is returned.
  def replace_history_entry(which, line, data); end

  def retry_if_interrupted(&block); end
  def rl_abort(count, key); end

  # * Remember how to undo something.  Concatenate some undos if that
  #   seems right.
  def rl_add_undo(what, start, _end, text); end

  def rl_alphabetic(c); end
  def rl_arrow_keys(count, c); end

  # Returns the value of attribute rl_attempted_completion_function.
  def rl_attempted_completion_function; end

  # Sets the attribute rl_attempted_completion_function
  #
  # @param value the value to set the attribute rl_attempted_completion_function to.
  def rl_attempted_completion_function=(_arg0); end

  # Returns the value of attribute rl_attempted_completion_over.
  def rl_attempted_completion_over; end

  # Sets the attribute rl_attempted_completion_over
  #
  # @param value the value to set the attribute rl_attempted_completion_over to.
  def rl_attempted_completion_over=(_arg0); end

  # Backwards compatibility.
  def rl_backward(count, key); end

  # Move backward COUNT bytes.
  def rl_backward_byte(count, key); end

  # Move backward COUNT characters.
  def rl_backward_char(count, key); end

  def rl_backward_char_search(count, key); end

  # Kill backwards to the start of the line.  If DIRECTION is negative, kill
  #   forwards to the line end instead.
  def rl_backward_kill_line(direction, ignore); end

  # Rubout the word before point, placing it on the kill ring.
  def rl_backward_kill_word(count, ignore); end

  # Move backward a word.  We do what Emacs does.  Handles multibyte chars.
  def rl_backward_word(count, key); end

  # Returns the value of attribute rl_basic_quote_characters.
  def rl_basic_quote_characters; end

  # Sets the attribute rl_basic_quote_characters
  #
  # @param value the value to set the attribute rl_basic_quote_characters to.
  def rl_basic_quote_characters=(_arg0); end

  # Returns the value of attribute rl_basic_word_break_characters.
  def rl_basic_word_break_characters; end

  # Sets the attribute rl_basic_word_break_characters
  #
  # @param value the value to set the attribute rl_basic_word_break_characters to.
  def rl_basic_word_break_characters=(_arg0); end

  # Move to the beginning of the line.
  def rl_beg_of_line(count, key); end

  # Begin a group.  Subsequent undos are undone as an atomic operation.
  def rl_begin_undo_group; end

  # Meta-< goes to the start of the history.
  def rl_beginning_of_history(count, key); end

  # Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range.
  def rl_bind_key(key, function); end

  def rl_bind_keyseq_if_unbound(keyseq, default_func); end

  # Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
  #   now, this is always used to attempt to bind the arrow keys, hence the
  #   check for rl_vi_movement_mode.
  def rl_bind_keyseq_if_unbound_in_map(keyseq, default_func, kmap); end

  # Bind the key sequence represented by the string KEYSEQ to
  #   FUNCTION.  This makes new keymaps as necessary.  The initial
  #   place to do bindings is in MAP.
  def rl_bind_keyseq_in_map(keyseq, function, map); end

  # Upcase the first letter, downcase the rest.
  def rl_capitalize_word(count, key); end

  # The meaty function.
  #   Change the case of COUNT words, performing OP on them.
  #   OP is one of UpCase, DownCase, or CapCase.
  #   If a negative argument is given, leave point where it started,
  #   otherwise, leave it where it moves to.
  def rl_change_case(count, op); end

  def rl_char_search(count, key); end
  def rl_character_len(c, pos); end

  # Clean up the terminal and readline state after catching a signal, before
  #   resending it to the calling application.
  def rl_cleanup_after_signal; end

  # How to clear things from the "echo-area".
  def rl_clear_message; end

  # Clear any pending input pushed with rl_execute_next()
  def rl_clear_pending_input; end

  # C-l typed to a line without quoting clears the screen, and then reprints
  #   the prompt and the current input line.  Given a numeric arg, redraw only
  #   the current line.
  def rl_clear_screen(count, key); end

  def rl_clear_signals; end

  # Complete the word at or before point.  You have supplied the function
  #   that does the initial simple matching selection algorithm (see
  #   rl_completion_matches ()).  The default is to do filename completion.
  def rl_complete(ignore, invoking_key); end

  # Complete the word at or before point.
  #   WHAT_TO_DO says what to do with the completion.
  #   `?' means list the possible completions.
  #   TAB means do standard completion.
  #   `*' means insert all of the possible completions.
  #   `!' means to do standard completion, and list all possible completions if
  #   there is more than one.
  #   `@' means to do standard completion, and list all possible completions if
  #   there is more than one and partial completion is not possible.
  def rl_complete_internal(what_to_do); end

  # Returns the value of attribute rl_completer_quote_characters.
  def rl_completer_quote_characters; end

  # Sets the attribute rl_completer_quote_characters
  #
  # @param value the value to set the attribute rl_completer_quote_characters to.
  def rl_completer_quote_characters=(_arg0); end

  # Returns the value of attribute rl_completer_word_break_characters.
  def rl_completer_word_break_characters; end

  # Sets the attribute rl_completer_word_break_characters
  #
  # @param value the value to set the attribute rl_completer_word_break_characters to.
  def rl_completer_word_break_characters=(_arg0); end

  # Returns the value of attribute rl_completion_append_character.
  def rl_completion_append_character; end

  # Sets the attribute rl_completion_append_character
  #
  # @param value the value to set the attribute rl_completion_append_character to.
  def rl_completion_append_character=(_arg0); end

  # Return an array of (char *) which is a list of completions for TEXT.
  #   If there are no completions, return a NULL pointer.
  #   The first entry in the returned array is the substitution for TEXT.
  #   The remaining entries are the possible completions.
  #   The array is terminated with a NULL pointer.
  #
  #   ENTRY_FUNCTION is a function of two args, and returns a (char *).
  #     The first argument is TEXT.
  #     The second is a state argument it should be zero on the first call, and
  #     non-zero on subsequent calls.  It returns a NULL pointer to the caller
  #     when there are no more matches.
  def rl_completion_matches(text, entry_function); end

  def rl_copy_text(from, to); end

  # Move to the start of the next line.
  def rl_crlf; end

  # Delete the character under the cursor.  Given a numeric argument,
  #   kill that many characters instead.
  def rl_delete(count, key); end

  # Delete all spaces and tabs around point.
  def rl_delete_horizontal_space(count, ignore); end

  # Like the tcsh editing function delete-char-or-list.  The eof character
  #   is caught before this is invoked, so this really does the same thing as
  #   delete-char-or-list-or-eof, as long as it's bound to the eof character.
  def rl_delete_or_show_completions(count, key); end

  # Delete the string between FROM and TO.  FROM is inclusive, TO is not.
  #   Returns the number of characters deleted.
  def rl_delete_text(from, to); end

  # Returns the value of attribute rl_deprep_term_function.
  def rl_deprep_term_function; end

  # Sets the attribute rl_deprep_term_function
  #
  # @param value the value to set the attribute rl_deprep_term_function to.
  def rl_deprep_term_function=(_arg0); end

  # Restore the terminal's normal settings and modes.
  def rl_deprep_terminal; end

  # Start a numeric argument with initial value KEY
  def rl_digit_argument(ignore, key); end

  # Handle C-u style numeric args, as well as M--, and M-digits.
  def rl_digit_loop; end

  # Ring the terminal bell.
  def rl_ding; end

  # A convenience function for displaying a list of strings in
  #   columnar format on readline's output stream.  MATCHES is the list
  #   of strings, in argv format, LEN is the number of strings in MATCHES,
  #   and MAX is the length of the longest string in MATCHES.
  def rl_display_match_list(matches, len, max); end

  # Display the current state of the search in the echo-area.
  #   SEARCH_STRING contains the string that is being searched for,
  #   DIRECTION is zero for forward, or non-zero for reverse,
  #   WHERE is the history list number of the current line.  If it is
  #   -1, then this line is the starting one.
  def rl_display_search(search_string, reverse_p, where); end

  # What to do for some uppercase characters, like meta characters,
  #   and some characters appearing in emacs_ctlx_keymap.  This function
  #   is just a stub, you bind keys to it and the code in _rl_dispatch ()
  #   is special cased.
  def rl_do_lowercase_version(ignore1, ignore2); end

  def rl_do_undo; end

  # Lowercase the word at point.
  def rl_downcase_word(count, key); end

  def rl_emacs_editing_mode(count, key); end

  # Meta-> goes to the end of the history.  (The current line).
  def rl_end_of_history(count, key); end

  # Move to the end of the line.
  def rl_end_of_line(count, key); end

  # End an undo group started with rl_begin_undo_group ().
  def rl_end_undo_group; end

  # Returns the value of attribute rl_event_hook.
  def rl_event_hook; end

  # Sets the attribute rl_event_hook
  #
  # @param value the value to set the attribute rl_event_hook to.
  def rl_event_hook=(_arg0); end

  # Exchange the position of mark and point.
  def rl_exchange_point_and_mark(count, key); end

  # Make C be the next command to be executed.
  def rl_execute_next(c); end

  # *
  # * Expand the prompt string into the various display components, if
  # * necessary.
  # *
  # * local_prompt = expanded last line of string in rl_display_prompt
  # *          (portion after the final newline)
  # * local_prompt_prefix = portion before last newline of rl_display_prompt,
  # *             expanded via expand_prompt
  # * prompt_visible_length = number of visible characters in local_prompt
  # * prompt_prefix_length = number of visible characters in local_prompt_prefix
  # *
  # * This function is called once per call to readline().  It may also be
  # * called arbitrarily to expand the primary prompt.
  # *
  # * The return value is the number of visible characters on the last line
  # * of the (possibly multi-line) prompt.
  # *
  def rl_expand_prompt(prompt); end

  # Increase the size of RL_LINE_BUFFER until it has enough space to hold
  #   LEN characters.
  def rl_extend_line_buffer(len); end

  # Okay, now we write the entry_function for filename completion.  In the
  # general case.  Note that completion in the shell is a little different
  # because of all the pathnames that must be followed when looking up the
  # completion for a command.
  def rl_filename_completion_function(text, state); end

  # Returns the value of attribute rl_filename_quote_characters.
  def rl_filename_quote_characters; end

  # Sets the attribute rl_filename_quote_characters
  #
  # @param value the value to set the attribute rl_filename_quote_characters to.
  def rl_filename_quote_characters=(_arg0); end

  # Actually update the display, period.
  def rl_forced_update_display; end

  # Backwards compatibility.
  def rl_forward(count, key); end

  # Move forward COUNT bytes.
  def rl_forward_byte(count, key); end

  # Move forward COUNT characters.
  def rl_forward_char(count, key); end

  # Search forwards through the history looking for a string which is typed
  #   interactively.  Start with the current line.
  def rl_forward_search_history(sign, key); end

  # Move forward a word.  We do what Emacs does.  Handles multibyte chars.
  def rl_forward_word(count, key); end

  def rl_free_undo_list; end

  # Return the function (or macro) definition which would be invoked via
  #   KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is
  #   used.  TYPE, if non-NULL, is a pointer to an int which will receive the
  #   type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
  #   or ISMACR (macro).
  def rl_function_of_keyseq(keyseq, map, type); end

  def rl_gather_tyi; end

  # Bind the key sequence represented by the string KEYSEQ to
  #   the arbitrary pointer DATA.  TYPE says what kind of data is
  #   pointed to by DATA, right now this can be a function (ISFUNC),
  #   a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps
  #   as necessary.  The initial place to do bindings is in MAP.
  def rl_generic_bind(type, keyseq, data, map); end

  # Get a key from the buffer of characters to be read.
  #   Return the key in KEY.
  #   Result is KEY if there was a key, or 0 if there wasn't.
  def rl_get_char; end

  def rl_get_keymap_name_from_edit_mode; end

  # Move down to the next history line.
  def rl_get_next_history(count, key); end

  # Get the previous item out of our interactive history, making it the current
  #   line.  If there is no previous history, just ding.
  def rl_get_previous_history(count, key); end

  def rl_getc(stream); end

  # Initialize readline (and terminal if not already).
  def rl_initialize; end

  def rl_insert(count, c); end

  # Turn the current line into a comment in shell history.
  #   A K*rn shell style function.
  def rl_insert_comment(count, key); end

  def rl_insert_completions(ignore, invoking_key); end

  # Insert a string of text into the line at point.  This is the only
  #   way that you should do insertion.  _rl_insert_char () calls this
  #   function.  Returns the number of characters inserted.
  def rl_insert_text(string); end

  # Returns the value of attribute rl_instream.
  def rl_instream; end

  # Sets the attribute rl_instream
  #
  # @param value the value to set the attribute rl_instream to.
  def rl_instream=(_arg0); end

  def rl_isstate(x); end

  # Kill the whole line, no matter where point is.
  def rl_kill_full_line(count, ignore); end

  # Kill from here to the end of the line.  If DIRECTION is negative, kill
  #   back to the line start instead.
  def rl_kill_line(direction, ignore); end

  # The way to kill something.  This appends or prepends to the last
  #   kill, if the last command was a kill command.  if FROM is less
  #   than TO, then the text is appended, otherwise prepended.  If the
  #   last command was not a kill command, then a new slot is made for
  #   this kill.
  def rl_kill_text(from, to); end

  # Delete the word at point, saving the text in the kill ring.
  def rl_kill_word(count, key); end

  # Returns the value of attribute rl_library_version.
  def rl_library_version; end

  # Sets the attribute rl_library_version
  #
  # @param value the value to set the attribute rl_library_version to.
  def rl_library_version=(_arg0); end

  def rl_line_buffer; end

  # Perhaps put back the current line if it has changed.
  def rl_maybe_replace_line; end

  # Save the current line in _rl_saved_line_for_history.
  def rl_maybe_save_line; end

  # Restore the _rl_saved_line_for_history if there is one.
  def rl_maybe_unsave_line; end

  def rl_message(msg_buf); end

  # Save an undo entry for the text from START to END.
  def rl_modifying(start, _end); end

  def rl_named_function(name); end

  # What to do when a NEWLINE is pressed.  We accept the whole line.
  #   KEY is the key that invoked this command.  I guess it could have
  #   meaning in the future.
  def rl_newline(count, key); end

  # Search forward through the history list for a string.  If the vi-mode
  #   code calls this, KEY will be `?'.
  def rl_noninc_forward_search(count, key); end

  # Reverse search the history list for a string.  If the vi-mode code
  #   calls this, KEY will be `/'.
  def rl_noninc_reverse_search(count, key); end

  # Tell the update routines that we have moved onto a new (empty) line.
  def rl_on_new_line; end

  # Tell the update routines that we have moved onto a new line with the
  #   prompt already displayed.  Code originally from the version of readline
  #   distributed with CLISP.  rl_expand_prompt must have already been called
  #   (explicitly or implicitly).  This still doesn't work exactly right.
  def rl_on_new_line_with_prompt; end

  # Returns the value of attribute rl_outstream.
  def rl_outstream; end

  # Sets the attribute rl_outstream
  #
  # @param value the value to set the attribute rl_outstream to.
  def rl_outstream=(_arg0); end

  # Toggle overwrite mode.  A positive explicit argument selects overwrite
  #   mode.  A negative or zero explicit argument selects insert mode.
  def rl_overwrite_mode(count, key); end

  # Read the binding command from STRING and perform it.
  #   A key binding command looks like: Keyname: function-name\0,
  #   a variable binding command looks like: set variable value.
  #   A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark.
  def rl_parse_and_bind(string); end

  # Returns the value of attribute rl_point.
  def rl_point; end

  # List the possible completions.  See description of rl_complete ().
  def rl_possible_completions(ignore, invoking_key); end

  def rl_prep_terminal(meta_flag); end
  def rl_quoted_insert(count, key); end

  # Re-read the current keybindings file.
  def rl_re_read_init_file(count, ignore); end

  # Do key bindings from a file.  If FILENAME is NULL it defaults
  #   to the first non-null filename from this list:
  #     1. the filename used for the previous call
  #     2. the value of the shell variable `INPUTRC'
  #     3. ~/.inputrc
  #     4. /etc/inputrc
  #   If the file existed and could be opened and read, 0 is returned,
  #   otherwise errno is returned.
  def rl_read_init_file(filename); end

  # Read a key, including pending input.
  def rl_read_key; end

  # Returns the value of attribute rl_readline_name.
  def rl_readline_name; end

  # Sets the attribute rl_readline_name
  #
  # @param value the value to set the attribute rl_readline_name to.
  def rl_readline_name=(_arg0); end

  # Basic redisplay algorithm.
  def rl_redisplay; end

  # Clear the current line.  Numeric argument to C-l does this.
  def rl_refresh_line(ignore1, ignore2); end

  def rl_replace_from_history(entry, flags); end

  # Replace the current line buffer contents with TEXT.  If CLEAR_UNDO is
  #   non-zero, we free the current undo list.
  def rl_replace_line(text, clear_undo); end

  def rl_reset_line_state; end
  def rl_resize_terminal; end
  def rl_restart_output(count, key); end
  def rl_restore_prompt; end

  # Search backwards through the history looking for a string which is typed
  #   interactively.  Start with the current line.
  def rl_reverse_search_history(sign, key); end

  # Revert the current line to its previous state.
  def rl_revert_line(count, key); end

  # Rubout the character behind point.
  def rl_rubout(count, key); end

  # Delete the character under the cursor, unless the insertion
  #   point is at the end of the line, in which case the character
  #   behind the cursor is deleted.  COUNT is obeyed and may be used
  #   to delete forward or backward that many characters.
  def rl_rubout_or_delete(count, key); end

  def rl_save_prompt; end

  # Search through the history looking for an interactively typed string.
  #   This is analogous to i-search.  We start the search in the current line.
  #   DIRECTION is which direction to search; >= 0 means forward, < 0 means
  #   backwards.
  def rl_search_history(direction, invoking_key); end

  def rl_set_keymap_from_edit_mode; end

  # A bindable command to set the mark.
  def rl_set_mark(count, key); end

  # Set up the prompt and expand it.  Called from readline() and
  #   rl_callback_handler_install ().
  def rl_set_prompt(prompt); end

  def rl_set_signals; end
  def rl_setstate(x); end
  def rl_sigwinch_handler(sig); end

  # Add KEY to the buffer of characters to be read.  Returns 1 if the
  #   character was stuffed correctly; 0 otherwise.
  def rl_stuff_char(key); end

  # Insert a tab character.
  def rl_tab_insert(count, key); end

  # A function for simple tilde expansion.
  def rl_tilde_expand(ignore, key); end

  def rl_translate_keyseq(seq); end

  # Transpose the characters at point.  If point is at the end of the line,
  #   then transpose the characters before point.
  def rl_transpose_chars(count, key); end

  # Transpose the words at point.  If point is at the end of the line,
  #   transpose the two words before point.
  def rl_transpose_words(count, key); end

  # New public way to set the system default editing chars to their readline
  #   equivalents.
  def rl_tty_set_default_bindings(kmap); end

  # Rebind all of the tty special chars that readline worries about back
  #   to self-insert.  Call this before saving the current terminal special
  #   chars with save_tty_chars().  This only works on POSIX termios or termio
  #   systems.
  def rl_tty_unset_default_bindings(kmap); end

  # Do some undoing of things that were done.
  def rl_undo_command(count, key); end

  # This deletes one filename component in a Unix pathname.  That is, it
  #   deletes backward to directory separator (`/') or whitespace.
  def rl_unix_filename_rubout(count, key); end

  # Here is C-u doing what Unix does.  You don't *have* to use these
  # key-bindings.  We have a choice of killing the entire line, or
  # killing from where we are to the start of the line.  We choose the
  # latter, because if you are a Unix weenie, then you haven't backspaced
  # into the line at all, and if you aren't, then you know what you are
  # doing.
  def rl_unix_line_discard(count, key); end

  # This does what C-w does in Unix.  We can't prevent people from
  #   using behaviour that they expect.
  def rl_unix_word_rubout(count, key); end

  def rl_unsetstate(x); end

  # Uppercase the word at point.
  def rl_upcase_word(count, key); end

  # A completion function for usernames.
  #   TEXT contains a partial username preceded by a random
  #   character (usually `~').
  def rl_username_completion_function(text, state); end

  def rl_variable_bind(name, value); end
  def rl_vi_check; end

  # This is a NOOP until the rest of Vi-mode is working.
  def rl_vi_editing_mode(count, key); end

  # Switching from one mode to the other really just involves
  #   switching keymaps.
  def rl_vi_insertion_mode(count, key); end

  # Yank back the last killed text.  This ignores arguments.
  def rl_yank(count, ignore); end

  def rl_yank_last_arg(count, key); end

  # Yank the COUNTth argument from the previous history line.
  def rl_yank_nth_arg(count, ignore); end

  # Yank the COUNTh argument from the previous history line, skipping
  #   HISTORY_SKIP lines before looking for the `previous line'.
  def rl_yank_nth_arg_internal(count, ignore, history_skip); end

  # If the last command was yank, or yank_pop, and the text just
  #   before point is identical to the current kill item, then
  #   delete that text from the line, rotate the index down, and
  #   yank back some other text.
  def rl_yank_pop(count, key); end

  def save_tty_chars; end

  # Set default values for readline word completion.  These are the variables
  #   that application completion functions can change or inspect.
  def set_completion_defaults(what_to_do); end

  # Set the environment variables LINES and COLUMNS to lines and cols,
  #   respectively.
  def sh_set_lines_and_columns(lines, cols); end

  # Clear to the end of the line using spaces.  COUNT is the minimum
  #   number of character spaces to clear,
  def space_to_eol(count); end

  # Return the character which best describes FILENAME.
  #     `@' for symbolic links
  #     `/' for directories
  #     `*' for executables
  #     `=' for sockets
  #     `|' for FIFOs
  #     `%' for character special devices
  #     `#' for block special devices
  def stat_char(filename); end

  # Stifle the history list, remembering only MAX number of lines.
  def stifle_history(max); end

  def tgetflag(name); end

  # Undo the next thing in the list.  Return 0 if there
  #   is nothing to undo, or non-zero if there was.
  def trans(i); end

  # Stop stifling the history.  This returns the previous maximum
  #   number of history entries.  The value is positive if the history
  #   was stifled,  negative if it wasn't.
  def unstifle_history; end

  # PWP: update_line() is based on finding the middle difference of each
  #   line on the screen; vis:
  #
  #             /old first difference
  #  /beginning of line   |        /old last same       /old EOL
  #  v          v         v         v
  # old:   eddie> Oh, my little gruntle-buggy is to me, as lurgid as
  # new:   eddie> Oh, my little buggy says to me, as lurgid as
  #  ^          ^   ^           ^
  #  \beginning of line   |  \new last same    \new end of line
  #             \new first difference
  #
  #   All are character pointers for the sake of speed.  Special cases for
  #   no differences, as well as for end of line additions must be handled.
  #
  #   Could be made even smarter, but this works well enough
  def update_line(old, ostart, new, current_line, omax, nmax, inv_botlin); end

  def using_history; end
  def vis_chars(line); end
  def vis_line(line); end
  def vis_llen(l); end
  def vis_pos(line); end
  def w_offset(line, offset); end

  # Returns the magic number which says what history element we are
  #   looking at now.  In this implementation, it returns history_offset.
  def where_history; end

  def whitespace(c); end

  class << self
    # Fix up point so that it is within the line boundaries after killing
    #   text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
    #   boundaries also.
    def __rl_fix_point(x); end

    def _extract_last_quote(string, quote_char); end

    # How to abort things.
    def _rl_abort_internal; end

    # adjust pointed byte and find mbstate of the point of string.
    #   adjusted point will be point <= adjusted_point, and returns
    #   differences of the byte(adjusted_point - point).
    #   if point is invalied (point < 0 || more than string length),
    #   it returns -1
    def _rl_adjust_point(string, point); end

    def _rl_any_typein; end

    # Process C as part of the current numeric argument.  Return -1 if the
    #   argument should be aborted, 0 if we should not read any more chars, and
    #   1 if we should continue to read chars.
    def _rl_arg_dispatch(cxt, c); end

    def _rl_arg_getchar; end
    def _rl_arg_init; end
    def _rl_arg_overflow; end

    # Move the cursor back.
    def _rl_backspace(count); end

    def _rl_bind_tty_special_chars(kmap); end
    def _rl_char_search(count, fdir, bdir); end
    def _rl_char_search_internal(count, dir, smbchar, len); end
    def _rl_char_value(buf, ind); end
    def _rl_clean_up_for_exit; end
    def _rl_clear_screen; end

    # Clear to the end of the line.  COUNT is the minimum
    #   number of character spaces to clear,
    def _rl_clear_to_eol(count); end

    def _rl_col_width(string, start, _end); end

    # compare the specified two characters. If the characters matched,
    #   return true. Otherwise return false.
    def _rl_compare_chars(buf1, pos1, buf2, pos2); end

    def _rl_control_keypad(on); end

    # Add TEXT to the kill ring, allocating a new kill ring slot as necessary.
    #   This uses TEXT directly, so the caller must not free it.  If APPEND is
    #   non-zero, and the last command was a kill, the text is appended to the
    #   current kill ring slot, otherwise prepended.
    def _rl_copy_to_kill_ring(text, append); end

    # return the `current display line' of the cursor -- the number of lines to
    #   move up to get to the first screen line of the current readline line.
    def _rl_current_display_line; end

    # Do the command associated with KEY in MAP.
    #   If the associated command is really a keymap, then read
    #   another key, and dispatch into that map.
    def _rl_dispatch(key, map); end

    def _rl_dispatch_subseq(key, map, got_subseq); end
    def _rl_enable_meta_key; end

    # Quick redisplay hack when erasing characters at the end of the line.
    def _rl_erase_at_end_of_line(l); end

    def _rl_erase_entire_line; end
    def _rl_find_completion_word; end

    # Find next `count' characters started byte point of the specified seed.
    #   If flags is MB_FIND_NONZERO, we look for non-zero-width multibyte
    #   characters.
    def _rl_find_next_mbchar(string, seed, count, flags); end

    # Find previous character started byte point of the specified seed.
    #   Returned point will be point <= seed.  If flags is MB_FIND_NONZERO,
    #   we look for non-zero-width multibyte characters.
    def _rl_find_prev_mbchar(string, seed, flags); end

    def _rl_fix_point(fix_mark_too); end

    # return the number of bytes parsed from the multibyte sequence starting
    # at src, if a non-L'\0' wide character was recognized. It returns 0,
    # if a L'\0' wide character was recognized. It  returns (size_t)(-1),
    # if an invalid multibyte sequence was encountered. It returns (size_t)(-2)
    # if it couldn't parse a complete  multibyte character.
    def _rl_get_char_len(src); end

    # Get readline's idea of the screen size.  TTY is a file descriptor open
    #   to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
    #   values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
    #   non-null serve to check whether or not we have initialized termcap.
    def _rl_get_screen_size(tty, ignore_env); end

    def _rl_history_set_point; end
    def _rl_init_eightbit; end
    def _rl_init_line_state; end
    def _rl_init_terminal_io(terminal_name); end
    def _rl_input_available; end

    # Insert the character C at the current location, moving point forward.
    #   If C introduces a multibyte sequence, we read the whole sequence and
    #   then insert the multibyte char into the line buffer.
    def _rl_insert_char(count, c); end

    # Insert the next typed character verbatim.
    def _rl_insert_next(count); end

    def _rl_insert_typein(c); end
    def _rl_internal_char_cleanup; end
    def _rl_internal_pager(lines); end
    def _rl_is_mbchar_matched(string, seed, _end, mbchar, length); end
    def _rl_isearch_cleanup(cxt, r); end

    # Process just-read character C according to isearch context CXT.  Return
    #   -1 if the caller should just free the context and return, 0 if we should
    #   break out of the loop, and 1 if we should continue to read characters.
    def _rl_isearch_dispatch(cxt, c); end

    def _rl_isearch_fini(cxt); end
    def _rl_isearch_init(direction); end
    def _rl_make_prompt_for_search(pchar); end

    # Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.
    #   (Well, when we don't have multibyte characters, _rl_last_c_pos is a
    #   buffer index.)
    #   DATA is the contents of the screen line of interest; i.e., where
    #   the movement is being done.
    def _rl_move_cursor_relative(new, data, start = T.unsafe(nil)); end

    # PWP: move the cursor up or down.
    def _rl_move_vert(to); end

    def _rl_nsearch_abort(cxt); end
    def _rl_nsearch_cleanup(cxt, r); end

    # Process just-read character C according to search context CXT.  Return -1
    #   if the caller should abort the search, 0 if we should break out of the
    #   loop, and 1 if we should continue to read characters.
    def _rl_nsearch_dispatch(cxt, c); end

    # Perform one search according to CXT, using NONINC_SEARCH_STRING.  Return
    #   -1 if the search should be aborted, any other value means to clean up
    #   using _rl_nsearch_cleanup ().  Returns 1 if the search was successful,
    #   0 otherwise.
    def _rl_nsearch_dosearch(cxt); end

    def _rl_nsearch_init(dir, pchar); end

    # Write COUNT characters from STRING to the output stream.
    def _rl_output_some_chars(string, start, count); end

    # Overwrite the character at point (or next COUNT characters) with C.
    #   If C introduces a multibyte character sequence, read the entire sequence
    #   before starting the overwrite loop.
    def _rl_overwrite_char(count, c); end

    # This is different from what vi does, so the code's not shared.  Emacs
    #   rubout in overwrite mode has one oddity:  it replaces a control
    #   character that's displayed as two characters (^X) with two spaces.
    def _rl_overwrite_rubout(count, key); end

    def _rl_read_init_file(filename, include_level); end

    # read multibyte char
    def _rl_read_mbchar(mbchar, size); end

    # Read a multibyte-character string whose first character is FIRST into
    #   the buffer MB of length MLEN.  Returns the last character read, which
    #   may be FIRST.  Used by the search functions, among others.  Very similar
    #   to _rl_read_mbchar.
    def _rl_read_mbstring(first, mb, mlen); end

    # Redisplay the current line after a SIGWINCH is received.
    def _rl_redisplay_after_sigwinch; end

    # Replace the contents of the line buffer between START and END with
    #   TEXT.  The operation is undoable.  To replace the entire line in an
    #   undoable mode, use _rl_replace_text(text, 0, rl_end)
    def _rl_replace_text(text, start, _end); end

    # Create a default argument.
    def _rl_reset_argument; end

    def _rl_rubout_char(count, key); end
    def _rl_scxt_alloc(type, flags); end
    def _rl_search_getchar(cxt); end

    # Function for the rest of the library to use to set insert/overwrite mode.
    def _rl_set_insert_mode(im, force); end

    # Set the mark at POSITION.
    def _rl_set_mark_at_pos(position); end

    # Set the history pointer back to the last entry in the history.
    def _rl_start_using_history; end

    def _rl_strip_prompt(pmt); end
    def _rl_subseq_getchar(key); end
    def _rl_to_lower(char); end

    # Stuff KEY into the *front* of the input buffer.
    #   Returns non-zero if successful, zero if there is
    #   no space left in the buffer.
    def _rl_unget_char(key); end

    def _rl_update_final; end
    def _rl_vi_done_inserting; end
    def _rl_vi_initialize_line; end
    def _rl_vi_reset_last; end
    def _rl_vi_save_insert(up); end

    # Is the command C a VI mode text modification command?
    def _rl_vi_textmod_command(c); end

    def _rl_walphabetic(c); end

    # Place STRING at the end of the history list.  The data field
    #   is  set to NULL.
    def add_history(string); end

    def alloc_history_entry(string, ts); end
    def alloc_undo_entry(what, start, _end, text); end

    # Append any necessary closing quote and a separator character to the
    # just-inserted match.  If the user has specified that directories
    # should be marked by a trailing `/', append one of those instead.  The
    # default trailing character is a space.  Returns the number of characters
    # appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS
    # has them) and don't add a suffix for a symlink to a directory.  A
    # nontrivial match is one that actually adds to the word being completed.
    # The variable rl_completion_mark_symlink_dirs controls this behavior
    # (it's initially set to the what the user has chosen, indicated by the
    # value of _rl_complete_mark_symlink_dirs, but may be modified by an
    # application's completion function).
    def append_to_match(text, delimiter, quote_char, nontrivial_match); end

    # Try and bind the common arrow key prefixes after giving termcap and
    #   the inputrc file a chance to bind them and create `real' keymaps
    #   for the arrow key prefix.
    def bind_arrow_keys; end

    # Bind some common arrow key sequences in MAP.
    def bind_arrow_keys_internal(map); end

    # Bind the arrow key sequences from the termcap description in MAP.
    def bind_termcap_arrow_keys(map); end

    def block_sigint; end
    def clear_history; end

    # Find the common prefix of the list of matches, and put it into
    #   matches[0].
    def compute_lcd_of_matches(match_list, matches, text); end

    # Move to the start of the current line.
    def cr; end

    def cr_faster(new, cur); end
    def ctrl_char(c); end

    # Return the history entry at the current position, as determined by
    #   history_offset.  If there is no entry there, return a NULL pointer.
    def current_history; end

    # Delete COUNT characters from the display line.
    def delete_chars(count); end

    # Display MATCHES, a list of matching filenames in argv format.  This
    # handles the simple case -- a single match -- first.  If there is more
    # than one match, we compute the number of strings in the list and the
    # length of the longest string, which will be needed by the display
    # function.  If the application wants to handle displaying the list of
    # matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the
    # address of a function, and we just call it.  If we're handling the
    # display ourselves, we just call rl_display_match_list.  We also check
    # that the list of matches doesn't exceed the user-settable threshold,
    # and ask the user if he wants to see the list if there are more matches
    # than RL_COMPLETION_QUERY_ITEMS.
    def display_matches(matches); end

    def endsrch_char(c); end

    # Current implementation:
    #    \001 (^A) start non-visible characters
    #    \002 (^B) end non-visible characters
    #   all characters except \001 and \002 (following a \001) are copied to
    #   the returned string all characters except those between \001 and
    #   \002 are assumed to be `visible'.
    def expand_prompt(pmt); end

    def fnprint(to_print); end

    # Compute width of STRING when displayed on screen by print_filename
    def fnwidth(string); end

    def gen_completion_matches(text, start, _end, our_func, found_quote, quote_char); end
    def get_term_capabilities(buffer); end

    # The user must press "y" or "n". Non-zero return means "y" pressed.
    def get_y_or_n(for_pager); end

    # Handle a parser directive.  STATEMENT is the line of the directive
    #   without any leading `$'.
    def handle_parser_directive(statement); end

    def hist_inittime; end
    def history_arg_extract(first, last, string); end

    # Returns the value of attribute history_base.
    def history_base; end

    # Return the history entry which is logically at OFFSET in the history array.
    #   OFFSET is relative to history_base.
    def history_get(offset); end

    def history_is_stifled; end

    # Returns the value of attribute history_length.
    def history_length; end

    def history_list; end

    # Search for STRING in the history list.  DIR is < 0 for searching
    #   backwards.  POS is an absolute index into the history list at
    #   which point to begin searching.
    def history_search_pos(string, dir, pos); end

    # Do an anchored search for string through the history in DIRECTION.
    def history_search_prefix(string, direction); end

    # Make the current history item be the one at POS, an absolute index.
    #   Returns zero if POS is out of range, else non-zero.
    def history_set_pos(pos); end

    # Return the amount of space available in the buffer for stuffing
    #   characters.
    def ibuffer_space; end

    # Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated
    #   arrays of line break markers.  MINSIZE is the minimum size of VISIBLE_LINE
    #   and INVISIBLE_LINE; if it is greater than LINE_SIZE, LINE_SIZE is
    #   increased.  If the lines have already been allocated, this ensures that
    #   they can hold at least MINSIZE characters.
    def init_line_structures(minsize); end

    def insert_all_matches(matches, point, qc); end
    def insert_match(match, start, mtype, qc); end

    # Insert COUNT characters from STRING to the output stream at column COL.
    def insert_some_chars(string, count, col); end

    def inv_line(line); end
    def inv_llen(l); end
    def isascii(c); end
    def isprint(c); end
    def m_offset(margin, offset); end

    # Make the data from the history entry ENTRY be the contents of the
    #   current line.  This doesn't do anything with rl_point; the caller
    #   must set it.
    def make_history_line_current(entry); end

    def make_quoted_replacement(match, mtype, qc); end
    def meta_char(c); end

    # Move history_offset forward to the next history entry, and return
    #   a pointer to that entry.  If there is no next entry then return a
    #   NULL pointer.
    def next_history; end

    # @return [Boolean]
    def no_terminal?; end

    # Search for a line in the history containing STRING.  If DIR is < 0, the
    #   search is backwards through previous entries, else through subsequent
    #   entries.  Returns 1 if the search was successful, 0 otherwise.
    def noninc_dosearch(string, dir); end

    # Search non-interactively through the history list.  DIR < 0 means to
    #   search backwards through the history of previous commands; otherwise
    #   the search is for commands subsequent to the current position in the
    #   history list.  PCHAR is the character to use for prompting when reading
    #   the search string; if not specified (0), it defaults to `:'.
    def noninc_search(dir, pchar); end

    # Search the history list for STRING starting at absolute history position
    #   POS.  If STRING begins with `^', the search must match STRING at the
    #   beginning of a history line, otherwise a full substring match is performed
    #   for STRING.  DIR < 0 means to search backwards through the history list,
    #   DIR >= 0 means to search forward.
    def noninc_search_from_pos(string, pos, dir); end

    # Invert the current parser state if there is anything on the stack.
    def parser_else(args); end

    # Terminate a conditional, popping the value of
    #   _rl_parsing_conditionalized_out from the stack.
    def parser_endif(args); end

    # Push _rl_parsing_conditionalized_out, and set parser state based
    #   on ARGS.
    def parser_if(args); end

    def parser_include(args); end
    def path_isdir(filename); end
    def postprocess_matches(matchesp, matching_filenames); end
    def prepare_terminal_settings(meta_flag); end

    # Back up history_offset to the previous history entry, and return
    #   a pointer to that entry.  If there is no previous entry then return
    #   a NULL pointer.
    def previous_history; end

    # Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
    #   are using it, check for and output a single character for `special'
    #   filenames.  Return the number of characters we output.
    def print_filename(to_print, full_pathname); end

    # Return the portion of PATHNAME that should be output when listing
    #   possible completions.  If we are hacking filename completion, we
    #   are only interested in the basename, the portion following the
    #   final slash.  Otherwise, we return what we were passed.  Since
    #   printing empty strings is not very informative, if we're doing
    #   filename completion, and the basename is the empty string, we look
    #   for the previous slash and return the portion following that.  If
    #   there's no previous slash, we just return what we were passed.
    def printable_part(pathname); end

    # * _rl_last_c_pos is an absolute cursor position in multibyte locales and a
    #   buffer index in others.  This macro is used when deciding whether the
    #   current cursor position is in the middle of a prompt string containing
    #   invisible characters.
    def prompt_ending_index; end

    # Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
    #   none.  A return value of NULL means that EOF was encountered.
    def readline(prompt); end

    # If this system allows us to look at the values of the regular
    #   input editing characters, then bind them to their readline
    #   equivalents, iff the characters are not bound to keymaps.
    def readline_default_bindings; end

    # Initialize the entire state of the world.
    def readline_initialize_everything; end

    # Read a line of input from the global rl_instream, doing output on
    #   the global rl_outstream.
    #   If rl_prompt is non-null, then that is our prompt.
    def readline_internal; end

    def readline_internal_charloop; end
    def readline_internal_setup; end
    def readline_internal_teardown(eof); end

    # Redraw the last line of a multi-line prompt that may possibly contain
    # terminal escape sequences.  Called with the cursor at column 0 of the
    # line to draw the prompt on.
    def redraw_prompt(t); end

    def release_sigint; end

    # Filter out duplicates in MATCHES.  This frees up the strings in
    #   MATCHES.
    def remove_duplicate_matches(matches); end

    # Remove history element WHICH from the history.  The removed
    #   element is returned to you so you can free the line, data,
    #   and containing structure.
    def remove_history(which); end

    # Replace the DATA in the specified history entries, replacing OLD with
    #   NEW.  WHICH says which one(s) to replace:  WHICH == -1 means to replace
    #   all of the history entries where entry->data == OLD; WHICH == -2 means
    #   to replace the `newest' history entry where entry->data == OLD; and
    #   WHICH >= 0 means to replace that particular history entry's data, as
    #   long as it matches OLD.
    def replace_history_data(which, old, new); end

    # Make the history entry at WHICH have LINE and DATA.  This returns
    #   the old entry so you can dispose of the data.  In the case of an
    #   invalid WHICH, a NULL pointer is returned.
    def replace_history_entry(which, line, data); end

    def retry_if_interrupted(&block); end
    def rl_abort(count, key); end

    # * Remember how to undo something.  Concatenate some undos if that
    #   seems right.
    def rl_add_undo(what, start, _end, text); end

    def rl_alphabetic(c); end
    def rl_arrow_keys(count, c); end

    # Returns the value of attribute rl_attempted_completion_function.
    def rl_attempted_completion_function; end

    # Sets the attribute rl_attempted_completion_function
    #
    # @param value the value to set the attribute rl_attempted_completion_function to.
    def rl_attempted_completion_function=(_arg0); end

    # Returns the value of attribute rl_attempted_completion_over.
    def rl_attempted_completion_over; end

    # Sets the attribute rl_attempted_completion_over
    #
    # @param value the value to set the attribute rl_attempted_completion_over to.
    def rl_attempted_completion_over=(_arg0); end

    # Backwards compatibility.
    def rl_backward(count, key); end

    # Move backward COUNT bytes.
    def rl_backward_byte(count, key); end

    # Move backward COUNT characters.
    def rl_backward_char(count, key); end

    def rl_backward_char_search(count, key); end

    # Kill backwards to the start of the line.  If DIRECTION is negative, kill
    #   forwards to the line end instead.
    def rl_backward_kill_line(direction, ignore); end

    # Rubout the word before point, placing it on the kill ring.
    def rl_backward_kill_word(count, ignore); end

    # Move backward a word.  We do what Emacs does.  Handles multibyte chars.
    def rl_backward_word(count, key); end

    # Returns the value of attribute rl_basic_quote_characters.
    def rl_basic_quote_characters; end

    # Sets the attribute rl_basic_quote_characters
    #
    # @param value the value to set the attribute rl_basic_quote_characters to.
    def rl_basic_quote_characters=(_arg0); end

    # Returns the value of attribute rl_basic_word_break_characters.
    def rl_basic_word_break_characters; end

    # Sets the attribute rl_basic_word_break_characters
    #
    # @param value the value to set the attribute rl_basic_word_break_characters to.
    def rl_basic_word_break_characters=(_arg0); end

    # Move to the beginning of the line.
    def rl_beg_of_line(count, key); end

    # Begin a group.  Subsequent undos are undone as an atomic operation.
    def rl_begin_undo_group; end

    # Meta-< goes to the start of the history.
    def rl_beginning_of_history(count, key); end

    # Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range.
    def rl_bind_key(key, function); end

    def rl_bind_keyseq_if_unbound(keyseq, default_func); end

    # Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right
    #   now, this is always used to attempt to bind the arrow keys, hence the
    #   check for rl_vi_movement_mode.
    def rl_bind_keyseq_if_unbound_in_map(keyseq, default_func, kmap); end

    # Bind the key sequence represented by the string KEYSEQ to
    #   FUNCTION.  This makes new keymaps as necessary.  The initial
    #   place to do bindings is in MAP.
    def rl_bind_keyseq_in_map(keyseq, function, map); end

    # Upcase the first letter, downcase the rest.
    def rl_capitalize_word(count, key); end

    # The meaty function.
    #   Change the case of COUNT words, performing OP on them.
    #   OP is one of UpCase, DownCase, or CapCase.
    #   If a negative argument is given, leave point where it started,
    #   otherwise, leave it where it moves to.
    def rl_change_case(count, op); end

    def rl_char_search(count, key); end
    def rl_character_len(c, pos); end

    # Clean up the terminal and readline state after catching a signal, before
    #   resending it to the calling application.
    def rl_cleanup_after_signal; end

    # How to clear things from the "echo-area".
    def rl_clear_message; end

    # Clear any pending input pushed with rl_execute_next()
    def rl_clear_pending_input; end

    # C-l typed to a line without quoting clears the screen, and then reprints
    #   the prompt and the current input line.  Given a numeric arg, redraw only
    #   the current line.
    def rl_clear_screen(count, key); end

    def rl_clear_signals; end

    # Complete the word at or before point.  You have supplied the function
    #   that does the initial simple matching selection algorithm (see
    #   rl_completion_matches ()).  The default is to do filename completion.
    def rl_complete(ignore, invoking_key); end

    # Complete the word at or before point.
    #   WHAT_TO_DO says what to do with the completion.
    #   `?' means list the possible completions.
    #   TAB means do standard completion.
    #   `*' means insert all of the possible completions.
    #   `!' means to do standard completion, and list all possible completions if
    #   there is more than one.
    #   `@' means to do standard completion, and list all possible completions if
    #   there is more than one and partial completion is not possible.
    def rl_complete_internal(what_to_do); end

    # Returns the value of attribute rl_completer_quote_characters.
    def rl_completer_quote_characters; end

    # Sets the attribute rl_completer_quote_characters
    #
    # @param value the value to set the attribute rl_completer_quote_characters to.
    def rl_completer_quote_characters=(_arg0); end

    # Returns the value of attribute rl_completer_word_break_characters.
    def rl_completer_word_break_characters; end

    # Sets the attribute rl_completer_word_break_characters
    #
    # @param value the value to set the attribute rl_completer_word_break_characters to.
    def rl_completer_word_break_characters=(_arg0); end

    # Returns the value of attribute rl_completion_append_character.
    def rl_completion_append_character; end

    # Sets the attribute rl_completion_append_character
    #
    # @param value the value to set the attribute rl_completion_append_character to.
    def rl_completion_append_character=(_arg0); end

    # Return an array of (char *) which is a list of completions for TEXT.
    #   If there are no completions, return a NULL pointer.
    #   The first entry in the returned array is the substitution for TEXT.
    #   The remaining entries are the possible completions.
    #   The array is terminated with a NULL pointer.
    #
    #   ENTRY_FUNCTION is a function of two args, and returns a (char *).
    #     The first argument is TEXT.
    #     The second is a state argument it should be zero on the first call, and
    #     non-zero on subsequent calls.  It returns a NULL pointer to the caller
    #     when there are no more matches.
    def rl_completion_matches(text, entry_function); end

    def rl_copy_text(from, to); end

    # Move to the start of the next line.
    def rl_crlf; end

    # Delete the character under the cursor.  Given a numeric argument,
    #   kill that many characters instead.
    def rl_delete(count, key); end

    # Delete all spaces and tabs around point.
    def rl_delete_horizontal_space(count, ignore); end

    # Like the tcsh editing function delete-char-or-list.  The eof character
    #   is caught before this is invoked, so this really does the same thing as
    #   delete-char-or-list-or-eof, as long as it's bound to the eof character.
    def rl_delete_or_show_completions(count, key); end

    # Delete the string between FROM and TO.  FROM is inclusive, TO is not.
    #   Returns the number of characters deleted.
    def rl_delete_text(from, to); end

    # Returns the value of attribute rl_deprep_term_function.
    def rl_deprep_term_function; end

    # Sets the attribute rl_deprep_term_function
    #
    # @param value the value to set the attribute rl_deprep_term_function to.
    def rl_deprep_term_function=(_arg0); end

    # Restore the terminal's normal settings and modes.
    def rl_deprep_terminal; end

    # Start a numeric argument with initial value KEY
    def rl_digit_argument(ignore, key); end

    # Handle C-u style numeric args, as well as M--, and M-digits.
    def rl_digit_loop; end

    # Ring the terminal bell.
    def rl_ding; end

    # A convenience function for displaying a list of strings in
    #   columnar format on readline's output stream.  MATCHES is the list
    #   of strings, in argv format, LEN is the number of strings in MATCHES,
    #   and MAX is the length of the longest string in MATCHES.
    def rl_display_match_list(matches, len, max); end

    # Display the current state of the search in the echo-area.
    #   SEARCH_STRING contains the string that is being searched for,
    #   DIRECTION is zero for forward, or non-zero for reverse,
    #   WHERE is the history list number of the current line.  If it is
    #   -1, then this line is the starting one.
    def rl_display_search(search_string, reverse_p, where); end

    # What to do for some uppercase characters, like meta characters,
    #   and some characters appearing in emacs_ctlx_keymap.  This function
    #   is just a stub, you bind keys to it and the code in _rl_dispatch ()
    #   is special cased.
    def rl_do_lowercase_version(ignore1, ignore2); end

    def rl_do_undo; end

    # Lowercase the word at point.
    def rl_downcase_word(count, key); end

    def rl_emacs_editing_mode(count, key); end

    # Meta-> goes to the end of the history.  (The current line).
    def rl_end_of_history(count, key); end

    # Move to the end of the line.
    def rl_end_of_line(count, key); end

    # End an undo group started with rl_begin_undo_group ().
    def rl_end_undo_group; end

    # Returns the value of attribute rl_event_hook.
    def rl_event_hook; end

    # Sets the attribute rl_event_hook
    #
    # @param value the value to set the attribute rl_event_hook to.
    def rl_event_hook=(_arg0); end

    # Exchange the position of mark and point.
    def rl_exchange_point_and_mark(count, key); end

    # Make C be the next command to be executed.
    def rl_execute_next(c); end

    # *
    # * Expand the prompt string into the various display components, if
    # * necessary.
    # *
    # * local_prompt = expanded last line of string in rl_display_prompt
    # *          (portion after the final newline)
    # * local_prompt_prefix = portion before last newline of rl_display_prompt,
    # *             expanded via expand_prompt
    # * prompt_visible_length = number of visible characters in local_prompt
    # * prompt_prefix_length = number of visible characters in local_prompt_prefix
    # *
    # * This function is called once per call to readline().  It may also be
    # * called arbitrarily to expand the primary prompt.
    # *
    # * The return value is the number of visible characters on the last line
    # * of the (possibly multi-line) prompt.
    # *
    def rl_expand_prompt(prompt); end

    # Increase the size of RL_LINE_BUFFER until it has enough space to hold
    #   LEN characters.
    def rl_extend_line_buffer(len); end

    # Okay, now we write the entry_function for filename completion.  In the
    # general case.  Note that completion in the shell is a little different
    # because of all the pathnames that must be followed when looking up the
    # completion for a command.
    def rl_filename_completion_function(text, state); end

    # Returns the value of attribute rl_filename_quote_characters.
    def rl_filename_quote_characters; end

    # Sets the attribute rl_filename_quote_characters
    #
    # @param value the value to set the attribute rl_filename_quote_characters to.
    def rl_filename_quote_characters=(_arg0); end

    # Actually update the display, period.
    def rl_forced_update_display; end

    # Backwards compatibility.
    def rl_forward(count, key); end

    # Move forward COUNT bytes.
    def rl_forward_byte(count, key); end

    # Move forward COUNT characters.
    def rl_forward_char(count, key); end

    # Search forwards through the history looking for a string which is typed
    #   interactively.  Start with the current line.
    def rl_forward_search_history(sign, key); end

    # Move forward a word.  We do what Emacs does.  Handles multibyte chars.
    def rl_forward_word(count, key); end

    def rl_free_undo_list; end

    # Return the function (or macro) definition which would be invoked via
    #   KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is
    #   used.  TYPE, if non-NULL, is a pointer to an int which will receive the
    #   type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
    #   or ISMACR (macro).
    def rl_function_of_keyseq(keyseq, map, type); end

    def rl_gather_tyi; end

    # Bind the key sequence represented by the string KEYSEQ to
    #   the arbitrary pointer DATA.  TYPE says what kind of data is
    #   pointed to by DATA, right now this can be a function (ISFUNC),
    #   a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps
    #   as necessary.  The initial place to do bindings is in MAP.
    def rl_generic_bind(type, keyseq, data, map); end

    # Get a key from the buffer of characters to be read.
    #   Return the key in KEY.
    #   Result is KEY if there was a key, or 0 if there wasn't.
    def rl_get_char; end

    def rl_get_keymap_name_from_edit_mode; end

    # Move down to the next history line.
    def rl_get_next_history(count, key); end

    # Get the previous item out of our interactive history, making it the current
    #   line.  If there is no previous history, just ding.
    def rl_get_previous_history(count, key); end

    def rl_getc(stream); end

    # Initialize readline (and terminal if not already).
    def rl_initialize; end

    def rl_insert(count, c); end

    # Turn the current line into a comment in shell history.
    #   A K*rn shell style function.
    def rl_insert_comment(count, key); end

    def rl_insert_completions(ignore, invoking_key); end

    # Insert a string of text into the line at point.  This is the only
    #   way that you should do insertion.  _rl_insert_char () calls this
    #   function.  Returns the number of characters inserted.
    def rl_insert_text(string); end

    # Returns the value of attribute rl_instream.
    def rl_instream; end

    # Sets the attribute rl_instream
    #
    # @param value the value to set the attribute rl_instream to.
    def rl_instream=(_arg0); end

    def rl_isstate(x); end

    # Kill the whole line, no matter where point is.
    def rl_kill_full_line(count, ignore); end

    # Kill from here to the end of the line.  If DIRECTION is negative, kill
    #   back to the line start instead.
    def rl_kill_line(direction, ignore); end

    # The way to kill something.  This appends or prepends to the last
    #   kill, if the last command was a kill command.  if FROM is less
    #   than TO, then the text is appended, otherwise prepended.  If the
    #   last command was not a kill command, then a new slot is made for
    #   this kill.
    def rl_kill_text(from, to); end

    # Delete the word at point, saving the text in the kill ring.
    def rl_kill_word(count, key); end

    # Returns the value of attribute rl_library_version.
    def rl_library_version; end

    # Sets the attribute rl_library_version
    #
    # @param value the value to set the attribute rl_library_version to.
    def rl_library_version=(_arg0); end

    def rl_line_buffer; end

    # Perhaps put back the current line if it has changed.
    def rl_maybe_replace_line; end

    # Save the current line in _rl_saved_line_for_history.
    def rl_maybe_save_line; end

    # Restore the _rl_saved_line_for_history if there is one.
    def rl_maybe_unsave_line; end

    def rl_message(msg_buf); end

    # Save an undo entry for the text from START to END.
    def rl_modifying(start, _end); end

    def rl_named_function(name); end

    # What to do when a NEWLINE is pressed.  We accept the whole line.
    #   KEY is the key that invoked this command.  I guess it could have
    #   meaning in the future.
    def rl_newline(count, key); end

    # Search forward through the history list for a string.  If the vi-mode
    #   code calls this, KEY will be `?'.
    def rl_noninc_forward_search(count, key); end

    # Reverse search the history list for a string.  If the vi-mode code
    #   calls this, KEY will be `/'.
    def rl_noninc_reverse_search(count, key); end

    # Tell the update routines that we have moved onto a new (empty) line.
    def rl_on_new_line; end

    # Tell the update routines that we have moved onto a new line with the
    #   prompt already displayed.  Code originally from the version of readline
    #   distributed with CLISP.  rl_expand_prompt must have already been called
    #   (explicitly or implicitly).  This still doesn't work exactly right.
    def rl_on_new_line_with_prompt; end

    # Returns the value of attribute rl_outstream.
    def rl_outstream; end

    # Sets the attribute rl_outstream
    #
    # @param value the value to set the attribute rl_outstream to.
    def rl_outstream=(_arg0); end

    # Toggle overwrite mode.  A positive explicit argument selects overwrite
    #   mode.  A negative or zero explicit argument selects insert mode.
    def rl_overwrite_mode(count, key); end

    # Read the binding command from STRING and perform it.
    #   A key binding command looks like: Keyname: function-name\0,
    #   a variable binding command looks like: set variable value.
    #   A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark.
    def rl_parse_and_bind(string); end

    # Returns the value of attribute rl_point.
    def rl_point; end

    # List the possible completions.  See description of rl_complete ().
    def rl_possible_completions(ignore, invoking_key); end

    def rl_prep_terminal(meta_flag); end
    def rl_quoted_insert(count, key); end

    # Re-read the current keybindings file.
    def rl_re_read_init_file(count, ignore); end

    # Do key bindings from a file.  If FILENAME is NULL it defaults
    #   to the first non-null filename from this list:
    #     1. the filename used for the previous call
    #     2. the value of the shell variable `INPUTRC'
    #     3. ~/.inputrc
    #     4. /etc/inputrc
    #   If the file existed and could be opened and read, 0 is returned,
    #   otherwise errno is returned.
    def rl_read_init_file(filename); end

    # Read a key, including pending input.
    def rl_read_key; end

    # Returns the value of attribute rl_readline_name.
    def rl_readline_name; end

    # Sets the attribute rl_readline_name
    #
    # @param value the value to set the attribute rl_readline_name to.
    def rl_readline_name=(_arg0); end

    # Basic redisplay algorithm.
    def rl_redisplay; end

    # Clear the current line.  Numeric argument to C-l does this.
    def rl_refresh_line(ignore1, ignore2); end

    def rl_replace_from_history(entry, flags); end

    # Replace the current line buffer contents with TEXT.  If CLEAR_UNDO is
    #   non-zero, we free the current undo list.
    def rl_replace_line(text, clear_undo); end

    def rl_reset_line_state; end
    def rl_resize_terminal; end
    def rl_restart_output(count, key); end
    def rl_restore_prompt; end

    # Search backwards through the history looking for a string which is typed
    #   interactively.  Start with the current line.
    def rl_reverse_search_history(sign, key); end

    # Revert the current line to its previous state.
    def rl_revert_line(count, key); end

    # Rubout the character behind point.
    def rl_rubout(count, key); end

    # Delete the character under the cursor, unless the insertion
    #   point is at the end of the line, in which case the character
    #   behind the cursor is deleted.  COUNT is obeyed and may be used
    #   to delete forward or backward that many characters.
    def rl_rubout_or_delete(count, key); end

    def rl_save_prompt; end

    # Search through the history looking for an interactively typed string.
    #   This is analogous to i-search.  We start the search in the current line.
    #   DIRECTION is which direction to search; >= 0 means forward, < 0 means
    #   backwards.
    def rl_search_history(direction, invoking_key); end

    def rl_set_keymap_from_edit_mode; end

    # A bindable command to set the mark.
    def rl_set_mark(count, key); end

    # Set up the prompt and expand it.  Called from readline() and
    #   rl_callback_handler_install ().
    def rl_set_prompt(prompt); end

    def rl_set_signals; end
    def rl_setstate(x); end
    def rl_sigwinch_handler(sig); end

    # Add KEY to the buffer of characters to be read.  Returns 1 if the
    #   character was stuffed correctly; 0 otherwise.
    def rl_stuff_char(key); end

    # Insert a tab character.
    def rl_tab_insert(count, key); end

    # A function for simple tilde expansion.
    def rl_tilde_expand(ignore, key); end

    def rl_translate_keyseq(seq); end

    # Transpose the characters at point.  If point is at the end of the line,
    #   then transpose the characters before point.
    def rl_transpose_chars(count, key); end

    # Transpose the words at point.  If point is at the end of the line,
    #   transpose the two words before point.
    def rl_transpose_words(count, key); end

    # New public way to set the system default editing chars to their readline
    #   equivalents.
    def rl_tty_set_default_bindings(kmap); end

    # Rebind all of the tty special chars that readline worries about back
    #   to self-insert.  Call this before saving the current terminal special
    #   chars with save_tty_chars().  This only works on POSIX termios or termio
    #   systems.
    def rl_tty_unset_default_bindings(kmap); end

    # Do some undoing of things that were done.
    def rl_undo_command(count, key); end

    # This deletes one filename component in a Unix pathname.  That is, it
    #   deletes backward to directory separator (`/') or whitespace.
    def rl_unix_filename_rubout(count, key); end

    # Here is C-u doing what Unix does.  You don't *have* to use these
    # key-bindings.  We have a choice of killing the entire line, or
    # killing from where we are to the start of the line.  We choose the
    # latter, because if you are a Unix weenie, then you haven't backspaced
    # into the line at all, and if you aren't, then you know what you are
    # doing.
    def rl_unix_line_discard(count, key); end

    # This does what C-w does in Unix.  We can't prevent people from
    #   using behaviour that they expect.
    def rl_unix_word_rubout(count, key); end

    def rl_unsetstate(x); end

    # Uppercase the word at point.
    def rl_upcase_word(count, key); end

    # A completion function for usernames.
    #   TEXT contains a partial username preceded by a random
    #   character (usually `~').
    def rl_username_completion_function(text, state); end

    def rl_variable_bind(name, value); end
    def rl_vi_check; end

    # This is a NOOP until the rest of Vi-mode is working.
    def rl_vi_editing_mode(count, key); end

    # Switching from one mode to the other really just involves
    #   switching keymaps.
    def rl_vi_insertion_mode(count, key); end

    # Yank back the last killed text.  This ignores arguments.
    def rl_yank(count, ignore); end

    def rl_yank_last_arg(count, key); end

    # Yank the COUNTth argument from the previous history line.
    def rl_yank_nth_arg(count, ignore); end

    # Yank the COUNTh argument from the previous history line, skipping
    #   HISTORY_SKIP lines before looking for the `previous line'.
    def rl_yank_nth_arg_internal(count, ignore, history_skip); end

    # If the last command was yank, or yank_pop, and the text just
    #   before point is identical to the current kill item, then
    #   delete that text from the line, rotate the index down, and
    #   yank back some other text.
    def rl_yank_pop(count, key); end

    def save_tty_chars; end

    # Set default values for readline word completion.  These are the variables
    #   that application completion functions can change or inspect.
    def set_completion_defaults(what_to_do); end

    # Set the environment variables LINES and COLUMNS to lines and cols,
    #   respectively.
    def sh_set_lines_and_columns(lines, cols); end

    # Clear to the end of the line using spaces.  COUNT is the minimum
    #   number of character spaces to clear,
    def space_to_eol(count); end

    # Return the character which best describes FILENAME.
    #     `@' for symbolic links
    #     `/' for directories
    #     `*' for executables
    #     `=' for sockets
    #     `|' for FIFOs
    #     `%' for character special devices
    #     `#' for block special devices
    def stat_char(filename); end

    # Stifle the history list, remembering only MAX number of lines.
    def stifle_history(max); end

    def tgetflag(name); end

    # Undo the next thing in the list.  Return 0 if there
    #   is nothing to undo, or non-zero if there was.
    def trans(i); end

    # Stop stifling the history.  This returns the previous maximum
    #   number of history entries.  The value is positive if the history
    #   was stifled,  negative if it wasn't.
    def unstifle_history; end

    # PWP: update_line() is based on finding the middle difference of each
    #   line on the screen; vis:
    #
    #             /old first difference
    #  /beginning of line   |        /old last same       /old EOL
    #  v          v         v         v
    # old:   eddie> Oh, my little gruntle-buggy is to me, as lurgid as
    # new:   eddie> Oh, my little buggy says to me, as lurgid as
    #  ^          ^   ^           ^
    #  \beginning of line   |  \new last same    \new end of line
    #             \new first difference
    #
    #   All are character pointers for the sake of speed.  Special cases for
    #   no differences, as well as for end of line additions must be handled.
    #
    #   Could be made even smarter, but this works well enough
    def update_line(old, ostart, new, current_line, omax, nmax, inv_botlin); end

    def using_history; end
    def vis_chars(line); end
    def vis_line(line); end
    def vis_llen(l); end
    def vis_pos(line); end
    def w_offset(line, offset); end

    # Returns the magic number which says what history element we are
    #   looking at now.  In this implementation, it returns history_offset.
    def where_history; end

    def whitespace(c); end
  end
end

RbReadline::ABORT_CHAR = T.let(T.unsafe(nil), String)

# Possible definitions for history starting point specification.
RbReadline::ANCHORED_SEARCH = T.let(T.unsafe(nil), Integer)

RbReadline::ANYOTHERKEY = T.let(T.unsafe(nil), Integer)
RbReadline::AUDIBLE_BELL = T.let(T.unsafe(nil), Integer)
RbReadline::BAD_MODIFIER = T.let(T.unsafe(nil), Integer)
RbReadline::BAD_WORD_SPEC = T.let(T.unsafe(nil), Integer)

# forward find
RbReadline::BFIND = T.let(T.unsafe(nil), Integer)

# forward to
RbReadline::BTO = T.let(T.unsafe(nil), Integer)

RbReadline::CapCase = T.let(T.unsafe(nil), Integer)
RbReadline::DEFAULT_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)
RbReadline::DEFAULT_INPUTRC = T.let(T.unsafe(nil), String)
RbReadline::DEFAULT_MAX_KILLS = T.let(T.unsafe(nil), Integer)
RbReadline::DownCase = T.let(T.unsafe(nil), Integer)
RbReadline::EOF = T.let(T.unsafe(nil), String)
RbReadline::ESC = T.let(T.unsafe(nil), String)

# Possible history errors passed to hist_error.
RbReadline::EVENT_NOT_FOUND = T.let(T.unsafe(nil), Integer)

# backward to
RbReadline::FFIND = T.let(T.unsafe(nil), Integer)

# Definitions used when searching the line for characters.
# NOTE: it is necessary that opposite directions are inverses
RbReadline::FTO = T.let(T.unsafe(nil), Integer)

# Possible definitions for what style of writing the history file we want.
RbReadline::HISTORY_APPEND = T.let(T.unsafe(nil), Integer)

RbReadline::HISTORY_OVERWRITE = T.let(T.unsafe(nil), Integer)
RbReadline::HISTORY_QUOTE_CHARACTERS = T.let(T.unsafe(nil), String)
RbReadline::HISTORY_WORD_DELIMITERS = T.let(T.unsafe(nil), String)
RbReadline::ISFUNC = T.let(T.unsafe(nil), Integer)
RbReadline::ISKMAP = T.let(T.unsafe(nil), Integer)
RbReadline::ISMACR = T.let(T.unsafe(nil), Integer)
RbReadline::KEYMAP_SIZE = T.let(T.unsafe(nil), Integer)

# A context for reading key sequences longer than a single character when
#   using the callback interface.
RbReadline::KSEQ_DISPATCHED = T.let(T.unsafe(nil), Integer)

RbReadline::KSEQ_RECURSIVE = T.let(T.unsafe(nil), Integer)
RbReadline::KSEQ_SUBSEQ = T.let(T.unsafe(nil), Integer)
RbReadline::MB_FIND_ANY = T.let(T.unsafe(nil), Integer)
RbReadline::MB_FIND_NONZERO = T.let(T.unsafe(nil), Integer)
RbReadline::MB_LEN_MAX = T.let(T.unsafe(nil), Integer)
RbReadline::MULT_MATCH = T.let(T.unsafe(nil), Integer)
RbReadline::NEWLINE = T.let(T.unsafe(nil), String)
RbReadline::NON_ANCHORED_SEARCH = T.let(T.unsafe(nil), Integer)

# done accepted line
RbReadline::NO_BELL = T.let(T.unsafe(nil), Integer)

# Possible values for do_replace argument to rl_filename_quoting_function,
#   called by rl_complete_internal.
RbReadline::NO_MATCH = T.let(T.unsafe(nil), Integer)

RbReadline::NO_PREV_SUBST = T.let(T.unsafe(nil), Integer)
RbReadline::NUM_READONE = T.let(T.unsafe(nil), Integer)
RbReadline::NUM_SAWDIGITS = T.let(T.unsafe(nil), Integer)

# Callback data for reading numeric arguments
RbReadline::NUM_SAWMINUS = T.let(T.unsafe(nil), Integer)

RbReadline::PAGE = T.let(T.unsafe(nil), String)
RbReadline::RB_READLINE_VERSION = T.let(T.unsafe(nil), String)

# Input error; can be returned by (*rl_getc_function) if readline is reading
#   a top-level command (RL_ISSTATE (RL_STATE_READCMD)).
RbReadline::READERR = T.let(T.unsafe(nil), String)

RbReadline::RETURN = T.let(T.unsafe(nil), String)
RbReadline::RL_IM_DEFAULT = T.let(T.unsafe(nil), Integer)
RbReadline::RL_IM_INSERT = T.let(T.unsafe(nil), Integer)
RbReadline::RL_IM_OVERWRITE = T.let(T.unsafe(nil), Integer)
RbReadline::RL_LIBRARY_VERSION = T.let(T.unsafe(nil), String)
RbReadline::RL_PROMPT_END_IGNORE = T.let(T.unsafe(nil), String)

# Definitions available for use by readline clients.
RbReadline::RL_PROMPT_START_IGNORE = T.let(T.unsafe(nil), String)

RbReadline::RL_QF_BACKSLASH = T.let(T.unsafe(nil), Integer)
RbReadline::RL_QF_DOUBLE_QUOTE = T.let(T.unsafe(nil), Integer)
RbReadline::RL_QF_OTHER_QUOTE = T.let(T.unsafe(nil), Integer)

# Possible values for the found_quote flags word used by the completion
#   functions.  It says what kind of (shell-like) quoting we found anywhere
#   in the line.
RbReadline::RL_QF_SINGLE_QUOTE = T.let(T.unsafe(nil), Integer)

RbReadline::RL_READLINE_VERSION = T.let(T.unsafe(nil), Integer)

# intra-line char search
RbReadline::RL_SEARCH_CSEARCH = T.let(T.unsafe(nil), Integer)

# incremental search
RbReadline::RL_SEARCH_ISEARCH = T.let(T.unsafe(nil), Integer)

# non-incremental search
RbReadline::RL_SEARCH_NSEARCH = T.let(T.unsafe(nil), Integer)

# tty special chars saved
RbReadline::RL_STATE_CALLBACK = T.let(T.unsafe(nil), Integer)

# overwrite mode
RbReadline::RL_STATE_COMPLETING = T.let(T.unsafe(nil), Integer)

# reading input after ESC
RbReadline::RL_STATE_DISPATCHING = T.let(T.unsafe(nil), Integer)

# entered vi command mode at least once
RbReadline::RL_STATE_DONE = T.let(T.unsafe(nil), Integer)

# initializing
RbReadline::RL_STATE_INITIALIZED = T.let(T.unsafe(nil), Integer)

# no state before first call
RbReadline::RL_STATE_INITIALIZING = T.let(T.unsafe(nil), Integer)

# doing an undo
RbReadline::RL_STATE_INPUTPENDING = T.let(T.unsafe(nil), Integer)

# reading more input in a command function
RbReadline::RL_STATE_ISEARCH = T.let(T.unsafe(nil), Integer)

# getting input from a macro
RbReadline::RL_STATE_MACRODEF = T.let(T.unsafe(nil), Integer)

# reading numeric argument
RbReadline::RL_STATE_MACROINPUT = T.let(T.unsafe(nil), Integer)

# reading a command key
RbReadline::RL_STATE_METANEXT = T.let(T.unsafe(nil), Integer)

# dispatching to a command
RbReadline::RL_STATE_MOREINPUT = T.let(T.unsafe(nil), Integer)

# reading vi motion arg
RbReadline::RL_STATE_MULTIKEY = T.let(T.unsafe(nil), Integer)

# Possible state values for rl_readline_state
RbReadline::RL_STATE_NONE = T.let(T.unsafe(nil), Integer)

# doing incremental search
RbReadline::RL_STATE_NSEARCH = T.let(T.unsafe(nil), Integer)

# doing a history search
RbReadline::RL_STATE_NUMERICARG = T.let(T.unsafe(nil), Integer)

# defining keyboard macro
RbReadline::RL_STATE_OVERWRITE = T.let(T.unsafe(nil), Integer)

# terminal is prepped
RbReadline::RL_STATE_READCMD = T.let(T.unsafe(nil), Integer)

# doing non-inc search
RbReadline::RL_STATE_SEARCH = T.let(T.unsafe(nil), Integer)

# doing completion
RbReadline::RL_STATE_SIGHANDLER = T.let(T.unsafe(nil), Integer)

# initialization done
RbReadline::RL_STATE_TERMPREPPED = T.let(T.unsafe(nil), Integer)

# rl_execute_next called
RbReadline::RL_STATE_TTYCSAVED = T.let(T.unsafe(nil), Integer)

# in readline sighandler
RbReadline::RL_STATE_UNDOING = T.let(T.unsafe(nil), Integer)

# reading multiple-key command
RbReadline::RL_STATE_VICMDONCE = T.let(T.unsafe(nil), Integer)

# using the callback interface
RbReadline::RL_STATE_VIMOTION = T.let(T.unsafe(nil), Integer)

RbReadline::RUBOUT = T.let(T.unsafe(nil), String)
RbReadline::SF_FAILED = T.let(T.unsafe(nil), Integer)
RbReadline::SF_FOUND = T.let(T.unsafe(nil), Integer)

# search flags
RbReadline::SF_REVERSE = T.let(T.unsafe(nil), Integer)

RbReadline::SINGLE_MATCH = T.let(T.unsafe(nil), Integer)
RbReadline::SPACE = T.let(T.unsafe(nil), String)
RbReadline::SUBST_FAILED = T.let(T.unsafe(nil), Integer)
RbReadline::SYS_INPUTRC = T.let(T.unsafe(nil), String)
RbReadline::TAB = T.let(T.unsafe(nil), String)
RbReadline::UNDO_BEGIN = T.let(T.unsafe(nil), Integer)
RbReadline::UNDO_DELETE = T.let(T.unsafe(nil), Integer)
RbReadline::UNDO_END = T.let(T.unsafe(nil), Integer)
RbReadline::UNDO_INSERT = T.let(T.unsafe(nil), Integer)
RbReadline::UpCase = T.let(T.unsafe(nil), Integer)
RbReadline::VISIBLE_BELL = T.let(T.unsafe(nil), Integer)
RbReadline::XOK = T.let(T.unsafe(nil), Integer)

module Readline
  include ::RbReadline

  private

  # Begins an interactive terminal process using +prompt+ as the command
  # prompt that users see when they type commands. The method returns the
  # line entered whenever a carriage return is encountered.
  #
  # If an +add_history+ argument is provided, commands entered by users are
  # stored in a history buffer that can be recalled for later use.
  #
  # Note that this method depends on $stdin and $stdout both being open.
  # Because this is meant as an interactive console interface, they should
  # generally not be redirected.
  #
  # If you would like to add non-visible characters to the the prompt (for
  # example to add colors) you must prepend the character \001 (^A) before
  # each sequence of non-visible characters and add the character \002 (^B)
  # after, otherwise line wrapping may not work properly.
  #
  # Example:
  #
  #    loop{ Readline.readline('> ') }
  def readline(prompt = T.unsafe(nil), add_history = T.unsafe(nil)); end

  class << self
    # Returns the list of quote characters that can cause a word break.
    # The default is "'\"" (single and double quote characters).
    def basic_quote_characters; end

    # Sets the list of quote characters that can cause a word break.
    def basic_quote_characters=(str); end

    # Returns the character string that signal a break between words for the
    # completion proc. The default is " \t\n\"\\'`@$><=|&{(".
    def basic_word_break_characters; end

    # Sets the character string that signal a break between words for the
    # completion proc.
    def basic_word_break_characters=(str); end

    # Returns the list of characters that can be used to quote a substring
    # of the line, i.e. a group of characters inside quotes.
    def completer_quote_characters; end

    # Sets the list of characters that can be used to quote a substring of
    # the line, i.e. a group of characters within quotes.
    def completer_quote_characters=(str); end

    # Returns the character string that signal the start or end of a word for
    # the completion proc.
    def completer_word_break_characters; end

    # Sets the character string that signal the start or end of a word for
    # the completion proc.
    def completer_word_break_characters=(str); end

    # Returns the character that is automatically appended after the
    # Readline.completion_proc method is called.
    def completion_append_character; end

    # Sets the character that is automatically appended after the
    # Readline.completion_proc method is called.
    #
    # If +char+ is nil or empty, then a null character is used.
    def completion_append_character=(char); end

    # Returns whether or not the completion proc is case sensitive. The
    # default is false, i.e. completion procs are case sensitive.
    def completion_case_fold; end

    # Sets whether or not the completion proc should ignore case sensitivity.
    # The default is false, i.e. completion procs are case sensitive.
    def completion_case_fold=(bool); end

    # Returns the current auto-completion procedure.
    def completion_proc; end

    # Sets the auto-completion procedure (i.e. tab auto-complete).
    #
    # The +proc+ argument is typically a Proc object. It must respond to
    # <tt>.call</tt>, take a single String argument and return an Array of
    # candidates for completion.
    #
    # Example:
    #
    #    list = ['search', 'next', 'clear']
    #    Readline.completion_proc = proc{ |s| list.grep( /^#{Regexp.escape(s)}/) }
    def completion_proc=(proc); end

    # Sets emacs editing mode
    def emacs_editing_mode; end

    # Returns the character string used to indicate quotes for the filename
    # completion of user input.
    def filename_quote_characters; end

    # Sets the character string of one or more characters that indicate quotes
    # for the filename completion of user input.
    def filename_quote_characters=(str); end

    # Sets the input stream (an IO object) for readline interaction. The
    # default is <tt>$stdin</tt>.
    def input=(input); end

    # Returns current line buffer
    def line_buffer; end

    # Sets the output stream (an IO object) for readline interaction. The
    # default is <tt>$stdout</tt>.
    def output=(output); end

    # Returns the current offset in the current input line.
    def point; end

    # Begins an interactive terminal process using +prompt+ as the command
    # prompt that users see when they type commands. The method returns the
    # line entered whenever a carriage return is encountered.
    #
    # If an +add_history+ argument is provided, commands entered by users are
    # stored in a history buffer that can be recalled for later use.
    #
    # Note that this method depends on $stdin and $stdout both being open.
    # Because this is meant as an interactive console interface, they should
    # generally not be redirected.
    #
    # If you would like to add non-visible characters to the the prompt (for
    # example to add colors) you must prepend the character \001 (^A) before
    # each sequence of non-visible characters and add the character \002 (^B)
    # after, otherwise line wrapping may not work properly.
    #
    # Example:
    #
    #    loop{ Readline.readline('> ') }
    def readline(prompt = T.unsafe(nil), add_history = T.unsafe(nil)); end

    # Returns nil if no matches are found or an array of strings:
    #
    #   [0] is the replacement for text
    #   [1..n] the possible matches
    #   [n+1] nil
    #
    # The possible matches should not include [0].
    #
    # If this method sets RbReadline.rl_attempted_completion_over to true,
    # then the default completion function will not be called when this
    # function returns nil.
    def readline_attempted_completion_function(text, start, _end); end

    # Temporarily disable warnings and call a block
    def silence_warnings(&block); end

    # Sets vi editing mode.
    def vi_editing_mode; end
  end
end

# The Fcomp class provided to encapsulate typical filename completion
# procedure. You will not typically use this directly, but will instead
# use the Readline::FILENAME_COMPLETION_PROC.
class Readline::Fcomp
  class << self
    def call(str); end
  end
end

# The History class encapsulates a history of all commands entered by
# users at the prompt, providing an interface for inspection and retrieval
# of all commands.
class Readline::History
  extend ::Enumerable

  class << self
    # Synonym for Readline.add_history.
    def <<(str); end

    # Returns the command that was entered at the specified +index+
    # in the history buffer.
    #
    # Raises an IndexError if the entry is nil.
    def [](index); end

    # Sets the command +str+ at the given index in the history buffer.
    #
    # You can only replace an existing entry. Attempting to create a new
    # entry will result in an IndexError.
    def []=(index, str); end

    # Deletes an entry from the histoyr buffer at the specified +index+.
    def delete_at(index); end

    # Iterates over each entry in the history buffer.
    def each; end

    # Returns a bolean value indicating whether or not the history buffer
    # is empty.
    #
    # @return [Boolean]
    def empty?; end

    # Returns the length of the history buffer.
    def length; end

    # Removes and returns the last element from the history buffer.
    def pop; end

    # Pushes a list of +args+ onto the history buffer.
    def push(*args); end

    # Internal function that removes the item at +index+ from the history
    # buffer, performing necessary duplication in the process.
    # --
    # TODO: mark private?
    def rb_remove_history(index); end

    # Removes and returns the first element from the history buffer.
    def shift; end

    # Synonym for Readline.length.
    def size; end

    # The History class, stringified in all caps.
    # --
    # Why?
    def to_s; end
  end
end

# The Ucomp class provided to encapsulate typical filename completion
# procedure. You will not typically use this directly, but will instead
# use the Readline::USERNAME_COMPLETION_PROC.
#
# Note that this feature currently only works on Unix systems since it
# ultimately uses the Etc module to iterate over a list of users.
class Readline::Ucomp
  class << self
    def call(str); end
  end
end
