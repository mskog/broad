# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-configurable` gem.
# Please instead update this file by running `bin/tapioca gem dry-configurable`.

module Dry
  class << self
    def Equalizer(*keys, **options); end
    def Struct(attributes = T.unsafe(nil), &block); end
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# A simple configuration mixin
#
# @api public
# @example class-level configuration
#
#   class App
#   extend Dry::Configurable
#
#   setting :database do
#   setting :dsn, 'sqlite:memory'
#   end
#   end
#
#   App.config.database.dsn = 'jdbc:sqlite:memory'
#   App.config.database.dsn
#   # => "jdbc:sqlite:memory"
# @example instance-level configuration
#
#   class App
#   include Dry::Configurable
#
#   setting :database
#   end
#
#   production = App.new
#   production.config.database = ENV['DATABASE_URL']
#   production.finalize!
#
#   development = App.new
#   development.config.database = 'jdbc:sqlite:memory'
#   development.finalize!
module Dry::Configurable
  include ::Dry::Core::Constants
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  include ::Dry::Configurable::InstanceMethods

  mixes_in_class_methods ::Dry::Configurable::ClassMethods

  class << self
    # @api private
    # @private
    def extended(klass); end

    # @api private
    # @private
    # @raise [AlreadyIncluded]
    def included(klass); end
  end
end

# @api public
class Dry::Configurable::AlreadyIncluded < ::Dry::Configurable::Error; end

module Dry::Configurable::ClassMethods
  include ::Dry::Configurable::Methods

  # @api private
  def __config_dsl__; end

  # @api private
  def __config_reader__; end

  # Return declared settings
  #
  # @api public
  # @return [Settings]
  def _settings; end

  # Return configuration
  #
  # @api public
  # @return [Config]
  def config; end

  # @api private
  def inherited(subclass); end

  # Add a setting to the configuration
  #
  # @api public
  # @param name [Mixed] The accessor key for the configuration value
  # @param default [Mixed] Default value for the setting
  # @param constructor [#call] Transformation given value will go through
  # @param reader [Boolean] Whether a reader accessor must be created
  # @return [Dry::Configurable::Config]
  # @yield A block can be given to add nested settings.
  def setting(*args, **options, &block); end

  # Return declared settings
  #
  # @api public
  # @return [Set<Symbol>]
  def settings; end
end

# Setting compiler used internally by the DSL
#
# @api private
class Dry::Configurable::Compiler
  # @api private
  def call(ast); end

  # @api private
  def visit(node); end

  # @api private
  def visit_nested(node); end

  # @api private
  def visit_setting(node); end
end

# Config exposes setting values through a convenient API
#
# @api public
class Dry::Configurable::Config
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Config] a new instance of Config
  def initialize(settings); end

  # Get config value by a key
  #
  # @api public
  # @param name [String, Symbol]
  # @raise [ArgumentError]
  # @return Config value
  def [](name); end

  # Set config value.
  # Note that finalized configs cannot be changed.
  #
  # @api public
  # @param name [String, Symbol]
  # @param value [Object]
  def []=(name, value); end

  # @api private
  def _resolved; end

  # @api private
  def _settings; end

  # @api private
  def finalize!; end

  # @api private
  def pristine; end

  # Dump config into a hash
  #
  # @api public
  # @return [Hash]
  def to_h; end

  # Update config with new values
  #
  # @api public
  # @param values [Hash] A hash with new values
  # @return [Config]
  def update(values); end

  # Dump config into a hash
  #
  # @api public
  # @return [Hash]
  def values; end

  private

  # @api private
  def initialize_copy(source); end

  # @api private
  def method_missing(meth, *args); end

  # @api private
  def resolve(meth); end

  # @api private
  # @return [Boolean]
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# Setting DSL used by the class API
#
# @api private
class Dry::Configurable::DSL
  # @api private
  # @return [DSL] a new instance of DSL
  def initialize(&block); end

  # @api private
  def ast; end

  # @api private
  def compiler; end

  # Registers a new setting node and compile it into a setting object
  #
  # @api private
  # @return Setting
  # @see ClassMethods.setting
  def setting(name, default = T.unsafe(nil), **options, &block); end

  private

  # @api private
  # @raise [ArgumentError]
  def ensure_valid_options(options); end

  # Returns a tuple of valid and invalid options hashes derived from the options hash
  # given to the setting
  #
  # @api private
  def valid_and_invalid_options(options); end
end

# @api private
Dry::Configurable::DSL::VALID_NAME = T.let(T.unsafe(nil), Regexp)

Dry::Configurable::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Configurable::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Configurable::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Configurable::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Configurable::EMPTY_STRING = T.let(T.unsafe(nil), String)

# @api public
class Dry::Configurable::Error < ::StandardError; end

# @api public
class Dry::Configurable::FrozenConfig < ::Dry::Configurable::Error; end

Dry::Configurable::IDENTITY = T.let(T.unsafe(nil), Proc)

# Initializer method which is prepended when `Dry::Configurable`
# is included in a class
#
# @api private
module Dry::Configurable::Initializer
  # @api private
  def initialize(*_arg0, **_arg1); end
end

# Instance-level API when `Dry::Configurable` is included in a class
#
# @api public
module Dry::Configurable::InstanceMethods
  include ::Dry::Configurable::Methods

  # Return object's configuration
  #
  # @api public
  # @return [Config]
  def config; end

  # Finalize the config and freeze the object
  #
  # @api public
  def finalize!; end

  private

  # @api public
  def initialize_copy(source); end
end

# Common API for both classes and instances
#
# @api public
module Dry::Configurable::Methods
  # @api public
  # @raise [FrozenConfig]
  # @yield [config]
  def configure(&block); end

  # Finalize and freeze configuration
  #
  # @api public
  # @return [Dry::Configurable::Config]
  def finalize!; end
end

Dry::Configurable::Self = T.let(T.unsafe(nil), Proc)

# This class represents a setting and is used internally.
#
# @api private
class Dry::Configurable::Setting
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Setting] a new instance of Setting
  def initialize(name, input: T.unsafe(nil), default: T.unsafe(nil), **options); end

  # @api private
  # @return [Boolean]
  def cloneable?; end

  # @api private
  def constructor; end

  # @api private
  def default; end

  # @api private
  # @return [Boolean]
  def evaluated?; end

  # @api private
  def input; end

  # @api private
  # @return [Boolean]
  def input_defined?; end

  # @api private
  def name; end

  # @api private
  def nested(settings); end

  # @api private
  def options; end

  # @api private
  def pristine; end

  # @api private
  # @return [Boolean]
  def reader?; end

  # @api private
  def value; end

  # @api private
  def with(new_opts); end

  # @api private
  # @return [Boolean]
  def writer?(meth); end

  # @api private
  def writer_name; end

  private

  # @api private
  def evaluate; end

  # @api private
  def initialize_copy(source); end

  class << self
    # @api private
    # @return [Boolean]
    def cloneable_value?(value); end
  end
end

# @api private
Dry::Configurable::Setting::CLONEABLE_VALUE_TYPES = T.let(T.unsafe(nil), Array)

# @api private
Dry::Configurable::Setting::DEFAULT_CONSTRUCTOR = T.let(T.unsafe(nil), Proc)

# Specialized Setting which includes nested settings
#
# @api private
class Dry::Configurable::Setting::Nested < ::Dry::Configurable::Setting
  # @api private
  def constructor; end

  # @api private
  def pristine; end
end

# @api private
Dry::Configurable::Setting::Nested::CONSTRUCTOR = T.let(T.unsafe(nil), Method)

# @api private
Dry::Configurable::Setting::OPTIONS = T.let(T.unsafe(nil), Array)

# A settings map
#
# @api private
class Dry::Configurable::Settings
  include ::Dry::Core::Equalizer::Methods
  include ::Enumerable

  # @api private
  # @return [Settings] a new instance of Settings
  def initialize(elements = T.unsafe(nil)); end

  # @api private
  def <<(setting); end

  # @api private
  def [](name); end

  # @api private
  def each(&block); end

  # @api private
  def elements; end

  # @api private
  # @return [Boolean]
  def key?(name); end

  # @api private
  def keys; end

  # @api private
  def pristine; end

  private

  # @api private
  def initialize_copy(source); end

  # @api private
  def initialize_elements(elements); end
end

Dry::Configurable::Undefined = T.let(T.unsafe(nil), Object)
