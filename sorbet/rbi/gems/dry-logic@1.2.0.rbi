# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-logic` gem.
# Please instead update this file by running `bin/tapioca gem dry-logic`.

# A collection of micro-libraries, each intended to encapsulate
# a common task in Ruby
module Dry
  class << self
    # Build an equalizer module for the inclusion in other class
    #
    # ## Credits
    #
    # Equalizer has been originally imported from the equalizer gem created by Dan Kubb
    #
    # @api public
    def Equalizer(*keys, **options); end

    def Struct(attributes = T.unsafe(nil), &block); end
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

module Dry::Logic
  class << self
    def Rule(*args, **options, &block); end
  end
end

class Dry::Logic::Evaluator
  include ::Dry::Core::Equalizer::Methods

  # @return [Evaluator] a new instance of Evaluator
  def initialize(path); end

  # Returns the value of attribute path.
  def path; end
end

class Dry::Logic::Evaluator::Attr < ::Dry::Logic::Evaluator
  def [](input); end
  def call(input); end
end

class Dry::Logic::Evaluator::Key < ::Dry::Logic::Evaluator
  def [](input); end
  def call(input); end
end

class Dry::Logic::Evaluator::Set
  include ::Dry::Core::Equalizer::Methods

  # @return [Set] a new instance of Set
  def initialize(evaluators); end

  def [](input); end
  def call(input); end

  # Returns the value of attribute evaluators.
  def evaluators; end

  class << self
    def new(paths); end
  end
end

module Dry::Logic::Operations; end

class Dry::Logic::Operations::Abstract
  include ::Dry::Core::Constants
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Logic::Operators

  # @return [Abstract] a new instance of Abstract
  def initialize(*rules, **options); end

  def curry(*args); end
  def id; end
  def new(rules, **new_options); end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute rules.
  def rules; end

  def to_ast; end
  def with(new_options); end
end

Dry::Logic::Operations::Abstract::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Logic::Operations::Abstract::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Logic::Operations::Abstract::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Logic::Operations::Abstract::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Logic::Operations::Abstract::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Logic::Operations::Abstract::IDENTITY = T.let(T.unsafe(nil), Proc)
Dry::Logic::Operations::Abstract::Self = T.let(T.unsafe(nil), Proc)
Dry::Logic::Operations::Abstract::Undefined = T.let(T.unsafe(nil), Object)

class Dry::Logic::Operations::And < ::Dry::Logic::Operations::Binary
  # @return [And] a new instance of And
  def initialize(*_arg0, **_arg1); end

  def [](input); end
  def call(input); end

  # Returns the value of attribute hints.
  def hints; end

  def operator; end
  def type; end
end

class Dry::Logic::Operations::Attr < ::Dry::Logic::Operations::Key
  def type; end

  class << self
    def evaluator(name); end
  end
end

class Dry::Logic::Operations::Binary < ::Dry::Logic::Operations::Abstract
  # @return [Binary] a new instance of Binary
  def initialize(left, right, **options); end

  def ast(input = T.unsafe(nil)); end

  # Returns the value of attribute left.
  def left; end

  # Returns the value of attribute right.
  def right; end

  def to_s; end
end

class Dry::Logic::Operations::Check < ::Dry::Logic::Operations::Unary
  # @return [Check] a new instance of Check
  def initialize(*rules, **options); end

  def [](input); end
  def ast(input = T.unsafe(nil)); end
  def call(input); end

  # Returns the value of attribute evaluator.
  def evaluator; end

  def type; end

  class << self
    def new(rule, **options); end
  end
end

class Dry::Logic::Operations::Each < ::Dry::Logic::Operations::Unary
  def [](arr); end
  def call(input); end
  def type; end
end

class Dry::Logic::Operations::Implication < ::Dry::Logic::Operations::Binary
  def [](input); end
  def call(input); end
  def operator; end
  def type; end
end

class Dry::Logic::Operations::Key < ::Dry::Logic::Operations::Unary
  # @return [Key] a new instance of Key
  def initialize(*rules, **options); end

  def [](hash); end
  def ast(input = T.unsafe(nil)); end
  def call(hash); end

  # Returns the value of attribute evaluator.
  def evaluator; end

  # Returns the value of attribute path.
  def path; end

  def to_s; end
  def type; end

  class << self
    def evaluator(name); end
    def new(rules, **options); end
  end
end

class Dry::Logic::Operations::Negation < ::Dry::Logic::Operations::Unary
  def [](input); end
  def call(input); end
  def type; end
end

class Dry::Logic::Operations::Or < ::Dry::Logic::Operations::Binary
  def [](input); end
  def call(input); end
  def operator; end
  def type; end
end

class Dry::Logic::Operations::Set < ::Dry::Logic::Operations::Abstract
  def [](input); end
  def ast(input = T.unsafe(nil)); end
  def call(input); end
  def to_s; end
  def type; end
end

class Dry::Logic::Operations::Unary < ::Dry::Logic::Operations::Abstract
  # @return [Unary] a new instance of Unary
  def initialize(*rules, **options); end

  def ast(input = T.unsafe(nil)); end

  # Returns the value of attribute rule.
  def rule; end

  def to_s; end
end

class Dry::Logic::Operations::Xor < ::Dry::Logic::Operations::Binary
  def [](input); end
  def ast(input = T.unsafe(nil)); end
  def call(input); end
  def operator; end
  def type; end
end

module Dry::Logic::Operators
  def &(other); end
  def >(other); end
  def ^(other); end
  def and(other); end
  def or(other); end
  def then(other); end
  def xor(other); end
  def |(other); end
end

module Dry::Logic::Predicates
  extend ::Dry::Logic::Predicates::Methods

  mixes_in_class_methods ::Dry::Logic::Predicates::Methods

  class << self
    # @private
    def included(other); end
  end
end

module Dry::Logic::Predicates::Methods
  def [](name); end

  # @return [Boolean]
  def array?(input); end

  # @return [Boolean]
  def attr?(name, input); end

  # @return [Boolean]
  def bool?(input); end

  # @return [Boolean]
  def bytesize?(size, input); end

  # @return [Boolean]
  def case?(pattern, input); end

  # @return [Boolean]
  def date?(input); end

  # @return [Boolean]
  def date_time?(input); end

  # @return [Boolean]
  def decimal?(input); end

  # @return [Boolean]
  def empty?(input); end

  # @return [Boolean]
  def eql?(left, right); end

  # @return [Boolean]
  def even?(input); end

  # @return [Boolean]
  def excluded_from?(list, input); end

  # @return [Boolean]
  def excludes?(value, input); end

  # @return [Boolean]
  def exclusion?(list, input); end

  # @return [Boolean]
  def false?(value); end

  # @return [Boolean]
  def filled?(input); end

  # @return [Boolean]
  def float?(input); end

  # @return [Boolean]
  def format?(regex, input); end

  # @return [Boolean]
  def gt?(num, input); end

  # @return [Boolean]
  def gteq?(num, input); end

  # @return [Boolean]
  def hash?(input); end

  # @return [Boolean]
  def included_in?(list, input); end

  # @return [Boolean]
  def includes?(value, input); end

  # @return [Boolean]
  def inclusion?(list, input); end

  # @return [Boolean]
  def int?(input); end

  # @return [Boolean]
  def is?(left, right); end

  # @return [Boolean]
  def key?(name, input); end

  # @return [Boolean]
  def lt?(num, input); end

  # @return [Boolean]
  def lteq?(num, input); end

  # @return [Boolean]
  def max_bytesize?(num, input); end

  # @return [Boolean]
  def max_size?(num, input); end

  # @return [Boolean]
  def min_bytesize?(num, input); end

  # @return [Boolean]
  def min_size?(num, input); end

  # @return [Boolean]
  def nil?(input); end

  # @return [Boolean]
  def none?(input); end

  # @return [Boolean]
  def not_eql?(left, right); end

  # @return [Boolean]
  def number?(input); end

  # @return [Boolean]
  def odd?(input); end

  def predicate(name, &block); end

  # @return [Boolean]
  def respond_to?(method, input); end

  # @return [Boolean]
  def size?(size, input); end

  # @return [Boolean]
  def str?(input); end

  # @return [Boolean]
  def time?(input); end

  # @return [Boolean]
  def true?(value); end

  # @return [Boolean]
  def type?(type, input); end

  # @return [Boolean]
  def uri?(schemes, input); end

  # @return [Boolean]
  def uuid_v1?(input); end

  # @return [Boolean]
  def uuid_v2?(input); end

  # @return [Boolean]
  def uuid_v3?(input); end

  # @return [Boolean]
  def uuid_v4?(input); end

  # @return [Boolean]
  def uuid_v5?(input); end
end

class Dry::Logic::Result
  include ::Dry::Core::Constants

  # @return [Result] a new instance of Result
  def initialize(success, id = T.unsafe(nil), &block); end

  def ast(input = T.unsafe(nil)); end

  # @return [Boolean]
  def failure?; end

  # Returns the value of attribute id.
  def id; end

  # Returns the value of attribute serializer.
  def serializer; end

  # Returns the value of attribute success.
  def success; end

  # @return [Boolean]
  def success?; end

  def to_ast; end
  def to_s; end
  def type; end

  private

  def visit(ast); end
  def visit_and(node); end
  def visit_hint(node); end
  def visit_not(node); end
  def visit_or(node); end
  def visit_predicate(node); end
  def visit_xor(node); end
end

Dry::Logic::Result::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Logic::Result::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Logic::Result::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Logic::Result::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Logic::Result::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Logic::Result::IDENTITY = T.let(T.unsafe(nil), Proc)
Dry::Logic::Result::SUCCESS = T.let(T.unsafe(nil), T.untyped)
Dry::Logic::Result::Self = T.let(T.unsafe(nil), Proc)
Dry::Logic::Result::Undefined = T.let(T.unsafe(nil), Object)

class Dry::Logic::Rule
  include ::Dry::Core::Constants
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Logic::Operators

  # @return [Rule] a new instance of Rule
  def initialize(predicate, options = T.unsafe(nil)); end

  # Returns the value of attribute args.
  def args; end

  # Returns the value of attribute arity.
  def arity; end

  def ast(input = T.unsafe(nil)); end
  def bind(object); end
  def curry(*new_args); end
  def eval_args(object); end
  def id; end

  # Returns the value of attribute options.
  def options; end

  def parameters; end

  # Returns the value of attribute predicate.
  def predicate; end

  def type; end
  def with(new_opts); end

  private

  def args_with_names(*input); end

  class << self
    def build(predicate, args: T.unsafe(nil), arity: T.unsafe(nil), **options); end
    def interfaces; end
    def specialize(arity, curried, base = T.unsafe(nil)); end
  end
end

Dry::Logic::Rule::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Logic::Rule::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Logic::Rule::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Logic::Rule::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Logic::Rule::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Logic::Rule::IDENTITY = T.let(T.unsafe(nil), Proc)

class Dry::Logic::Rule::Interface < ::Module
  # @return [Interface] a new instance of Interface
  def initialize(arity, curried); end

  # Returns the value of attribute arity.
  def arity; end

  # @return [Boolean]
  def constant?; end

  # Returns the value of attribute curried.
  def curried; end

  # @return [Boolean]
  def curried?; end

  def curried_args; end
  def define_application; end
  def define_constant_application; end
  def define_constructor; end
  def name; end
  def unapplied; end
  def unapplied_args; end

  # @return [Boolean]
  def variable_arity?; end
end

Dry::Logic::Rule::Interface::SPLAT = T.let(T.unsafe(nil), Array)

class Dry::Logic::Rule::Predicate < ::Dry::Logic::Rule
  def ast(input = T.unsafe(nil)); end
  def name; end
  def to_ast(input = T.unsafe(nil)); end
  def to_s; end
  def type; end

  class << self
    def specialize(arity, curried, base = T.unsafe(nil)); end
  end
end

class Dry::Logic::Rule::Predicate::Predicate2Arity < ::Dry::Logic::Rule::Predicate; end
class Dry::Logic::Rule::Predicate::Predicate2Arity1Curried < ::Dry::Logic::Rule::Predicate; end
Dry::Logic::Rule::Self = T.let(T.unsafe(nil), Proc)
Dry::Logic::Rule::Undefined = T.let(T.unsafe(nil), Object)

class Dry::Logic::RuleCompiler
  include ::Dry::Core::Constants

  # @return [RuleCompiler] a new instance of RuleCompiler
  def initialize(predicates); end

  def call(ast); end

  # Returns the value of attribute predicates.
  def predicates; end

  def visit(node); end
  def visit_and(node); end
  def visit_attr(node); end
  def visit_check(node); end
  def visit_each(node); end
  def visit_implication(node); end
  def visit_key(node); end
  def visit_not(node); end
  def visit_or(node); end
  def visit_predicate(node); end
  def visit_set(node); end
  def visit_xor(node); end
end

Dry::Logic::RuleCompiler::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Logic::RuleCompiler::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Logic::RuleCompiler::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Logic::RuleCompiler::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Logic::RuleCompiler::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Logic::RuleCompiler::IDENTITY = T.let(T.unsafe(nil), Proc)
Dry::Logic::RuleCompiler::Self = T.let(T.unsafe(nil), Proc)
Dry::Logic::RuleCompiler::Undefined = T.let(T.unsafe(nil), Object)
