# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `graphql` gem.
# Please instead update this file by running `bin/tapioca gem graphql`.

# backport from ruby v2.5 to v2.2 that has no `padding` things
#
# @api private
module Base64Bp
  extend ::Base64

  private

  # @api private
  def urlsafe_decode64(str); end

  # @api private
  def urlsafe_encode64(bin, padding:); end

  class << self
    # @api private
    def urlsafe_decode64(str); end

    # @api private
    def urlsafe_encode64(bin, padding:); end
  end
end

module GraphQL
  class << self
    def const_missing(const_name); end
    def default_parser; end

    # Sets the attribute default_parser
    #
    # @param value the value to set the attribute default_parser to.
    def default_parser=(_arg0); end

    # Turn a query string or schema definition into an AST
    #
    # @param graphql_string [String] a GraphQL query string or schema definition
    # @return [GraphQL::Language::Nodes::Document]
    def parse(graphql_string, tracer: T.unsafe(nil)); end

    # Read the contents of `filename` and parse them as GraphQL
    #
    # @param filename [String] Path to a `.graphql` file containing IDL or query
    # @return [GraphQL::Language::Nodes::Document]
    def parse_file(filename); end

    def parse_with_racc(string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end

    # @return [Array<GraphQL::Language::Token>]
    def scan(graphql_string); end

    def scan_with_ragel(graphql_string); end
  end
end

module GraphQL::Analysis
  private

  def analysis_errors(results); end

  # @return [void]
  def analyze_multiplex(multiplex, analyzers); end

  # Visit `query`'s internal representation, calling `analyzers` along the way.
  #
  # - First, query analyzers are filtered down by calling `.analyze?(query)`, if they respond to that method
  # - Then, query analyzers are initialized by calling `.initial_value(query)`, if they respond to that method.
  # - Then, they receive `.call(memo, visit_type, irep_node)`, where visit type is `:enter` or `:leave`.
  # - Last, they receive `.final_value(memo)`, if they respond to that method.
  #
  # It returns an array of final `memo` values in the order that `analyzers` were passed in.
  #
  # @param query [GraphQL::Query]
  # @param analyzers [Array<#call>] Objects that respond to `#call(memo, visit_type, irep_node)`
  # @return [Array<Any>] Results from those analyzers
  def analyze_query(query, analyzers, multiplex_states: T.unsafe(nil)); end

  # Enter the node, visit its children, then leave the node.
  def reduce_node(irep_node, reducer_states); end

  def use(schema_class); end
  def visit_analyzers(visit_type, irep_node, reducer_states); end

  class << self
    def analysis_errors(results); end

    # @return [void]
    def analyze_multiplex(multiplex, analyzers); end

    # Visit `query`'s internal representation, calling `analyzers` along the way.
    #
    # - First, query analyzers are filtered down by calling `.analyze?(query)`, if they respond to that method
    # - Then, query analyzers are initialized by calling `.initial_value(query)`, if they respond to that method.
    # - Then, they receive `.call(memo, visit_type, irep_node)`, where visit type is `:enter` or `:leave`.
    # - Last, they receive `.final_value(memo)`, if they respond to that method.
    #
    # It returns an array of final `memo` values in the order that `analyzers` were passed in.
    #
    # @param query [GraphQL::Query]
    # @param analyzers [Array<#call>] Objects that respond to `#call(memo, visit_type, irep_node)`
    # @return [Array<Any>] Results from those analyzers
    def analyze_query(query, analyzers, multiplex_states: T.unsafe(nil)); end

    # Enter the node, visit its children, then leave the node.
    def reduce_node(irep_node, reducer_states); end

    def use(schema_class); end
    def visit_analyzers(visit_type, irep_node, reducer_states); end
  end
end

# A query reducer for measuring the depth of a given query.
#
# See https://graphql-ruby.org/queries/ast_analysis.html for more examples.
#
# @example Logging the depth of a query
#   class LogQueryDepth < GraphQL::Analysis::QueryDepth
#   def result
#   log("GraphQL query depth: #{@max_depth}")
#   end
#   end
#
#   # In your Schema file:
#
#   class MySchema < GraphQL::Schema
#   use GraphQL::Analysis::AST
#   query_analyzer LogQueryDepth
#   end
#
#   # When you run the query, the depth will get logged:
#
#   Schema.execute(query_str)
#   # GraphQL query depth: 8
module GraphQL::Analysis::AST
  private

  def analysis_errors(results); end

  # Analyze a multiplex, and all queries within.
  # Multiplex analyzers are ran for all queries, keeping state.
  # Query analyzers are ran per query, without carrying state between queries.
  #
  # @param multiplex [GraphQL::Execution::Multiplex]
  # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
  # @return [Array<Any>] Results from multiplex analyzers
  def analyze_multiplex(multiplex, analyzers); end

  # @param query [GraphQL::Query]
  # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
  # @return [Array<Any>] Results from those analyzers
  def analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end

  def use(schema_class); end

  class << self
    def analysis_errors(results); end

    # Analyze a multiplex, and all queries within.
    # Multiplex analyzers are ran for all queries, keeping state.
    # Query analyzers are ran per query, without carrying state between queries.
    #
    # @param multiplex [GraphQL::Execution::Multiplex]
    # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
    # @return [Array<Any>] Results from multiplex analyzers
    def analyze_multiplex(multiplex, analyzers); end

    # @param query [GraphQL::Query]
    # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
    # @return [Array<Any>] Results from those analyzers
    def analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end

    def use(schema_class); end
  end
end

# Query analyzer for query ASTs. Query analyzers respond to visitor style methods
# but are prefixed by `enter` and `leave`.
#
# When an analyzer is initialized with a Multiplex, you can always get the current query from
# `visitor.query` in the visit methods.
#
# @param The [GraphQL::Query, GraphQL::Execution::Multiplex] query or multiplex to analyze
class GraphQL::Analysis::AST::Analyzer
  # @return [Analyzer] a new instance of Analyzer
  def initialize(subject); end

  # Analyzer hook to decide at analysis time whether a query should
  # be analyzed or not.
  #
  # @return [Boolean] If the query should be analyzed or not
  def analyze?; end

  def on_enter_abstract_node(node, parent, visitor); end
  def on_enter_argument(node, parent, visitor); end
  def on_enter_directive(node, parent, visitor); end
  def on_enter_document(node, parent, visitor); end
  def on_enter_enum(node, parent, visitor); end
  def on_enter_field(node, parent, visitor); end
  def on_enter_fragment_spread(node, parent, visitor); end
  def on_enter_inline_fragment(node, parent, visitor); end
  def on_enter_input_object(node, parent, visitor); end
  def on_enter_list_type(node, parent, visitor); end
  def on_enter_non_null_type(node, parent, visitor); end
  def on_enter_null_value(node, parent, visitor); end
  def on_enter_operation_definition(node, parent, visitor); end
  def on_enter_type_name(node, parent, visitor); end
  def on_enter_variable_definition(node, parent, visitor); end
  def on_enter_variable_identifier(node, parent, visitor); end
  def on_leave_abstract_node(node, parent, visitor); end
  def on_leave_argument(node, parent, visitor); end
  def on_leave_directive(node, parent, visitor); end
  def on_leave_document(node, parent, visitor); end
  def on_leave_enum(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def on_leave_fragment_spread(node, parent, visitor); end
  def on_leave_inline_fragment(node, parent, visitor); end
  def on_leave_input_object(node, parent, visitor); end
  def on_leave_list_type(node, parent, visitor); end
  def on_leave_non_null_type(node, parent, visitor); end
  def on_leave_null_value(node, parent, visitor); end
  def on_leave_operation_definition(node, parent, visitor); end
  def on_leave_type_name(node, parent, visitor); end
  def on_leave_variable_definition(node, parent, visitor); end
  def on_leave_variable_identifier(node, parent, visitor); end

  # The result for this analyzer. Returning {GraphQL::AnalysisError} results
  # in a query error.
  #
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [Any] The analyzer result
  def result; end

  protected

  # @return [GraphQL::Execution::Multiplex, nil] `nil` if this analyzer is visiting a query
  def multiplex; end

  # @return [GraphQL::Query, nil] `nil` if this analyzer is visiting a multiplex
  #   (When this is `nil`, use `visitor.query` inside visit methods to get the current query)
  def query; end

  # @return [GraphQL::Query, GraphQL::Execution::Multiplex] Whatever this analyzer is analyzing
  def subject; end

  class << self
    private

    def build_visitor_hooks(member_name); end
  end
end

class GraphQL::Analysis::AST::FieldUsage < ::GraphQL::Analysis::AST::Analyzer
  # @return [FieldUsage] a new instance of FieldUsage
  def initialize(query); end

  def on_leave_field(node, parent, visitor); end
  def result; end

  private

  def extract_deprecated_arguments(argument_values); end
end

# Used under the hood to implement complexity validation,
# see {Schema#max_complexity} and {Query#max_complexity}
class GraphQL::Analysis::AST::MaxQueryComplexity < ::GraphQL::Analysis::AST::QueryComplexity
  def result; end
end

class GraphQL::Analysis::AST::MaxQueryDepth < ::GraphQL::Analysis::AST::QueryDepth
  def result; end
end

class GraphQL::Analysis::AST::QueryComplexity < ::GraphQL::Analysis::AST::Analyzer
  # State for the query complexity calculation:
  # - `complexities_on_type` holds complexity scores for each type in an IRep node
  #
  # @return [QueryComplexity] a new instance of QueryComplexity
  def initialize(query); end

  def on_enter_field(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end

  # Overide this method to use the complexity result
  def result; end

  private

  # @return [Boolean]
  def applies_to?(query, left_scope, right_scope); end

  # A hook which is called whenever a field's max complexity is calculated.
  # Override this method to capture individual field complexity details.
  #
  # @param scoped_type_complexity [ScopedTypeComplexity]
  # @param max_complexity [Numeric] Field's maximum complexity including child complexity
  # @param child_complexity [Numeric, nil] Field's child complexity
  def field_complexity(scoped_type_complexity, max_complexity:, child_complexity: T.unsafe(nil)); end

  # @return [Integer]
  def max_possible_complexity; end

  # (`{field_key => complexity}`)
  #
  # @param children_for_scope [Array<Hash>] An array of `scoped_children[scope]` hashes
  # @return [Integer] Complexity value for all these selections in the current scope
  def merged_max_complexity(query, children_for_scope); end

  # @param query [GraphQL::Query] Used for `query.possible_types`
  # @param scoped_children_hashes [Array<Hash>] Array of scoped children hashes
  # @return [Integer]
  def merged_max_complexity_for_scopes(query, scoped_children_hashes); end
end

class GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity
  # @param parent_type [Class] The owner of `field_definition`
  # @param field_definition [GraphQL::Field, GraphQL::Schema::Field] Used for getting the `.complexity` configuration
  # @param query [GraphQL::Query] Used for `query.possible_types`
  # @param response_path [Array<String>] The path to the response key for the field
  # @return [ScopedTypeComplexity] a new instance of ScopedTypeComplexity
  def initialize(parent_type, field_definition, query, response_path); end

  # Returns the value of attribute field_definition.
  def field_definition; end

  # @return [Array<GraphQL::Language::Nodes::Field>]
  def nodes; end

  def own_complexity(child_complexity); end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute response_path.
  def response_path; end

  # This value is only calculated when asked for to avoid needless hash allocations.
  # Also, if it's never asked for, we determine that this scope complexity
  # is a scalar field ({#terminal?}).
  #
  # @return [Hash<Hash<Class => ScopedTypeComplexity>]] Hash<Hash<Class => ScopedTypeComplexity>]
  def scoped_children; end

  # Returns true if this field has no selections, ie, it's a scalar.
  # We need a quick way to check whether we should continue traversing.
  #
  # @return [Boolean]
  def terminal?; end
end

# A single proc for {#scoped_children} hashes. Use this to avoid repeated allocations,
# since the lexical binding isn't important.
GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity::HASH_CHILDREN = T.let(T.unsafe(nil), Proc)

class GraphQL::Analysis::AST::QueryDepth < ::GraphQL::Analysis::AST::Analyzer
  # @return [QueryDepth] a new instance of QueryDepth
  def initialize(query); end

  def on_enter_field(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def result; end
end

# Depth first traversal through a query AST, calling AST analyzers
# along the way.
#
# The visitor is a special case of GraphQL::Language::Visitor, visiting
# only the selected operation, providing helpers for common use cases such
# as skipped fields and visiting fragment spreads.
#
# @see {GraphQL::Analysis::AST::Analyzer} AST Analyzers for queries
class GraphQL::Analysis::AST::Visitor < ::GraphQL::Language::Visitor
  # @return [Visitor] a new instance of Visitor
  def initialize(query:, analyzers:); end

  # @return [GraphQL::Argument, nil] The most-recently-entered GraphQL::Argument, if currently inside one
  def argument_definition; end

  # @return [GraphQL::Query::Arguments] Arguments for this node, merging default values, literal values and query variables
  # @see {GraphQL::Query#arguments_for}
  def arguments_for(ast_node, field_definition); end

  # @return [GraphQL::Directive, nil] The most-recently-entered GraphQL::Directive, if currently inside one
  def directive_definition; end

  # @return [GraphQL::Field, nil] The most-recently-entered GraphQL::Field, if currently inside one
  def field_definition; end

  # @return [Array<GraphQL::ObjectType>] Types whose scope we've entered
  def object_types; end

  def on_abstract_node(node, parent); end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end

  # Visitor Hooks
  def on_operation_definition(node, parent); end

  # @return [GraphQL::BaseType] The type which the current type came from
  def parent_type_definition; end

  # @return [GraphQL::Argument, nil] The previous GraphQL argument
  def previous_argument_definition; end

  # @return [GraphQL::Field, nil] The GraphQL field which returned the object that the current field belongs to
  def previous_field_definition; end

  # @return [GraphQL::Query] the query being visited
  def query; end

  # @return [Array<GraphQL::AnalysisError]] Array<GraphQL::AnalysisError]
  def rescued_errors; end

  # @return [Array<String>] The path to the response key for the current field
  def response_path; end

  # @return [Boolean] If the current node should be skipped because of a skip or include directive
  def skipping?; end

  # @return [GraphQL::BaseType] The current object type
  def type_definition; end

  def visit; end

  # @return [Boolean] If the visitor is currently inside a fragment definition
  def visiting_fragment_definition?; end

  private

  def call_analyzers(method, node, parent); end

  # Visit a fragment spread inline instead of visiting the definition
  # by itself.
  def enter_fragment_spread_inline(fragment_spread); end

  # Visit a fragment spread inline instead of visiting the definition
  # by itself.
  def leave_fragment_spread_inline(_fragment_spread); end

  # @yield [node]
  def on_fragment_with_type(node); end

  # @return [Boolean]
  def skip?(ast_node); end
end

# A query reducer for tracking both field usage and deprecated field usage.
#
# @example Logging field usage and deprecated field usage
#   Schema.query_analyzers << GraphQL::Analysis::FieldUsage.new { |query, used_fields, used_deprecated_fields|
#   puts "Used GraphQL fields: #{used_fields.join(', ')}"
#   puts "Used deprecated GraphQL fields: #{used_deprecated_fields.join(', ')}"
#   }
#   Schema.execute(query_str)
#   # Used GraphQL fields: Cheese.id, Cheese.fatContent, Query.cheese
#   # Used deprecated GraphQL fields: Cheese.fatContent
class GraphQL::Analysis::FieldUsage
  # @return [FieldUsage] a new instance of FieldUsage
  def initialize(&block); end

  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end
end

# Used under the hood to implement complexity validation,
# see {Schema#max_complexity} and {Query#max_complexity}
#
# @example Assert max complexity of 10
#   # DON'T actually do this, graphql-ruby
#   # Does this for you based on your `max_complexity` setting
#   MySchema.query_analyzers << GraphQL::Analysis::MaxQueryComplexity.new(10)
class GraphQL::Analysis::MaxQueryComplexity < ::GraphQL::Analysis::QueryComplexity
  # @return [MaxQueryComplexity] a new instance of MaxQueryComplexity
  def initialize(max_complexity); end
end

# Used under the hood to implement depth validation,
# see {Schema#max_depth} and {Query#max_depth}
#
# @example Assert max depth of 10
#   # DON'T actually do this, graphql-ruby
#   # Does this for you based on your `max_depth` setting
#   MySchema.query_analyzers << GraphQL::Analysis::MaxQueryDepth.new(10)
class GraphQL::Analysis::MaxQueryDepth < ::GraphQL::Analysis::QueryDepth
  # @return [MaxQueryDepth] a new instance of MaxQueryDepth
  def initialize(max_depth); end
end

# Calculate the complexity of a query, using {Field#complexity} values.
#
# @example Log the complexity of incoming queries
#   MySchema.query_analyzers << GraphQL::Analysis::QueryComplexity.new do |query, complexity|
#   Rails.logger.info("Complexity: #{complexity}")
#   end
class GraphQL::Analysis::QueryComplexity
  # @return [QueryComplexity] a new instance of QueryComplexity
  # @yield [query, complexity] Called for each query analyzed by the schema, before executing it
  # @yieldparam query [GraphQL::Query] The query that was analyzed
  # @yieldparam complexity [Numeric] The complexity for this query
  def initialize(&block); end

  # Implement the query analyzer API
  def call(memo, visit_type, irep_node); end

  # Send the query and complexity to the block
  #
  # @return [Object, GraphQL::AnalysisError] Whatever the handler returns
  def final_value(reduced_value); end

  # State for the query complexity calcuation:
  # - `target` is passed to handler
  # - `complexities_on_type` holds complexity scores for each type in an IRep node
  def initial_value(target); end

  private

  # Get a complexity value for a field,
  # by getting the number or calling its proc
  def get_complexity(irep_node, child_complexity); end
end

# Selections on an object may apply differently depending on what is _actually_ returned by the resolve function.
# Find the maximum possible complexity among those combinations.
class GraphQL::Analysis::QueryComplexity::TypeComplexity
  # @return [TypeComplexity] a new instance of TypeComplexity
  def initialize; end

  # Return the max possible complexity for types in this selection
  def max_possible_complexity; end

  # Store the complexity for the branch on `type_defn`.
  # Later we will see if this is the max complexity among branches.
  def merge(type_defn, complexity); end
end

# A query reducer for measuring the depth of a given query.
#
# @example Logging the depth of a query
#   Schema.query_analyzers << GraphQL::Analysis::QueryDepth.new { |query, depth|  puts "GraphQL query depth: #{depth}" }
#   Schema.execute(query_str)
#   # GraphQL query depth: 8
class GraphQL::Analysis::QueryDepth
  # @return [QueryDepth] a new instance of QueryDepth
  def initialize(&block); end

  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end
end

class GraphQL::Analysis::ReducerState
  # @return [ReducerState] a new instance of ReducerState
  def initialize(reducer, query); end

  def call(visit_type, irep_node); end

  # Returns the value of attribute errors.
  def errors; end

  # Sets the attribute errors
  #
  # @param value the value to set the attribute errors to.
  def errors=(_arg0); end

  # Respond with any errors, if found. Otherwise, if the reducer accepts
  # `final_value`, send it the last memo value.
  # Otherwise, use the last value from the traversal.
  #
  # @return [Any] final memo value
  def finalize_reducer; end

  # Returns the value of attribute memo.
  def memo; end

  # Sets the attribute memo
  #
  # @param value the value to set the attribute memo to.
  def memo=(_arg0); end

  # Returns the value of attribute reducer.
  def reducer; end

  private

  # If the reducer has an `initial_value` method, call it and store
  # the result as `memo`. Otherwise, use `nil` as memo.
  #
  # @return [Any] initial memo value
  def initialize_reducer(reducer, query); end
end

class GraphQL::AnalysisError < ::GraphQL::ExecutionError; end

# @api deprecated
class GraphQL::Argument
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  # @api deprecated
  # @return [Argument] a new instance of Argument
  def initialize; end

  # @api deprecated
  def as; end

  # @api deprecated
  def as=(_arg0); end

  # @api deprecated
  def ast_node; end

  # @api deprecated
  def ast_node=(_arg0); end

  # @api deprecated
  def default_value; end

  # @api deprecated
  def default_value=(new_default_value); end

  # @api deprecated
  # @return [Boolean]
  def default_value?; end

  # @api deprecated
  def deprecation_reason; end

  # @api deprecated
  def deprecation_reason=(_arg0); end

  # @api deprecated
  def description; end

  # @api deprecated
  def description=(_arg0); end

  # @api deprecated
  # @return [String] The name of this argument inside `resolve` functions
  def expose_as; end

  # @api deprecated
  def graphql_name; end

  # Backport this to support legacy-style directives
  #
  # @api deprecated
  def keyword; end

  # @api deprecated
  def method_access; end

  # @api deprecated
  def method_access=(_arg0); end

  # @api deprecated
  # @return [Boolean]
  def method_access?; end

  # @return [String] The name of this argument on its {GraphQL::Field} or {GraphQL::InputObjectType}
  def name; end

  # @return [String] The name of this argument on its {GraphQL::Field} or {GraphQL::InputObjectType}
  def name=(_arg0); end

  # @api deprecated
  # @param value [Object] The incoming value from variables or query string literal
  # @param ctx [GraphQL::Query::Context]
  # @return [Object] The prepared `value` for this argument or `value` itself if no `prepare` function exists.
  def prepare(value, ctx); end

  # Assign a `prepare` function to prepare this argument's value before `resolve` functions are called.
  #
  # @api deprecated
  # @param prepare_proc [#<call(value, ctx)] ]
  def prepare=(prepare_proc); end

  # @api deprecated
  # @return [GraphQL::BaseType] the input type for this argument
  def type; end

  # @api deprecated
  # @param new_input_type [GraphQL::BaseType, Proc] Assign a new input type for this argument (if it's a proc, it will be called after schema initialization)
  def type=(new_input_type); end

  # @api deprecated
  def type_class; end

  private

  # @api deprecated
  def initialize_copy(other); end

  class << self
    # @api private
    def deep_stringify(val); end

    # @api private
    def from_dsl(name, type_or_argument = T.unsafe(nil), description = T.unsafe(nil), default_value: T.unsafe(nil), as: T.unsafe(nil), prepare: T.unsafe(nil), **kwargs, &block); end
  end
end

# @api private
module GraphQL::Argument::DefaultPrepare
  class << self
    # @api private
    def call(value, ctx); end
  end
end

# @api deprecated
GraphQL::Argument::NO_DEFAULT_VALUE = T.let(T.unsafe(nil), Object)

module GraphQL::Authorization; end

# @deprecated authorization at query runtime is generally a better idea.
module GraphQL::Authorization::Analyzer
  private

  def call(memo, visit_type, irep_node); end
  def final_value(memo); end
  def initial_value(query); end

  class << self
    def call(memo, visit_type, irep_node); end
    def final_value(memo); end
    def initial_value(query); end
  end
end

class GraphQL::Authorization::InaccessibleFieldsError < ::GraphQL::AnalysisError
  # @return [InaccessibleFieldsError] a new instance of InaccessibleFieldsError
  def initialize(fields:, irep_nodes:, context:); end

  # @return [GraphQL::Query::Context] The current query's context
  def context; end

  # @return [Array<Schema::Field, GraphQL::Field>] Fields that failed `.accessible?` checks
  def fields; end

  # @return [Array<GraphQL::InternalRepresentation::Node>] The visited nodes that failed `.accessible?` checks
  # @see {#fields} for the Field definitions
  def irep_nodes; end
end

GraphQL::BOOLEAN_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# Wrap unhandled errors with {TracedError}.
#
# {TracedError} provides a GraphQL backtrace with arguments and return values.
# The underlying error is available as {TracedError#cause}.
#
# @example toggling backtrace annotation
#   class MySchema < GraphQL::Schema
#   if Rails.env.development? || Rails.env.test?
#   use GraphQL::Backtrace
#   end
#   end
class GraphQL::Backtrace
  include ::Enumerable
  extend ::Forwardable

  # @return [Backtrace] a new instance of Backtrace
  def initialize(context, value: T.unsafe(nil)); end

  def [](*args, **_arg1, &block); end
  def each(*args, **_arg1, &block); end
  def inspect; end
  def to_a; end
  def to_s; end

  class << self
    def use(schema_defn, legacy: T.unsafe(nil)); end
  end
end

# Used for internal bookkeeping
#
# @api private
class GraphQL::Backtrace::Frame
  # @api private
  # @return [Frame] a new instance of Frame
  def initialize(path:, query:, ast_node:, object:, field:, arguments:, parent_frame:); end

  # @api private
  def arguments; end

  # @api private
  def ast_node; end

  # @api private
  def field; end

  # @api private
  def object; end

  # @api private
  def parent_frame; end

  # @api private
  def path; end

  # @api private
  def query; end
end

module GraphQL::Backtrace::InspectResult
  private

  def inspect_result(obj); end
  def inspect_truncated(obj); end

  class << self
    def inspect_result(obj); end
    def inspect_truncated(obj); end
  end
end

module GraphQL::Backtrace::LegacyTracer
  private

  # Implement the {GraphQL::Tracing} API.
  def trace(key, metadata); end

  class << self
    # Implement the {GraphQL::Tracing} API.
    def trace(key, metadata); end
  end
end

# A class for turning a context into a human-readable table or array
class GraphQL::Backtrace::Table
  # @return [Table] a new instance of Table
  def initialize(context, value:); end

  # @return [Array<String>] An array of position + field name entries
  def to_backtrace; end

  # @return [String] A table layout of backtrace with metadata
  def to_table; end

  private

  # @return [Array] 5 items for a backtrace table (not `key`)
  def build_rows(context_entry, rows:, top: T.unsafe(nil)); end

  # @return [String]
  def render_table(rows); end

  def rows; end
  def value_at(runtime, path); end
end

GraphQL::Backtrace::Table::HEADERS = T.let(T.unsafe(nil), Array)
GraphQL::Backtrace::Table::MAX_COL_WIDTH = T.let(T.unsafe(nil), Integer)
GraphQL::Backtrace::Table::MIN_COL_WIDTH = T.let(T.unsafe(nil), Integer)

# When {Backtrace} is enabled, raised errors are wrapped with {TracedError}.
class GraphQL::Backtrace::TracedError < ::GraphQL::Error
  # @return [TracedError] a new instance of TracedError
  def initialize(err, current_ctx); end

  # @return [GraphQL::Query::Context] The context at the field where the error was raised
  def context; end

  # @return [Array<String>] Printable backtrace of GraphQL error context
  def graphql_backtrace; end
end

# This many lines of the original Ruby backtrace
# are included in the message
GraphQL::Backtrace::TracedError::CAUSE_BACKTRACE_PREVIEW_LENGTH = T.let(T.unsafe(nil), Integer)

GraphQL::Backtrace::TracedError::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# TODO this is not fiber-friendly
module GraphQL::Backtrace::Tracer
  private

  # Implement the {GraphQL::Tracing} API.
  def trace(key, metadata); end

  class << self
    # Implement the {GraphQL::Tracing} API.
    def trace(key, metadata); end
  end
end

# Helpers for migrating in a backwards-compatible way
# Remove this in GraphQL-Ruby 2.0, when all users of it will be gone.
#
# @api private
module GraphQL::BackwardsCompatibility
  private

  # @api private
  def get_arity(callable); end

  # Given a callable whose API used to take `from` arguments,
  # check its arity, and if needed, apply a wrapper so that
  # it can be called with `to` arguments.
  # If a wrapper is applied, warn the application with `name`.
  #
  # If `last`, then use the last arguments to call the function.
  #
  # @api private
  def wrap_arity(callable, from:, to:, name:, last: T.unsafe(nil)); end

  class << self
    # @api private
    def get_arity(callable); end

    # Given a callable whose API used to take `from` arguments,
    # check its arity, and if needed, apply a wrapper so that
    # it can be called with `to` arguments.
    # If a wrapper is applied, warn the application with `name`.
    #
    # If `last`, then use the last arguments to call the function.
    #
    # @api private
    def wrap_arity(callable, from:, to:, name:, last: T.unsafe(nil)); end
  end
end

# @api private
class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  # @api private
  # @return [FirstArgumentsWrapper] a new instance of FirstArgumentsWrapper
  def initialize(callable, old_arity); end

  # @api private
  def call(*args); end
end

# @api private
class GraphQL::BackwardsCompatibility::LastArgumentsWrapper < ::GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  # @api private
  def call(*args); end
end

# The parent for all type classes.
class GraphQL::BaseType
  include ::GraphQL::Define::NonNullWithBang
  include ::GraphQL::Define::InstanceDefinable
  include ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  # @return [BaseType] a new instance of BaseType
  def initialize; end

  # @param other [GraphQL::BaseType] compare to this object
  # @return [Boolean] are these types equivalent? (incl. non-null, list)
  # @see {ModifiesAnotherType#==} for override on List & NonNull types
  def ==(other); end

  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  #
  # @param value the value to set the attribute ast_node to.
  def ast_node=(_arg0); end

  def coerce_input(value, ctx = T.unsafe(nil)); end
  def coerce_isolated_input(value); end
  def coerce_isolated_result(value); end

  # @raise [GraphQL::RequiredImplementationMissingError]
  def coerce_result(value, ctx); end

  # @api private
  def default_relay=(_arg0); end

  # @return [Boolean] Is this type a built-in Relay type? (`Node`, `PageInfo`)
  def default_relay?; end

  # @api private
  def default_scalar=(_arg0); end

  # @return [Boolean] Is this type a built-in scalar type? (eg, `String`, `Int`)
  def default_scalar?; end

  # @return [String, nil] a description for this type
  def description; end

  # @return [String, nil] a description for this type
  def description=(_arg0); end

  # Types with fields may override this
  #
  # @param name [String] field name to lookup for this type
  # @return [GraphQL::Field, nil]
  def get_field(name); end

  # Future-compatible alias
  #
  # @see {GraphQL::SchemaMember}
  def graphql_definition(silence_deprecation_warning: T.unsafe(nil)); end

  # Future-compatible alias
  #
  # @return [String] the name of this type, must be unique within a Schema
  # @see {GraphQL::SchemaMember}
  def graphql_name; end

  # Print the human-readable name of this type using the query-string naming pattern
  def inspect; end

  # @api private
  def introspection=(_arg0); end

  # @return [Boolean] Is this type a predefined introspection type?
  def introspection?; end

  # Returns true if this is a list type. A non-nullable list is considered a list.
  #
  # @return [Boolean]
  def list?; end

  # @return [String] the name of this type, must be unique within a Schema
  def name; end

  def name=(name); end

  # Returns true if this is a non-nullable type. A nullable list of non-nullables is considered nullable.
  #
  # @return [Boolean]
  def non_null?; end

  # Find out which possible type to use for `value`.
  # Returns self if there are no possible types (ie, not Union or Interface)
  def resolve_type(value, ctx); end

  # Return a GraphQL string for the type definition
  #
  # @param schema [GraphQL::Schema]
  # @param printer [GraphQL::Schema::Printer]
  # @return [String] type definition
  # @see {GraphQL::Schema::Printer#initialize for additional options}
  def to_definition(schema, printer: T.unsafe(nil), **args); end

  # @return [GraphQL::ListType] a list version of this type
  def to_list_type; end

  # @return [GraphQL::NonNullType] a non-null version of this type
  def to_non_null_type; end

  # Print the human-readable name of this type using the query-string naming pattern
  def to_s; end

  # Print the human-readable name of this type using the query-string naming pattern
  def to_type_signature; end

  def type_class; end

  # If this type is modifying an underlying type,
  # return the underlying type. (Otherwise, return `self`.)
  def unwrap; end

  # @return [Boolean]
  def valid_input?(value, ctx = T.unsafe(nil)); end

  # @return [Boolean]
  def valid_isolated_input?(value); end

  def validate_input(value, ctx = T.unsafe(nil)); end
  def validate_isolated_input(value); end

  private

  def initialize_copy(other); end
  def warn_deprecated_coerce(alt_method_name); end

  class << self
    # During schema definition, types can be defined inside procs or as strings.
    # This function converts it to a type instance
    #
    # @return [GraphQL::BaseType]
    def resolve_related_type(type_arg); end
  end
end

module GraphQL::BaseType::ModifiesAnotherType
  def ==(other); end
  def unwrap; end
end

class GraphQL::CoercionError < ::GraphQL::Error
  # @return [CoercionError] a new instance of CoercionError
  def initialize(message, extensions: T.unsafe(nil)); end

  # under the `extensions` key.
  #
  # @return [Hash] Optional custom data for error objects which will be added
  def extensions; end

  # under the `extensions` key.
  #
  # @return [Hash] Optional custom data for error objects which will be added
  def extensions=(_arg0); end
end

module GraphQL::Compatibility; end

# Test an execution strategy. This spec is not meant as a development aid.
# Rather, when the strategy _works_, run it here to see if it has any differences
# from the built-in strategy.
#
# - Custom scalar input / output
# - Null propagation
# - Query-level masking
# - Directive support
# - Typecasting
# - Error handling (raise / return GraphQL::ExecutionError)
# - Provides Irep & AST node to resolve fn
# - Skipping fields
#
# Some things are explicitly _not_ tested here, because they're handled
# by other parts of the system:
#
# - Schema definition (including types and fields)
# - Parsing & parse errors
# - AST -> IRep transformation (eg, fragment merging)
# - Query validation and analysis
# - Relay features
module GraphQL::Compatibility::ExecutionSpecification
  class << self
    # Make a minitest suite for this execution strategy, making sure it
    # fulfills all the requirements of this library.
    #
    # @param execution_strategy [<#new, #execute>] An execution strategy class
    # @return [Class<Minitest::Test>] A test suite for this execution strategy
    def build_suite(execution_strategy); end
  end
end

module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
  class << self
    def build(execution_strategy); end
  end
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  class << self
    def build(execution_strategy); end
  end
end

GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::BOGUS_NODE = T.let(T.unsafe(nil), OpenStruct)

# A list object must implement #each
class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
  # @return [CustomCollection] a new instance of CustomCollection
  def initialize(storage); end

  def each(&block); end
end

GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::DATA = T.let(T.unsafe(nil), Hash)

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
  class << self
    def call(parent_type, parent_object, field_definition, field_args, query_context, &next_middleware); end
  end
end

module GraphQL::Compatibility::LazyExecutionSpecification
  class << self
    # @param execution_strategy [<#new, #execute>] An execution strategy class
    # @return [Class<Minitest::Test>] A test suite for this execution strategy
    def build_suite(execution_strategy); end
  end
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
  class << self
    def build(execution_strategy); end
  end
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
  class << self
    def instrument(type, field); end
  end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
  # @return [LazyPush] a new instance of LazyPush
  def initialize(ctx, value); end

  def push; end

  # Returns the value of attribute value.
  def value; end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
  # @return [LazyPushCollection] a new instance of LazyPushCollection
  def initialize(ctx, values); end

  def push; end
  def value; end
end

# This asserts that a given parse function turns a string into
# the proper tree of {{GraphQL::Language::Nodes}}.
module GraphQL::Compatibility::QueryParserSpecification
  class << self
    # @return [Class<Minitest::Test>] A test suite for this parse function
    # @yieldparam query_string [String] A query string to parse
    # @yieldreturn [GraphQL::Language::Nodes::Document]
    def build_suite(&block); end
  end
end

module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
  def assert_raises_parse_error(query_string); end
  def assert_rejects_character(char); end
  def test_it_includes_line_and_column; end
  def test_it_rejects_bad_unicode; end
  def test_it_rejects_blank_queries; end
  def test_it_rejects_empty_inline_fragments; end
  def test_it_rejects_invalid_characters; end
  def test_it_rejects_unexpected_ends; end
  def test_it_rejects_unterminated_strings; end
  def test_it_restricts_on; end
end

GraphQL::Compatibility::QueryParserSpecification::QUERY_STRING = T.let(T.unsafe(nil), String)

module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
  def assert_valid_directive(directive); end
  def assert_valid_field(field); end
  def assert_valid_fragment(fragment_def); end
  def assert_valid_fragment_spread(fragment_spread); end
  def assert_valid_literal_argument(argument); end
  def assert_valid_query(query); end
  def assert_valid_typed_inline_fragment(inline_fragment); end
  def assert_valid_typeless_inline_fragment(inline_fragment); end
  def assert_valid_variable(variable); end
  def assert_valid_variable_argument(argument); end
end

# This asserts that a given parse function turns a string into
# the proper tree of {{GraphQL::Language::Nodes}}.
module GraphQL::Compatibility::SchemaParserSpecification
  class << self
    # @return [Class<Minitest::Test>] A test suite for this parse function
    # @yieldparam query_string [String] A query string to parse
    # @yieldreturn [GraphQL::Language::Nodes::Document]
    def build_suite(&block); end
  end
end

GraphQL::Compatibility::SchemaParserSpecification::SCHEMA_DEFINITION_STRING = T.let(T.unsafe(nil), String)
GraphQL::DEPRECATED_BOOLEAN_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)
GraphQL::DEPRECATED_FLOAT_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)
GraphQL::DEPRECATED_ID_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# Ruby has `deprecate_constant`,
# but I don't see a way to give a nice error message in that case,
# so I'm doing this instead.
GraphQL::DEPRECATED_INT_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

GraphQL::DEPRECATED_STRING_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# This plugin supports Fiber-based concurrency, along with {GraphQL::Dataloader::Source}.
#
# @example Installing Dataloader
#
#   class MySchema < GraphQL::Schema
#   use GraphQL::Dataloader
#   end
# @example Waiting for batch-loaded data in a GraphQL field
#
#   field :team, Types::Team, null: true
#
#   def team
#   dataloader.with(Sources::Record, Team).load(object.team_id)
#   end
class GraphQL::Dataloader
  # @return [Dataloader] a new instance of Dataloader
  def initialize(nonblocking: T.unsafe(nil)); end

  # @api private Nothing to see here
  def append_job(&job); end

  def join_queues(previous_queue, next_queue); end

  # @return [Boolean]
  def nonblocking?; end

  # @api private Move along, move along
  def run; end

  # Use a self-contained queue for the work in the block.
  def run_isolated; end

  # truffle-ruby wasn't doing well with the implementation below
  def with(source_class, *batch_args, **batch_kwargs); end

  # Tell the dataloader that this fiber is waiting for data.
  #
  # Dataloader will resume the fiber after the requested data has been loaded (by another Fiber).
  #
  # @return [void]
  def yield; end

  private

  # If there are pending sources, return a fiber for running them.
  # Otherwise, return `nil`.
  #
  # @return [Fiber, nil]
  def create_source_fiber; end

  def resume(fiber); end

  # Copies the thread local vars into the fiber thread local vars. Many
  # gems (such as RequestStore, MiniRacer, etc.) rely on thread local vars
  # to keep track of execution context, and without this they do not
  # behave as expected.
  #
  # @see https://github.com/rmosolgo/graphql-ruby/issues/3449
  def spawn_fiber; end

  class << self
    # Returns the value of attribute default_nonblocking.
    def default_nonblocking; end

    # Sets the attribute default_nonblocking
    #
    # @param value the value to set the attribute default_nonblocking to.
    def default_nonblocking=(_arg0); end

    def use(schema, nonblocking: T.unsafe(nil)); end

    # Call the block with a Dataloader instance,
    # then run all enqueued jobs and return the result of the block.
    def with_dataloading(&block); end
  end
end

class GraphQL::Dataloader::AsyncDataloader < ::GraphQL::Dataloader; end

# The default implementation of dataloading -- all no-ops.
#
# The Dataloader interface isn't public, but it enables
# simple internal code while adding the option to add Dataloader.
class GraphQL::Dataloader::NullDataloader < ::GraphQL::Dataloader
  def append_job; end

  # These are all no-ops because code was
  # executed sychronously.
  def run; end

  def run_isolated; end
  def yield; end
end

# @see Source#request which returns an instance of this
class GraphQL::Dataloader::Request
  # @return [Request] a new instance of Request
  def initialize(source, key); end

  # Call this method to cause the current Fiber to wait for the results of this request.
  #
  # @return [Object] the object loaded for `key`
  def load; end
end

# @see Source#request_all which returns an instance of this.
class GraphQL::Dataloader::RequestAll < ::GraphQL::Dataloader::Request
  # @return [RequestAll] a new instance of RequestAll
  def initialize(source, keys); end

  # Call this method to cause the current Fiber to wait for the results of this request.
  #
  # @return [Array<Object>] One object for each of `keys`
  def load; end
end

class GraphQL::Dataloader::Source
  # Returns the value of attribute dataloader.
  def dataloader; end

  # Subclasses must implement this method to return a value for each of `keys`
  #
  # @param keys [Array<Object>] keys passed to {#load}, {#load_all}, {#request}, or {#request_all}
  # @return [Array<Object>] A loaded value for each of `keys`. The array must match one-for-one to the list of `keys`.
  def fetch(keys); end

  # @param key [Object] A loading key which will be passed to {#fetch} if it isn't already in the internal cache.
  # @return [Object] The result from {#fetch} for `key`. If `key` hasn't been loaded yet, the Fiber will yield until it's loaded.
  def load(key); end

  # @param keys [Array<Object>] Loading keys which will be passed to `#fetch` (or read from the internal cache).
  # @return [Object] The result from {#fetch} for `keys`. If `keys` haven't been loaded yet, the Fiber will yield until they're loaded.
  def load_all(keys); end

  # @return [Boolean] True if this source has any pending requests for data.
  def pending?; end

  # Returns the value of attribute pending_keys.
  def pending_keys; end

  # @return [Dataloader::Request] a pending request for a value from `key`. Call `.load` on that object to wait for the result.
  def request(key); end

  # @return [Dataloader::Request] a pending request for a values from `keys`. Call `.load` on that object to wait for the results.
  def request_all(keys); end

  # Called by {GraphQL::Dataloader} to resolve and pending requests to this source.
  #
  # @api private
  # @return [void]
  def run_pending_keys; end

  # Called by {Dataloader} to prepare the {Source}'s internal state
  #
  # @api private
  def setup(dataloader); end

  # Wait for a batch, if there's anything to batch.
  # Then run the batch and update the cache.
  #
  # @return [void]
  def sync; end

  private

  # Reads and returns the result for the key from the internal cache, or raises an error if the result was an error
  #
  # @api private
  # @param key [Object] key passed to {#load} or {#load_all}
  # @return [Object] The result from {#fetch} for `key`.
  def result_for(key); end

  class << self
    # These arguments are given to `dataloader.with(source_class, ...)`. The object
    # returned from this method is used to de-duplicate batch loads under the hood
    # by using it as a Hash key.
    #
    # By default, the arguments are all put in an Array. To customize how this source's
    # batches are merged, override this method to return something else.
    #
    # For example, if you pass `ActiveRecord::Relation`s to `.with(...)`, you could override
    # this method to call `.to_sql` on them, thus merging `.load(...)` calls when they apply
    # to equivalent relations.
    #
    # @param batch_args [Array<Object>]
    # @param batch_kwargs [Hash]
    # @return [Object]
    def batch_key_for(*batch_args, **batch_kwargs); end
  end
end

# This error is raised when `Types::ISO8601Date` is asked to return a value
# that cannot be parsed to a Ruby Date.
#
# @see GraphQL::Types::ISO8601Date which raises this error
class GraphQL::DateEncodingError < ::GraphQL::RuntimeTypeError
  # @return [DateEncodingError] a new instance of DateEncodingError
  def initialize(value); end

  # The value which couldn't be encoded
  def date_value; end
end

module GraphQL::Define
  class << self
    # A helper for definitions that store their value in `#metadata`.
    #
    # @example Storing application classes with GraphQL types
    #   # Make a custom definition
    #   GraphQL::ObjectType.accepts_definitions(resolves_to_class_names: GraphQL::Define.assign_metadata_key(:resolves_to_class_names))
    #
    #   # After definition, read the key from metadata
    #   PostType.metadata[:resolves_to_class_names] # => [...]
    # @param key [Object] the key to assign in metadata
    # @return [#call(defn, value)] an assignment for `.accepts_definitions` which writes `key` to `#metadata`
    def assign_metadata_key(key); end
  end
end

# Turn argument configs into a {GraphQL::Argument}.
module GraphQL::Define::AssignArgument
  class << self
    def call(target, *args, **kwargs, &block); end
  end
end

module GraphQL::Define::AssignConnection
  class << self
    def call(type_defn, *field_args, max_page_size: T.unsafe(nil), **field_kwargs, &field_block); end
  end
end

# @api deprecated
module GraphQL::Define::AssignEnumValue
  class << self
    # @api deprecated
    def call(enum_type, name, desc = T.unsafe(nil), deprecation_reason: T.unsafe(nil), value: T.unsafe(nil), &block); end
  end
end

module GraphQL::Define::AssignGlobalIdField
  class << self
    def call(type_defn, field_name, **field_kwargs); end
  end
end

module GraphQL::Define::AssignMutationFunction
  class << self
    def call(target, function); end
  end
end

class GraphQL::Define::AssignMutationFunction::ResultProxy < ::SimpleDelegator
  # @return [ResultProxy] a new instance of ResultProxy
  def initialize(target, client_mutation_id); end

  # Returns the value of attribute client_mutation_id.
  def client_mutation_id; end
end

# @api deprecated
module GraphQL::Define::AssignObjectField
  class << self
    # @api deprecated
    def call(owner_type, name, type_or_field = T.unsafe(nil), desc = T.unsafe(nil), function: T.unsafe(nil), field: T.unsafe(nil), relay_mutation_function: T.unsafe(nil), **kwargs, &block); end
  end
end

# This object delegates most methods to a dictionary of functions, {@dictionary}.
# {@target} is passed to the specified function, along with any arguments and block.
# This allows a method-based DSL without adding methods to the defined class.
class GraphQL::Define::DefinedObjectProxy
  extend ::GraphQL::Ruby2Keywords

  # @return [DefinedObjectProxy] a new instance of DefinedObjectProxy
  def initialize(target); end

  # Lookup a function from the dictionary and call it if it's found.
  def method_missing(name, *args, **_arg2, &block); end

  # The object which will be defined by definition functions
  def target; end

  # Provides shorthand access to GraphQL's built-in types
  def types; end

  # Allow `plugin` to perform complex initialization on the definition.
  # Calls `plugin.use(defn, **kwargs)`.
  #
  # @param plugin [<#use(defn, **kwargs)>] A plugin object
  # @param kwargs [Hash] Any options for the plugin
  def use(plugin, **kwargs); end

  private

  # @return [Boolean]
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# @api deprecated
module GraphQL::Define::InstanceDefinable
  mixes_in_class_methods ::GraphQL::Define::InstanceDefinable::ClassMethods

  # @api deprecated
  def define(**kwargs, &block); end

  # @api deprecated
  def deprecated_define(**kwargs, &block); end

  # @api deprecated
  def metadata; end

  # @api deprecated
  def redefine(**kwargs, &block); end

  private

  # Run the definition block if it hasn't been run yet.
  # This can only be run once: the block is deleted after it's used.
  # You have to call this before using any value which could
  # come from the definition block.
  #
  # @api deprecated
  # @return [void]
  def ensure_defined; end

  # @api deprecated
  def initialize_copy(other); end

  # Take the pending methods and put them back on this object's singleton class.
  # This reverts the process done by {#stash_dependent_methods}
  #
  # @api deprecated
  # @return [void]
  def revive_dependent_methods; end

  # Find the method names which were declared as definition-dependent,
  # then grab the method definitions off of this object's class
  # and store them for later.
  #
  # Then make a dummy method for each of those method names which:
  #
  # - Triggers the pending definition, if there is one
  # - Calls the same method again.
  #
  # It's assumed that {#ensure_defined} will put the original method definitions
  # back in place with {#revive_dependent_methods}.
  #
  # @api deprecated
  # @return [void]
  def stash_dependent_methods; end

  class << self
    # @api deprecated
    # @private
    def included(base); end
  end
end

# @api deprecated
class GraphQL::Define::InstanceDefinable::AssignAttribute
  extend ::GraphQL::Ruby2Keywords

  # @api deprecated
  # @return [AssignAttribute] a new instance of AssignAttribute
  def initialize(attr_name); end

  # Even though we're just using the first value here,
  # We have to add a splat here to use `ruby2_keywords`,
  # so that it will accept a `[{}]` input from the caller.
  #
  # @api deprecated
  def call(defn, *value, **_arg2); end
end

# @api deprecated
class GraphQL::Define::InstanceDefinable::AssignMetadataKey
  # @api deprecated
  # @return [AssignMetadataKey] a new instance of AssignMetadataKey
  def initialize(key); end

  # @api deprecated
  def call(defn, value = T.unsafe(nil)); end
end

# @api deprecated
module GraphQL::Define::InstanceDefinable::ClassMethods
  # Attach definitions to this class.
  # Each symbol in `accepts` will be assigned with `{key}=`.
  # The last entry in accepts may be a hash of name-proc pairs for custom definitions.
  #
  # @api deprecated
  def accepts_definitions(*accepts); end

  # @api deprecated
  def define(**kwargs, &block); end

  # Create a new instance
  # and prepare a definition using its {.definitions}.
  #
  # @api deprecated
  # @param kwargs [Hash] Key-value pairs corresponding to defininitions from `accepts_definitions`
  # @param block [Proc] Block which calls helper methods from `accepts_definitions`
  def deprecated_define(**kwargs, &block); end

  # @api deprecated
  # @return [Hash] combined definitions for self and ancestors
  def dictionary; end

  # @api deprecated
  def ensure_defined(*method_names); end

  # @api deprecated
  def ensure_defined_method_names; end

  # @api deprecated
  # @return [Hash] definitions for this class only
  def own_dictionary; end
end

# @api deprecated
class GraphQL::Define::InstanceDefinable::Definition
  # @api deprecated
  # @return [Definition] a new instance of Definition
  def initialize(define_keywords, define_proc); end

  # @api deprecated
  def define_keywords; end

  # @api deprecated
  def define_proc; end
end

# @api deprecated
module GraphQL::Define::InstanceDefinable::DeprecatedDefine
  # @api deprecated
  def define(**kwargs, &block); end
end

class GraphQL::Define::NoDefinitionError < ::GraphQL::Error; end

# Wrap the object in NonNullType in response to `!`
#
# @example required Int type
#   !GraphQL::INT_TYPE
module GraphQL::Define::NonNullWithBang
  # Make the type non-null
  #
  # @return [GraphQL::NonNullType] a non-null type which wraps the original type
  def !; end
end

# Some conveniences for definining return & argument types.
#
# Passed into initialization blocks, eg {ObjectType#initialize}, {Field#initialize}
class GraphQL::Define::TypeDefiner
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def Boolean; end
  def Float; end
  def ID; end
  def Int; end
  def String; end

  # Make a {ListType} which wraps the input type
  #
  # @example making a list type
  #   list_of_strings = types[types.String]
  #   list_of_strings.inspect
  #   # => "[String]"
  # @param type [Type] A type to be wrapped in a ListType
  # @return [GraphQL::ListType] A ListType wrapping `type`
  def [](type); end
end

# There are two ways to apply the deprecated `!` DSL to class-style schema definitions:
#
# 1. Scoped by file (CRuby only), add to the top of the file:
#
#      using GraphQL::DeprecationDSL
#
#   (This is a "refinement", there are also other ways to scope it.)
#
# 2. Global application, add before schema definition:
#
#      GraphQL::DeprecationDSL.activate
module GraphQL::DeprecatedDSL
  class << self
    def activate; end
  end
end

module GraphQL::DeprecatedDSL::Methods
  def !; end
end

GraphQL::DeprecatedDSL::TYPE_CLASSES = T.let(T.unsafe(nil), Array)

module GraphQL::Deprecation
  class << self
    def warn(message); end
  end
end

module GraphQL::Dig
  # implemented using the old activesupport #dig instead of the ruby built-in
  # so we can use some of the magic in Schema::InputObject and Query::Arguments
  # to handle stringified/symbolized keys.
  #
  # @param args [Array<[String, Symbol>] Retrieves the value object corresponding to the each key objects repeatedly] rgs [Array<[String, Symbol>] Retrieves the value object corresponding to the each key objects repeatedly
  # @return [Object]
  def dig(own_key, *rest_keys); end
end

# Directives are server-defined hooks for modifying execution.
#
# Two directives are included out-of-the-box:
# - `@skip(if: ...)` Skips the tagged field if the value of `if` is true
# - `@include(if: ...)` Includes the tagged field _only_ if `if` is true
class GraphQL::Directive
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  # @return [Directive] a new instance of Directive
  def initialize; end

  # Returns the value of attribute arguments.
  def arguments; end

  # Sets the attribute arguments
  #
  # @param value the value to set the attribute arguments to.
  def arguments=(_arg0); end

  # Returns the value of attribute arguments_class.
  def arguments_class; end

  # Sets the attribute arguments_class
  #
  # @param value the value to set the attribute arguments_class to.
  def arguments_class=(_arg0); end

  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  #
  # @param value the value to set the attribute ast_node to.
  def ast_node=(_arg0); end

  # @api private
  def default_directive=(_arg0); end

  # @return [Boolean] Is this directive supplied by default? (eg `@skip`)
  def default_directive?; end

  # Returns the value of attribute description.
  def description; end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  def description=(_arg0); end

  def get_argument(argument_name); end

  # Future-compatible alias
  #
  # @see {GraphQL::SchemaMember}
  def graphql_definition; end

  # Returns the value of attribute name.
  # Future-compatible alias
  #
  # @see {GraphQL::SchemaMember}
  def graphql_name; end

  def inspect; end

  # Returns the value of attribute locations.
  def locations; end

  # Sets the attribute locations
  #
  # @param value the value to set the attribute locations to.
  def locations=(_arg0); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # @return [Boolean]
  def on_field?; end

  # @return [Boolean]
  def on_fragment?; end

  # @return [Boolean]
  def on_operation?; end

  def to_s; end
  def type_class; end
end

GraphQL::Directive::ARGUMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::DeprecatedDirective = T.let(T.unsafe(nil), GraphQL::Directive)
GraphQL::Directive::ENUM = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::ENUM_VALUE = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::FIELD = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::FRAGMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::FRAGMENT_SPREAD = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::INLINE_FRAGMENT = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::INPUT_FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::INPUT_OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::INTERFACE = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::IncludeDirective = T.let(T.unsafe(nil), GraphQL::Directive)
GraphQL::Directive::LOCATIONS = T.let(T.unsafe(nil), Array)
GraphQL::Directive::LOCATION_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
GraphQL::Directive::MUTATION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::QUERY = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::SCALAR = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::SCHEMA = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::SUBSCRIPTION = T.let(T.unsafe(nil), Symbol)
GraphQL::Directive::SkipDirective = T.let(T.unsafe(nil), GraphQL::Directive)
GraphQL::Directive::UNION = T.let(T.unsafe(nil), Symbol)

# @api deprecated
class GraphQL::EnumType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  # @api deprecated
  # @return [EnumType] a new instance of EnumType
  def initialize; end

  # @api deprecated
  # @param enum_value [EnumValue] A value to add to this type's set of values
  def add_value(enum_value); end

  # @api deprecated
  def ast_node; end

  # @api deprecated
  def ast_node=(_arg0); end

  # @api deprecated
  def coerce_result(value, ctx = T.unsafe(nil)); end

  # @api deprecated
  def enum_values(_context = T.unsafe(nil)); end

  # @api deprecated
  def kind; end

  # @api deprecated
  def to_s; end

  # @api deprecated
  # @return [Hash<String => EnumValue>] `{name => value}` pairs contained in this type
  def values(_context = T.unsafe(nil)); end

  # @api deprecated
  # @param new_values [Array<EnumValue>] The set of values contained in this type
  def values=(new_values); end

  private

  # Get the underlying value for this enum value
  #
  # @api deprecated
  # @example get episode value from Enum
  #   episode = EpisodeEnum.coerce("NEWHOPE")
  #   episode # => 6
  # @param value_name [String] the string representation of this enum value
  # @return [Object] the underlying value for this enum value
  def coerce_non_null_input(value_name, ctx); end

  # @api deprecated
  def initialize_copy(other); end

  # @api deprecated
  def validate_non_null_input(value_name, ctx); end
end

# A value within an {EnumType}
#
# Created with the `value` helper
#
# @api deprecated
class GraphQL::EnumType::EnumValue
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  # @api deprecated
  def ast_node; end

  # @api deprecated
  def ast_node=(_arg0); end

  def deprecation_reason; end
  def deprecation_reason=(_arg0); end
  def description; end
  def description=(_arg0); end

  # @api deprecated
  def graphql_name; end

  def name; end

  # @api deprecated
  def name=(new_name); end

  # @api deprecated
  def type_class; end

  def value; end
  def value=(_arg0); end
end

# @api deprecated
GraphQL::EnumType::EnumValue::ATTRIBUTES = T.let(T.unsafe(nil), Array)

# @api deprecated
class GraphQL::EnumType::UnresolvedValueError < ::GraphQL::Error; end

class GraphQL::Error < ::StandardError; end
module GraphQL::Execution; end

# Boolean checks for how an AST node's directives should
# influence its execution
#
# @api private
module GraphQL::Execution::DirectiveChecks
  private

  # @api private
  # @return [Boolean] Should this node be included in the query?
  def include?(directive_ast_nodes, query); end

  class << self
    # @api private
    # @return [Boolean] Should this node be included in the query?
    def include?(directive_ast_nodes, query); end
  end
end

# @api private
GraphQL::Execution::DirectiveChecks::INCLUDE = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Execution::DirectiveChecks::SKIP = T.let(T.unsafe(nil), String)

# A plugin that wraps query execution with error handling.
# Supports class-based schemas and the new {Interpreter} runtime only.
#
# @example Handling ActiveRecord::NotFound
#
#   class MySchema < GraphQL::Schema
#   use GraphQL::Execution::Errors
#
#   rescue_from(ActiveRecord::NotFound) do |err, obj, args, ctx, field|
#   ErrorTracker.log("Not Found: #{err.message}")
#   nil
#   end
#   end
class GraphQL::Execution::Errors
  # @return [Errors] a new instance of Errors
  def initialize(schema); end

  # @api private
  def each_rescue; end

  # @return [Proc, nil] The handler for `error_class`, if one was registered on this schema or inherited
  def find_handler_for(error_class); end

  # Register this handler, updating the
  # internal handler index to maintain least-to-most specific.
  #
  # @param error_class [Class<Exception>]
  # @param error_handler [Proc]
  # @return [void]
  def rescue_from(error_class, error_handler); end

  # Call the given block with the schema's configured error handlers.
  #
  # If the block returns a lazy value, it's not wrapped with error handling. That area will have to be wrapped itself.
  #
  # @param ctx [GraphQL::Query::Context]
  # @return [Object] Either the result of the given block, or some object to replace the result, in case of error handling.
  def with_error_handling(ctx); end

  class << self
    def use(schema); end
  end
end

GraphQL::Execution::Errors::NEW_HANDLER_HASH = T.let(T.unsafe(nil), Proc)

# A valid execution strategy
#
# @api private
class GraphQL::Execution::Execute
  include ::GraphQL::Execution::Execute::ExecutionFunctions

  # @api private
  def execute(ast_operation, root_type, query); end

  class << self
    # @api private
    def begin_multiplex(_multiplex); end

    # @api private
    def begin_query(query, _multiplex); end

    # @api private
    def finish_multiplex(results, multiplex); end

    # @api private
    def finish_query(query, _multiplex); end

    # @api private
    def use(schema_class); end
  end
end

# @api private
module GraphQL::Execution::Execute::ExecutionFunctions
  private

  # If the returned object is lazy (unfinished),
  # assign the lazy object to `.value=` so we can resolve it later.
  # When we resolve it later, reassign it to `.value=` so that
  # the finished value replaces the unfinished one.
  #
  # If the returned object is finished, continue to coerce
  # and resolve child fields
  #
  # @api private
  def continue_or_wait(raw_value, field_type, field_ctx); end

  # @api private
  def continue_resolve_field(raw_value, field_type, field_ctx); end

  # @api private
  def lazy_resolve_root_selection(result, query: T.unsafe(nil), multiplex: T.unsafe(nil)); end

  # @api private
  def resolve_field(object, field_ctx); end

  # @api private
  def resolve_root_selection(query); end

  # @api private
  def resolve_selection(object, current_type, current_ctx, mutation: T.unsafe(nil)); end

  # @api private
  def resolve_value(value, field_type, field_ctx); end

  class << self
    # If the returned object is lazy (unfinished),
    # assign the lazy object to `.value=` so we can resolve it later.
    # When we resolve it later, reassign it to `.value=` so that
    # the finished value replaces the unfinished one.
    #
    # If the returned object is finished, continue to coerce
    # and resolve child fields
    #
    # @api private
    def continue_or_wait(raw_value, field_type, field_ctx); end

    # @api private
    def continue_resolve_field(raw_value, field_type, field_ctx); end

    # @api private
    def lazy_resolve_root_selection(result, query: T.unsafe(nil), multiplex: T.unsafe(nil)); end

    # @api private
    def resolve_field(object, field_ctx); end

    # @api private
    def resolve_root_selection(query); end

    # @api private
    def resolve_selection(object, current_type, current_ctx, mutation: T.unsafe(nil)); end

    # @api private
    def resolve_value(value, field_type, field_ctx); end
  end
end

# A `.call`-able suitable to be the last step in a middleware chain
#
# @api private
module GraphQL::Execution::Execute::FieldResolveStep
  class << self
    # Execute the field's resolve method
    #
    # @api private
    def call(_parent_type, parent_object, field_definition, field_args, context, _next = T.unsafe(nil)); end
  end
end

# @api private
GraphQL::Execution::Execute::PROPAGATE_NULL = T.let(T.unsafe(nil), GraphQL::Execution::Execute::PropagateNull)

# @api private
class GraphQL::Execution::Execute::PropagateNull; end

# Just a singleton for implementing {Query::Context#skip}
#
# @api private
GraphQL::Execution::Execute::SKIP = T.let(T.unsafe(nil), GraphQL::Execution::Execute::Skip)

# @api private
class GraphQL::Execution::Execute::Skip < ::GraphQL::Error; end

# Starting from a root context,
# create a hash out of the context tree.
#
# @api private
module GraphQL::Execution::Flatten
  class << self
    # @api private
    def call(ctx); end

    private

    # @api private
    def flatten(obj); end
  end
end

module GraphQL::Execution::Instrumentation
  class << self
    # This function implements the instrumentation policy:
    #
    # - Instrumenters are a stack; the first `before_query` will have the last `after_query`
    # - If a `before_` hook returned without an error, its corresponding `after_` hook will run.
    # - If the `before_` hook did _not_ run, the `after_` hook will not be called.
    #
    # When errors are raised from `after_` hooks:
    #   - Subsequent `after_` hooks _are_ called
    #   - The first raised error is captured; later errors are ignored
    #   - If an error was capture, it's re-raised after all hooks are finished
    #
    # Partial runs of instrumentation are possible:
    # - If a `before_multiplex` hook raises an error, no `before_query` hooks will run
    # - If a `before_query` hook raises an error, subsequent `before_query` hooks will not run (on any query)
    def apply_instrumenters(multiplex); end

    private

    def call_after_hooks(instrumenters, object, after_hook_name, ex); end

    # Call each before hook, and if they all succeed, yield.
    # If they don't all succeed, call after_ for each one that succeeded.
    def call_hooks(instrumenters, object, before_hook_name, after_hook_name); end

    # Call the before_ hooks of each query,
    # Then yield if no errors.
    # `call_hooks` takes care of appropriate cleanup.
    def each_query_call_hooks(instrumenters, queries, i = T.unsafe(nil)); end
  end
end

class GraphQL::Execution::Interpreter
  # @return [Interpreter] a new instance of Interpreter
  def initialize; end

  # Run the eager part of `query`
  #
  # @return [Interpreter::Runtime]
  def evaluate(query); end

  # Support `Executor` :S
  def execute(_operation, _root_type, query); end

  # Run the lazy part of `query` or `multiplex`.
  #
  # @return [void]
  def sync_lazies(query: T.unsafe(nil), multiplex: T.unsafe(nil)); end

  class << self
    def begin_multiplex(multiplex); end
    def begin_query(query, multiplex); end
    def finish_multiplex(_results, multiplex); end
    def finish_query(query, _multiplex); end
    def use(schema_class); end
  end
end

# A container for metadata regarding arguments present in a GraphQL query.
#
# @see Interpreter::Arguments#argument_values for a hash of these objects.
class GraphQL::Execution::Interpreter::ArgumentValue
  # @return [ArgumentValue] a new instance of ArgumentValue
  def initialize(definition:, value:, default_used:); end

  # @return [Boolean] `true` if the schema-defined `default_value:` was applied in this case. (No client-provided value was present.)
  def default_used?; end

  # @return [GraphQL::Schema::Argument] The definition instance for this argument
  def definition; end

  # @return [Object] The Ruby-ready value for this Argument
  def value; end
end

# A wrapper for argument hashes in GraphQL queries.
#
# This object is immutable so that the runtime code can be sure that
# modifications don't leak from one use to another
#
# @see GraphQL::Query#arguments_for to get access to these objects.
class GraphQL::Execution::Interpreter::Arguments
  include ::GraphQL::Dig
  extend ::Forwardable

  # @param argument_values [nil, Hash{Symbol => ArgumentValue}]
  # @param keyword_arguments [nil, Hash{Symbol => Object}]
  # @return [Arguments] a new instance of Arguments
  def initialize(argument_values:, keyword_arguments: T.unsafe(nil)); end

  def [](*args, **_arg1, &block); end

  # @return [Hash{Symbol => ArgumentValue}]
  def argument_values; end

  def each(*args, **_arg1, &block); end
  def each_value(*args, **_arg1, &block); end

  # @return [Boolean]
  def empty?; end

  def fetch(*args, **_arg1, &block); end
  def inspect; end
  def key?(*args, **_arg1, &block); end
  def keys(*args, **_arg1, &block); end

  # The Ruby-style arguments hash, ready for a resolver.
  # This hash is the one used at runtime.
  #
  # @return [Hash<Symbol, Object>]
  def keyword_arguments; end

  # Create a new arguments instance which includes these extras.
  #
  # This is called by the runtime to implement field `extras: [...]`
  #
  # @api private
  # @param extra_args [Hash<Symbol => Object>]
  # @return [Interpreter::Arguments]
  def merge_extras(extra_args); end

  def size(*args, **_arg1, &block); end
  def to_h(*args, **_arg1, &block); end
  def values(*args, **_arg1, &block); end
end

GraphQL::Execution::Interpreter::Arguments::EMPTY = T.let(T.unsafe(nil), GraphQL::Execution::Interpreter::Arguments)
GraphQL::Execution::Interpreter::Arguments::NO_ARGS = T.let(T.unsafe(nil), Hash)

class GraphQL::Execution::Interpreter::ArgumentsCache
  # @return [ArgumentsCache] a new instance of ArgumentsCache
  def initialize(query); end

  # @yield [Interpreter::Arguments, Lazy<Interpreter::Arguments>] The finally-loaded arguments
  def dataload_for(ast_node, argument_owner, parent_object, &block); end

  def fetch(ast_node, argument_owner, parent_object); end

  class << self
    def prepare_args_hash(query, ast_arg_or_hash_or_value); end
  end
end

GraphQL::Execution::Interpreter::ArgumentsCache::NO_ARGUMENTS = T.let(T.unsafe(nil), Hash)
GraphQL::Execution::Interpreter::ArgumentsCache::NO_VALUE_GIVEN = T.let(T.unsafe(nil), Object)

class GraphQL::Execution::Interpreter::ExecutionErrors
  # @return [ExecutionErrors] a new instance of ExecutionErrors
  def initialize(ctx, ast_node, path); end

  def add(err_or_msg); end
end

class GraphQL::Execution::Interpreter::ListResultFailedError < ::GraphQL::Error
  # @return [ListResultFailedError] a new instance of ListResultFailedError
  def initialize(value:, path:, field:); end
end

# Wrapper for raw values
class GraphQL::Execution::Interpreter::RawValue
  # @return [RawValue] a new instance of RawValue
  def initialize(obj = T.unsafe(nil)); end

  def resolve; end
end

module GraphQL::Execution::Interpreter::Resolve
  class << self
    # After getting `results` back from an interpreter evaluation,
    # continue it until you get a response-ready Ruby value.
    #
    # `results` is one level of _depth_ of a query or multiplex.
    #
    # Resolve all lazy values in that depth before moving on
    # to the next level.
    #
    # It's assumed that the lazies will
    # return {Lazy} instances if there's more work to be done,
    # or return {Hash}/{Array} if the query should be continued.
    #
    # @return [void]
    def resolve(results, dataloader); end

    # Continue field results in `results` until there's nothing else to continue.
    #
    # @return [void]
    def resolve_all(results, dataloader); end
  end
end

# I think it would be even better if we could somehow make
# `continue_field` not recursive. "Trampolining" it somehow.
#
# @api private
class GraphQL::Execution::Interpreter::Runtime
  # @api private
  # @return [Runtime] a new instance of Runtime
  def initialize(query:); end

  # @api private
  # @param obj [Object] Some user-returned value that may want to be batched
  # @param path [Array<String>]
  # @param field [GraphQL::Schema::Field]
  # @param eager [Boolean] Set to `true` for mutation root fields only
  # @param trace [Boolean] If `false`, don't wrap this with field tracing
  # @return [GraphQL::Execution::Lazy, Object] If loading `object` will be deferred, it's a wrapper over it.
  def after_lazy(lazy_obj, owner:, field:, path:, scoped_context:, owner_object:, arguments:, ast_node:, result:, result_name:, eager: T.unsafe(nil), trace: T.unsafe(nil), &block); end

  # @api private
  def arguments(graphql_object, arg_owner, ast_node); end

  # @api private
  def authorized_new(type, value, context); end

  # @api private
  def call_method_on_directives(method_name, object, directives, &block); end

  # @api private
  # @return [GraphQL::Query::Context]
  def context; end

  # The resolver for `field` returned `value`. Continue to execute the query,
  # treating `value` as `type` (probably the return type of the field).
  #
  # Use `next_selections` to resolve object fields, if there are any.
  #
  # Location information from `path` and `ast_node`.
  #
  # @api private
  # @return [Lazy, Array, Hash, Object] Lazy, Array, and Hash are all traversed to resolve lazy values later
  def continue_field(path, value, owner_type, field, current_type, ast_node, next_selections, is_non_null, owner_object, arguments, result_name, selection_result); end

  # @api private
  def continue_value(path, value, parent_type, field, is_non_null, ast_node, result_name, selection_result); end

  # @api private
  # @return [Boolean]
  def dead_result?(selection_result); end

  # @api private
  # @return [void]
  def deep_merge_selection_result(from_result, into_result); end

  # @api private
  def delete_interpreter_context(key); end

  # Check {Schema::Directive.include?} for each directive that's present
  #
  # @api private
  # @return [Boolean]
  def directives_include?(node, graphql_object, parent_type); end

  # @api private
  # @return [void]
  def evaluate_selection(path, result_name, field_ast_nodes_or_ast_node, scoped_context, owner_object, owner_type, is_eager_field, selections_result, parent_object); end

  # @api private
  def evaluate_selection_with_args(arguments, field_defn, next_path, ast_node, field_ast_nodes, scoped_context, owner_type, object, is_eager_field, result_name, selection_result, parent_object); end

  # @api private
  # @return [void]
  def evaluate_selections(path, scoped_context, owner_object, owner_type, is_eager_selection, gathered_selections, selections_result, target_result, parent_object); end

  # @api private
  def final_result; end

  # @api private
  def gather_selections(owner_object, owner_type, selections, selections_to_run = T.unsafe(nil), selections_by_name = T.unsafe(nil)); end

  # @api private
  def inspect; end

  # @api private
  # @return [Boolean]
  def lazy?(object); end

  # @api private
  def progress_path; end

  # @api private
  # @return [GraphQL::Query]
  def query; end

  # @api private
  def resolve_list_item(inner_value, inner_type, next_path, ast_node, scoped_context, field, owner_object, arguments, this_idx, response_list, next_selections, owner_type); end

  # @api private
  def resolve_type(type, value, path); end

  # @api private
  def run_directive(method_name, object, directives, idx, &block); end

  # This _begins_ the execution. Some deferred work
  # might be stored up in lazies.
  #
  # @api private
  # @return [void]
  def run_eager; end

  # @api private
  # @return [Class<GraphQL::Schema>]
  def schema; end

  # @api private
  def set_all_interpreter_context(object, field, arguments, path); end

  # Mark this node and any already-registered children as dead,
  # so that it accepts no more writes.
  #
  # @api private
  def set_graphql_dead(selection_result); end

  # Set this pair in the Query context, but also in the interpeter namespace,
  # for compatibility.
  #
  # @api private
  def set_interpreter_context(key, value); end

  # @api private
  def set_result(selection_result, result_name, value); end

  # @api private
  def tap_or_each(obj_or_array); end
end

# @api private
module GraphQL::Execution::Interpreter::Runtime::GraphQLResult
  # @api private
  def initialize(result_name, parent_result); end

  # @api private
  def graphql_dead; end

  # @api private
  def graphql_dead=(_arg0); end

  # Although these are used by only one of the Result classes,
  # it's handy to have the methods implemented on both (even though they just return `nil`)
  # because it makes it easy to check if anything is assigned.
  #
  # @api private
  # @return [nil, Array<String>]
  def graphql_non_null_field_names; end

  # Although these are used by only one of the Result classes,
  # it's handy to have the methods implemented on both (even though they just return `nil`)
  # because it makes it easy to check if anything is assigned.
  #
  # @api private
  # @return [nil, Array<String>]
  def graphql_non_null_field_names=(_arg0); end

  # @api private
  # @return [nil, true]
  def graphql_non_null_list_items; end

  # @api private
  # @return [nil, true]
  def graphql_non_null_list_items=(_arg0); end

  # @api private
  def graphql_parent; end

  # @api private
  # @return [Hash] Plain-Ruby result data (`@graphql_metadata` contains Result wrapper objects)
  def graphql_result_data; end

  # @api private
  # @return [Hash] Plain-Ruby result data (`@graphql_metadata` contains Result wrapper objects)
  def graphql_result_data=(_arg0); end

  # @api private
  def graphql_result_name; end
end

# @api private
class GraphQL::Execution::Interpreter::Runtime::GraphQLResultArray
  include ::GraphQL::Execution::Interpreter::Runtime::GraphQLResult

  # @api private
  # @return [GraphQLResultArray] a new instance of GraphQLResultArray
  def initialize(_result_name, _parent_result); end

  # @api private
  def []=(idx, value); end

  # @api private
  def graphql_skip_at(index); end

  # @api private
  def values; end
end

# @api private
class GraphQL::Execution::Interpreter::Runtime::GraphQLResultHash
  include ::GraphQL::Execution::Interpreter::Runtime::GraphQLResult

  # @api private
  # @return [GraphQLResultHash] a new instance of GraphQLResultHash
  def initialize(_result_name, _parent_result); end

  # @api private
  def [](k); end

  # @api private
  def []=(key, value); end

  # @api private
  def delete(key); end

  # @api private
  def each; end

  # @api private
  def graphql_merged_into; end

  # @api private
  def graphql_merged_into=(_arg0); end

  # @api private
  # @return [Boolean]
  def key?(k); end

  # @api private
  def values; end
end

# @api private
class GraphQL::Execution::Interpreter::Runtime::GraphQLSelectionSet < ::Hash
  # @api private
  def graphql_directives; end

  # @api private
  def graphql_directives=(_arg0); end
end

# @api private
GraphQL::Execution::Interpreter::Runtime::HALT = T.let(T.unsafe(nil), Object)

# @api private
GraphQL::Execution::Interpreter::Runtime::NO_ARGS = T.let(T.unsafe(nil), Hash)

# This wraps a value which is available, but not yet calculated, like a promise or future.
#
# Calling `#value` will trigger calculation & return the "lazy" value.
#
# This is an itty-bitty promise-like object, with key differences:
# - It has only two states, not-resolved and resolved
# - It has no error-catching functionality
#
# @api private
class GraphQL::Execution::Lazy
  # Create a {Lazy} which will get its inner value by calling the block
  #
  # @api private
  # @param path [Array<String, Integer>]
  # @param field [GraphQL::Schema::Field]
  # @param get_value_func [Proc] a block to get the inner value (later)
  # @return [Lazy] a new instance of Lazy
  def initialize(path: T.unsafe(nil), field: T.unsafe(nil), &get_value_func); end

  # @api private
  def field; end

  # @api private
  def path; end

  # @api private
  # @return [Lazy] A {Lazy} whose value depends on another {Lazy}, plus any transformations in `block`
  def then; end

  # @api private
  # @return [Object] The wrapped value, calling the lazy block if necessary
  def value; end

  class << self
    # @api private
    # @param lazies [Array<Object>] Maybe-lazy objects
    # @return [Lazy] A lazy which will sync all of `lazies`
    def all(lazies); end

    # Traverse `val`, lazily resolving any values along the way
    #
    # @api private
    # @param val [Object] A data structure containing mixed plain values and `Lazy` instances
    # @return void
    def resolve(val); end
  end
end

# {GraphQL::Schema} uses this to match returned values to lazy resolution methods.
# Methods may be registered for classes, they apply to its subclasses also.
# The result of this lookup is cached for future resolutions.
# Instances of this class are thread-safe.
#
# @api private
# @see {Schema#lazy?} looks up values from this map
class GraphQL::Execution::Lazy::LazyMethodMap
  # @api private
  # @return [LazyMethodMap] a new instance of LazyMethodMap
  def initialize(use_concurrent: T.unsafe(nil)); end

  # @api private
  def each; end

  # @api private
  # @param value [Object] an object which may have a `lazy_value_method` registered for its class or superclasses
  # @return [Symbol, nil] The `lazy_value_method` for this object, or nil
  def get(value); end

  # @api private
  # @param lazy_class [Class] A class which represents a lazy value (subclasses may also be used)
  # @param lazy_value_method [Symbol] The method to call on this class to get its value
  def set(lazy_class, lazy_value_method); end

  protected

  # @api private
  def storage; end

  private

  # @api private
  def find_superclass_method(value_class); end

  # @api private
  def initialize_copy(other); end
end

# Mock the Concurrent::Map API
#
# @api private
class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  extend ::Forwardable

  # @api private
  # @return [ConcurrentishMap] a new instance of ConcurrentishMap
  def initialize; end

  # @api private
  def []=(key, value); end

  # @api private
  def compute_if_absent(key); end

  def each_pair(*args, **_arg1, &block); end
  def size(*args, **_arg1, &block); end

  protected

  # @api private
  def copy_storage; end

  private

  # @api private
  def initialize_copy(other); end
end

# This can be used for fields which _had no_ lazy results
#
# @api private
GraphQL::Execution::Lazy::NullResult = T.let(T.unsafe(nil), GraphQL::Execution::Lazy)

# Helpers for dealing with data structures containing {Lazy} instances
#
# @api private
module GraphQL::Execution::Lazy::Resolve
  class << self
    # Traverse `val`, triggering resolution for each {Lazy}.
    # These {Lazy}s are expected to mutate their owner data structures
    # during resolution! (They're created with the `.then` calls in `resolve_in_place`).
    #
    # @api private
    # @return [void]
    def deep_sync(val); end

    # If `value` is a collection,
    # add any {Lazy} instances in the collection
    # to `acc`
    #
    # @api private
    # @return [void]
    def each_lazy(acc, value); end

    # @api private
    def resolve(value); end

    # @api private
    def resolve_in_place(value); end
  end
end

# This object can be passed like an array, but it doesn't allocate an
# array until it's used.
#
# There's one crucial difference: you have to _capture_ the result
# of `#<<`. (This _works_ with arrays but isn't required, since it has a side-effect.)
#
# @api private
module GraphQL::Execution::Lazy::Resolve::NullAccumulator
  class << self
    # @api private
    def <<(item); end

    # @api private
    # @return [Boolean]
    def empty?; end
  end
end

# Lookahead creates a uniform interface to inspect the forthcoming selections.
#
# It assumes that the AST it's working with is valid. (So, it's safe to use
# during execution, but if you're using it directly, be sure to validate first.)
#
# A field may get access to its lookahead by adding `extras: [:lookahead]`
# to its configuration.
#
# @example looking ahead in a field
#   field :articles, [Types::Article], null: false,
#   extras: [:lookahead]
#
#   # For example, imagine a faster database call
#   # may be issued when only some fields are requested.
#   #
#   # Imagine that _full_ fetch must be made to satisfy `fullContent`,
#   # we can look ahead to see if we need that field. If we do,
#   # we make the expensive database call instead of the cheap one.
#   def articles(lookahead:)
#   if lookahead.selects?(:full_content)
#   fetch_full_articles(object)
#   else
#   fetch_preview_articles(object)
#   end
#   end
class GraphQL::Execution::Lookahead
  # @param query [GraphQL::Query]
  # @param ast_nodes [Array<GraphQL::Language::Nodes::Field>, Array<GraphQL::Language::Nodes::OperationDefinition>]
  # @param field [GraphQL::Schema::Field] if `ast_nodes` are fields, this is the field definition matching those nodes
  # @param root_type [Class] if `ast_nodes` are operation definition, this is the root type for that operation
  # @return [Lookahead] a new instance of Lookahead
  def initialize(query:, ast_nodes:, field: T.unsafe(nil), root_type: T.unsafe(nil), owner_type: T.unsafe(nil)); end

  # @return [Hash<Symbol, Object>]
  def arguments; end

  # @return [Array<GraphQL::Language::Nodes::Field>]
  def ast_nodes; end

  # @return [GraphQL::Schema::Field]
  def field; end

  def inspect; end

  # The method name of the field.
  # It returns the method_sym of the Lookahead's field.
  #
  # @example getting the name of a selection
  #   def articles(lookahead:)
  #   article.selection(:full_content).name # => :full_content
  #   # ...
  #   end
  # @return [Symbol]
  def name; end

  # @return [GraphQL::Schema::Object, GraphQL::Schema::Union, GraphQL::Schema::Interface]
  def owner_type; end

  # @return [Boolean] True if this lookahead represents a field that was requested
  def selected?; end

  # Like {#selects?}, but can be used for chaining.
  # It returns a null object (check with {#selected?})
  #
  # @return [GraphQL::Execution::Lookahead]
  def selection(field_name, selected_type: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # Like {#selection}, but for all nodes.
  # It returns a list of Lookaheads for all Selections
  #
  # If `arguments:` is provided, each provided key/value will be matched
  # against the arguments in each selection. This method will filter the selections
  # if any of the given `arguments:` do not match the given selection.
  #
  # @example getting the name of a selection
  #   def articles(lookahead:)
  #   next_lookaheads = lookahead.selections # => [#<GraphQL::Execution::Lookahead ...>, ...]
  #   next_lookaheads.map(&:name) #=> [:full_content, :title]
  #   end
  # @param arguments [Hash] Arguments which must match in the selection
  # @return [Array<GraphQL::Execution::Lookahead>]
  def selections(arguments: T.unsafe(nil)); end

  # True if this node has a selection on `field_name`.
  # If `field_name` is a String, it is treated as a GraphQL-style (camelized)
  # field name and used verbatim. If `field_name` is a Symbol, it is
  # treated as a Ruby-style (underscored) name and camelized before comparing.
  #
  # If `arguments:` is provided, each provided key/value will be matched
  # against the arguments in the next selection. This method will return false
  # if any of the given `arguments:` are not present and matching in the next selection.
  # (But, the next selection may contain _more_ than the given arguments.)
  #
  # @param field_name [String, Symbol]
  # @param arguments [Hash] Arguments which must match in the selection
  # @return [Boolean]
  def selects?(field_name, arguments: T.unsafe(nil)); end

  private

  # @return [Boolean]
  def arguments_match?(arguments, field_defn, field_node); end

  # If a selection on `node` matches `field_name` (which is backed by `field_defn`)
  # and matches the `arguments:` constraints, then add that node to `matches`
  def find_selected_nodes(node, field_name, field_defn, arguments:, matches:); end

  def find_selections(subselections_by_type, selections_on_type, selected_type, ast_selections, arguments); end

  # Wrap get_field and ensure that it returns a GraphQL::Schema::Field.
  # Remove this when legacy execution is removed.
  def get_class_based_field(type, name); end

  def normalize_keyword(keyword); end

  # If it's a symbol, stringify and camelize it
  def normalize_name(name); end

  # @return [Boolean]
  def skipped_by_directive?(ast_selection); end
end

# A singleton, so that misses don't come with overhead.
GraphQL::Execution::Lookahead::NULL_LOOKAHEAD = T.let(T.unsafe(nil), GraphQL::Execution::Lookahead::NullLookahead)

# This is returned for {Lookahead#selection} when a non-existent field is passed
class GraphQL::Execution::Lookahead::NullLookahead < ::GraphQL::Execution::Lookahead
  # No inputs required here.
  #
  # @return [NullLookahead] a new instance of NullLookahead
  def initialize; end

  def inspect; end

  # @return [Boolean]
  def selected?; end

  def selection(*_arg0); end
  def selections(*_arg0); end

  # @return [Boolean]
  def selects?(*_arg0); end
end

# Execute multiple queries under the same multiplex "umbrella".
# They can share a batching context and reduce redundant database hits.
#
# The flow is:
#
# - Multiplex instrumentation setup
# - Query instrumentation setup
# - Analyze the multiplex + each query
# - Begin each query
# - Resolve lazy values, breadth-first across all queries
# - Finish each query (eg, get errors)
# - Query instrumentation teardown
# - Multiplex instrumentation teardown
#
# If one query raises an application error, all queries will be in undefined states.
#
# Validation errors and {GraphQL::ExecutionError}s are handled in isolation:
# one of these errors in one query will not affect the other queries.
#
# @api private
# @see {Schema#multiplex} for public API
class GraphQL::Execution::Multiplex
  include ::GraphQL::Tracing::Traceable

  # @api private
  # @return [Multiplex] a new instance of Multiplex
  def initialize(schema:, queries:, context:, max_complexity:); end

  # @api private
  def context; end

  # @api private
  def dataloader; end

  # @api private
  def max_complexity; end

  # @api private
  def queries; end

  # @api private
  def schema; end

  class << self
    # @api private
    # @param query [GraphQL::Query]
    def begin_query(results, idx, query, multiplex); end

    # @api private
    def run_all(schema, query_options, **kwargs); end

    # @api private
    # @param schema [GraphQL::Schema]
    # @param queries [Array<GraphQL::Query>]
    # @param context [Hash]
    # @param max_complexity [Integer, nil]
    # @return [Array<Hash>] One result per query
    def run_queries(schema, queries, context: T.unsafe(nil), max_complexity: T.unsafe(nil)); end

    private

    # @api private
    # @param data_result [Hash] The result for the "data" key, if any
    # @param query [GraphQL::Query] The query which was run
    # @return [Hash] final result of this query, including all values and errors
    def finish_query(data_result, query, multiplex); end

    # Apply multiplex & query instrumentation to `queries`.
    #
    # It yields when the queries should be executed, then runs teardown.
    #
    # @api private
    def instrument_and_analyze(multiplex); end

    # @api private
    def run_as_multiplex(multiplex); end

    # use the old `query_execution_strategy` etc to run this query
    #
    # @api private
    def run_one_legacy(schema, query); end

    # @api private
    # @return [Boolean] True if the schema is only using one strategy, and it's one that supports multiplexing.
    def supports_multiplexing?(schema); end
  end
end

# Used internally to signal that the query shouldn't be executed
#
# @api private
GraphQL::Execution::Multiplex::NO_OPERATION = T.let(T.unsafe(nil), Hash)

# @api private
module GraphQL::Execution::Typecast
  class << self
    # @api private
    # @return [Boolean]
    def subtype?(parent_type, child_type); end
  end
end

# If a field's resolve function returns a {ExecutionError},
# the error will be inserted into the response's `"errors"` key
# and the field will resolve to `nil`.
class GraphQL::ExecutionError < ::GraphQL::Error
  # @return [ExecutionError] a new instance of ExecutionError
  def initialize(message, ast_node: T.unsafe(nil), options: T.unsafe(nil), extensions: T.unsafe(nil)); end

  # @return [GraphQL::Language::Nodes::Field] the field where the error occurred
  def ast_node; end

  # @return [GraphQL::Language::Nodes::Field] the field where the error occurred
  def ast_node=(_arg0); end

  # under the `extensions` key.
  #
  # @return [Hash] Optional custom data for error objects which will be added
  def extensions; end

  # under the `extensions` key.
  #
  # @return [Hash] Optional custom data for error objects which will be added
  def extensions=(_arg0); end

  # recommends that any custom entries in an error be under the
  # `extensions` key.
  #
  # @deprecated Use `extensions` instead of `options`. The GraphQL spec
  # @return [Hash] Optional data for error objects
  def options; end

  # recommends that any custom entries in an error be under the
  # `extensions` key.
  #
  # @deprecated Use `extensions` instead of `options`. The GraphQL spec
  # @return [Hash] Optional data for error objects
  def options=(_arg0); end

  # response which corresponds to this error.
  #
  # @return [String] an array describing the JSON-path into the execution
  def path; end

  # response which corresponds to this error.
  #
  # @return [String] an array describing the JSON-path into the execution
  def path=(_arg0); end

  # @return [Hash] An entry for the response's "errors" key
  def to_h; end
end

GraphQL::FLOAT_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# @api deprecated
class GraphQL::Field
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  # @api deprecated
  # @return [Field] a new instance of Field
  def initialize; end

  # @api deprecated
  # @return [Hash<String => GraphQL::Argument>] Map String argument names to their {GraphQL::Argument} implementations
  def arguments; end

  # @api deprecated
  # @return [Hash<String => GraphQL::Argument>] Map String argument names to their {GraphQL::Argument} implementations
  def arguments=(_arg0); end

  # @api deprecated
  def arguments_class; end

  # @api deprecated
  def arguments_class=(_arg0); end

  # @api deprecated
  def ast_node; end

  # @api deprecated
  def ast_node=(_arg0); end

  # @api deprecated
  # @return [Numeric, Proc] The complexity for this field (default: 1), as a constant or a proc like `->(query_ctx, args, child_complexity) { } # Numeric`
  def complexity; end

  # @api deprecated
  # @return [Numeric, Proc] The complexity for this field (default: 1), as a constant or a proc like `->(query_ctx, args, child_complexity) { } # Numeric`
  def complexity=(_arg0); end

  # @api deprecated
  def connection=(_arg0); end

  # @api deprecated
  # @return [Boolean]
  def connection?; end

  # @api deprecated
  # @return [nil, Integer]
  def connection_max_page_size; end

  # @api deprecated
  # @return [nil, Integer]
  def connection_max_page_size=(_arg0); end

  # @api deprecated
  # @return [String, nil] The client-facing reason why this field is deprecated (if present, the field is deprecated)
  def deprecation_reason; end

  # @api deprecated
  # @return [String, nil] The client-facing reason why this field is deprecated (if present, the field is deprecated)
  def deprecation_reason=(_arg0); end

  # @api deprecated
  # @return [String, nil] The client-facing description of this field
  def description; end

  # @api deprecated
  # @return [String, nil] The client-facing description of this field
  def description=(_arg0); end

  # @api private
  # @return [nil, Class]
  def edge_class; end

  # @api private
  # @return [nil, Class]
  def edge_class=(_arg0); end

  # @api deprecated
  # @return [Boolean]
  def edges?; end

  # @api deprecated
  # @return [Object, GraphQL::Function] The function used to derive this field
  def function; end

  # @api deprecated
  # @return [Object, GraphQL::Function] The function used to derive this field
  def function=(_arg0); end

  # @api deprecated
  def get_argument(argument_name); end

  # Future-compatible alias
  #
  # @api deprecated
  # @see {GraphQL::SchemaMember}
  def graphql_definition; end

  # @api deprecated
  # @return [String] The name of this field on its {GraphQL::ObjectType} (or {GraphQL::InterfaceType})
  def graphql_name; end

  # @api deprecated
  # @return [Object, nil] The key to access with `obj.[]` to resolve this field (overrides {#name} if present)
  def hash_key; end

  # @api deprecated
  # @param new_hash_key [Symbol] A key to access with `#[key]` to resolve this field. Overrides the existing resolve proc.
  def hash_key=(new_hash_key); end

  # @api deprecated
  def introspection=(_arg0); end

  # @api deprecated
  # @return [Boolean] Is this field a predefined introspection field?
  def introspection?; end

  # If {#resolve} returned an object which should be handled lazily,
  # this method will be called later to force the object to return its value.
  #
  # @api deprecated
  # @param obj [Object] The {#resolve}-provided object, registered with {Schema#lazy_resolve}
  # @param args [GraphQL::Query::Arguments] Arguments to this field
  # @param ctx [GraphQL::Query::Context] Context for this field
  # @return [Object] The result of calling the registered method on `obj`
  def lazy_resolve(obj, args, ctx); end

  # Assign a new resolve proc to this field. Used for {#lazy_resolve}
  #
  # @api deprecated
  def lazy_resolve=(new_lazy_resolve_proc); end

  # @api deprecated
  # @return [<#call(obj, args, ctx)>] A proc-like object which can be called trigger a lazy resolution
  def lazy_resolve_proc; end

  # @api deprecated
  # @return [GraphQL::Relay::Mutation, nil] The mutation this field was derived from, if it was derived from a mutation
  def mutation; end

  # @api deprecated
  # @return [GraphQL::Relay::Mutation, nil] The mutation this field was derived from, if it was derived from a mutation
  def mutation=(_arg0); end

  # @api deprecated
  # @return [String] The name of this field on its {GraphQL::ObjectType} (or {GraphQL::InterfaceType})
  def name; end

  # @api deprecated
  def name=(new_name); end

  # Prepare a lazy value for this field. It may be `then`-ed and resolved later.
  #
  # @api deprecated
  # @return [GraphQL::Execution::Lazy] A lazy wrapper around `obj` and its registered method name
  def prepare_lazy(obj, args, ctx); end

  # @api deprecated
  # @return [Symbol, nil] The method to call on `obj` to return this field (overrides {#name} if present)
  def property; end

  # @api deprecated
  # @param new_property [Symbol] A method to call to resolve this field. Overrides the existing resolve proc.
  def property=(new_property); end

  # @api deprecated
  # @return [Boolean] True if this is the Relay find-by-id field
  def relay_node_field; end

  # @api deprecated
  # @return [Boolean] True if this is the Relay find-by-id field
  def relay_node_field=(_arg0); end

  # @api deprecated
  # @return [Boolean] True if this is the Relay find-by-ids field
  def relay_nodes_field; end

  # @api deprecated
  # @return [Boolean] True if this is the Relay find-by-ids field
  def relay_nodes_field=(_arg0); end

  # Get a value for this field
  #
  # @api deprecated
  # @example resolving a field value
  #   field.resolve(obj, args, ctx)
  # @param object [Object] The object this field belongs to
  # @param arguments [Hash] Arguments declared in the query
  # @param context [GraphQL::Query::Context]
  def resolve(object, arguments, context); end

  # Provide a new callable for this field's resolve function. If `nil`,
  # a new resolve proc will be build based on its {#name}, {#property} or {#hash_key}.
  #
  # @api deprecated
  # @param new_resolve_proc [<#call(obj, args, ctx)>, nil]
  def resolve=(new_resolve_proc); end

  # @api deprecated
  # @return [<#call(obj, args, ctx)>] A proc-like object which can be called to return the field's value
  def resolve_proc; end

  # @api deprecated
  # @return [nil, String] Prefix for subscription names from this field
  def subscription_scope; end

  # @api deprecated
  # @return [nil, String] Prefix for subscription names from this field
  def subscription_scope=(_arg0); end

  # @api deprecated
  def to_s; end

  # @api deprecated
  # @return [Boolean] True if this field should be traced. By default, fields are only traced if they are not a ScalarType or EnumType.
  def trace; end

  # @api deprecated
  # @return [Boolean] True if this field should be traced. By default, fields are only traced if they are not a ScalarType or EnumType.
  def trace=(_arg0); end

  # Get the return type for this field.
  #
  # @api deprecated
  def type; end

  # @api deprecated
  def type=(new_return_type); end

  # @api deprecated
  def type_class; end

  private

  # @api deprecated
  def build_default_resolver; end

  # @api deprecated
  def initialize_copy(other); end
end

# @api deprecated
module GraphQL::Field::DefaultLazyResolve
  class << self
    # @api deprecated
    def call(obj, args, ctx); end
  end
end

# Create resolve procs ahead of time based on a {GraphQL::Field}'s `name`, `property`, and `hash_key` configuration.
module GraphQL::Field::Resolve
  private

  # @param field [GraphQL::Field] A field that needs a resolve proc
  # @return [Proc] A resolver for this field, based on its config
  def create_proc(field); end

  class << self
    # @param field [GraphQL::Field] A field that needs a resolve proc
    # @return [Proc] A resolver for this field, based on its config
    def create_proc(field); end
  end
end

# These only require `obj` as input
class GraphQL::Field::Resolve::BuiltInResolve; end

# Resolve the field by looking up `@hash_key` with `#[]`
class GraphQL::Field::Resolve::HashKeyResolve < ::GraphQL::Field::Resolve::BuiltInResolve
  # @return [HashKeyResolve] a new instance of HashKeyResolve
  def initialize(hash_key); end

  def call(obj, args, ctx); end
end

# Resolve the field by `public_send`ing `@method_name`
class GraphQL::Field::Resolve::MethodResolve < ::GraphQL::Field::Resolve::BuiltInResolve
  # @return [MethodResolve] a new instance of MethodResolve
  def initialize(field); end

  def call(obj, args, ctx); end
end

# Call the field's name at query-time since
# it might have changed
class GraphQL::Field::Resolve::NameResolve < ::GraphQL::Field::Resolve::BuiltInResolve
  # @return [NameResolve] a new instance of NameResolve
  def initialize(field); end

  def call(obj, args, ctx); end
end

# @api private
class GraphQL::Filter
  # @api private
  # @return [Filter] a new instance of Filter
  def initialize(only: T.unsafe(nil), except: T.unsafe(nil)); end

  # Returns true if `member, ctx` passes this filter
  #
  # @api private
  def call(member, ctx); end

  # @api private
  def merge(only: T.unsafe(nil), except: T.unsafe(nil)); end
end

# @api private
class GraphQL::Filter::MergedExcept < ::GraphQL::Filter::MergedOnly
  # @api private
  def call(member, ctx); end
end

# @api private
class GraphQL::Filter::MergedOnly
  # @api private
  # @return [MergedOnly] a new instance of MergedOnly
  def initialize(first, second); end

  # @api private
  def call(member, ctx); end

  class << self
    # @api private
    def build(onlies); end
  end
end

# @api deprecated
class GraphQL::Function
  # @api deprecated
  # @return [Hash<String => GraphQL::Argument>] Arguments, keyed by name
  def arguments; end

  # @api deprecated
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [Object] This function's resolver
  def call(obj, args, ctx); end

  # @api deprecated
  # @return [Integer, Proc]
  def complexity; end

  # @api deprecated
  # @return [String, nil]
  def deprecation_reason; end

  # @api deprecated
  # @return [String, nil]
  def description; end

  # @api deprecated
  # @return [GraphQL::BaseType] Return type
  def type; end

  class << self
    # Define an argument for this function & its subclasses
    #
    # @api deprecated
    # @return [void]
    # @see {GraphQL::Field} same arguments as the `argument` definition helper
    def argument(*args, **kwargs, &block); end

    # @api deprecated
    # @return [Hash<String => GraphQL::Argument>] Arguments for this function class, including inherited arguments
    def arguments; end

    # @api deprecated
    def build_field(function); end

    # Get or set this class's complexity
    def complexity(new_value = T.unsafe(nil)); end

    # Get or set this class's deprecation_reason
    def deprecation_reason(new_value = T.unsafe(nil)); end

    # Get or set this class's description
    def description(new_value = T.unsafe(nil)); end

    # @api deprecated
    # @private
    def inherited(subclass); end

    # Get or set the return type for this function class & descendants
    #
    # @api deprecated
    # @return [GraphQL::BaseType]
    def type(premade_type = T.unsafe(nil), &block); end

    # Provides shorthand access to GraphQL's built-in types
    #
    # @api deprecated
    def types; end

    private

    # Arguments defined on this class (not superclasses)
    #
    # @api deprecated
    def own_arguments; end

    # Does this function inherit from another function?
    #
    # @api deprecated
    # @return [Boolean]
    def parent_function?; end
  end
end

GraphQL::ID_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)
GraphQL::INT_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# @api deprecated
class GraphQL::InputObjectType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  # @api deprecated
  # @return [InputObjectType] a new instance of InputObjectType
  def initialize; end

  # @return [Hash<String => GraphQL::Argument>] Map String argument names to their {GraphQL::Argument} implementations
  def arguments; end

  # @return [Hash<String => GraphQL::Argument>] Map String argument names to their {GraphQL::Argument} implementations
  def arguments=(_arg0); end

  # @api deprecated
  def arguments_class; end

  # @api deprecated
  def arguments_class=(_arg0); end

  # @api deprecated
  def coerce_result(value, ctx = T.unsafe(nil)); end

  # @api deprecated
  def get_argument(argument_name); end

  # @api deprecated
  def input_fields; end

  # @api deprecated
  def kind; end

  # @return [GraphQL::Relay::Mutation, nil] The mutation this field was derived from, if it was derived from a mutation
  def mutation; end

  # @return [GraphQL::Relay::Mutation, nil] The mutation this field was derived from, if it was derived from a mutation
  def mutation=(_arg0); end

  private

  # @api deprecated
  def coerce_non_null_input(value, ctx); end

  # @api deprecated
  def initialize_copy(other); end

  # @api deprecated
  def validate_non_null_input(input, ctx); end
end

# @api private
GraphQL::InputObjectType::INVALID_OBJECT_MESSAGE = T.let(T.unsafe(nil), String)

# This error is raised when `Types::Int` is given an input value outside of 32-bit integer range.
#
# For really big integer values, consider `GraphQL::Types::BigInt`
#
# @see GraphQL::Types::Int which raises this error
class GraphQL::IntegerDecodingError < ::GraphQL::RuntimeTypeError
  # @return [IntegerDecodingError] a new instance of IntegerDecodingError
  def initialize(value); end

  # The value which couldn't be decoded
  def integer_value; end
end

# This error is raised when `Types::Int` is asked to return a value outside of 32-bit integer range.
#
# For values outside that range, consider:
#
# - `ID` for database primary keys or other identifiers
# - `GraphQL::Types::BigInt` for really big integer values
#
# @see GraphQL::Types::Int which raises this error
class GraphQL::IntegerEncodingError < ::GraphQL::RuntimeTypeError
  # @return [IntegerEncodingError] a new instance of IntegerEncodingError
  def initialize(value, context:); end

  # @return [GraphQL::Schema::Field] The field that returned a too-big integer
  def field; end

  # The value which couldn't be encoded
  def integer_value; end

  # @return [Array<String, Integer>] Where the field appeared in the GraphQL response
  def path; end
end

# @api deprecated
class GraphQL::InterfaceType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  # @api deprecated
  # @return [InterfaceType] a new instance of InterfaceType
  def initialize; end

  # These fields don't have instrumenation applied
  #
  # @api deprecated
  # @return [Array<GraphQL::Field>] All fields on this type
  # @see [Schema#get_fields] Get fields with instrumentation
  def all_fields; end

  # @api deprecated
  def fields; end

  # @api deprecated
  def fields=(_arg0); end

  # @api deprecated
  # @return [GraphQL::Field] The defined field for `field_name`
  def get_field(field_name); end

  # Get a possible type of this {InterfaceType} by type name
  #
  # @api deprecated
  # @param type_name [String]
  # @param ctx [GraphQL::Query::Context] The context for the current query
  # @return [GraphQL::ObjectType, nil] The type named `type_name` if it exists and implements this {InterfaceType}, (else `nil`)
  def get_possible_type(type_name, ctx); end

  # @api deprecated
  def kind; end

  # @api deprecated
  def orphan_types; end

  # @api deprecated
  def orphan_types=(_arg0); end

  # Check if a type is a possible type of this {InterfaceType}
  #
  # @api deprecated
  # @param type [String, GraphQL::BaseType] Name of the type or a type definition
  # @param ctx [GraphQL::Query::Context] The context for the current query
  # @return [Boolean] True if the `type` exists and is a member of this {InterfaceType}, (else `nil`)
  def possible_type?(type, ctx); end

  # @api deprecated
  def resolve_type(value, ctx); end

  # @api deprecated
  def resolve_type=(resolve_type_callable); end

  # @api deprecated
  def resolve_type_proc; end

  # @api deprecated
  def resolve_type_proc=(_arg0); end

  # @api deprecated
  def type_membership_class; end

  # @api deprecated
  def type_membership_class=(_arg0); end

  private

  # @api deprecated
  def initialize_copy(other); end
end

module GraphQL::InternalRepresentation; end

class GraphQL::InternalRepresentation::Document
  # @return [Document] a new instance of Document
  def initialize; end

  def [](key); end
  def each(&block); end

  # @return [Hash<String, Node>] Fragment definition Nodes of this query
  def fragment_definitions; end

  # @return [Hash<String, Node>] Operation Nodes of this query
  def operation_definitions; end
end

class GraphQL::InternalRepresentation::Node
  # @return [Node] a new instance of Node
  def initialize(name:, owner_type:, query:, return_type:, parent:, ast_nodes: T.unsafe(nil), definitions: T.unsafe(nil)); end

  def ==(other); end
  def arguments; end
  def ast_node; end

  # @return [Array<Language::Nodes::AbstractNode>] AST nodes which are represented by this node
  def ast_nodes; end

  # Merge selections from `new_parent` into `self`.
  # Selections are merged in place, not copied.
  def deep_merge_node(new_parent, scope: T.unsafe(nil), merge_self: T.unsafe(nil)); end

  def definition; end
  def definition_name; end

  # @return [Array<GraphQL::Field>] Field definitions for this node (there should only be one!)
  def definitions; end

  def inspect; end

  # @return [String] the name this node has in the response
  def name; end

  # @return [GraphQL::ObjectType]
  def owner_type; end

  # @return [InternalRepresentation::Node, nil]
  def parent; end

  # @return [GraphQL::Query]
  def query; end

  # @return [GraphQL::BaseType] The expected wrapped type this node must return.
  def return_type; end

  # These children correspond closely to scopes in the AST.
  # Keys _may_ be abstract types. They're assumed to be read-only after rewrite is finished
  # because {#typed_children} is derived from them.
  #
  # Using {#scoped_children} during the rewrite step reduces the overhead of reifying
  # abstract types because they're only reified _after_ the rewrite.
  #
  # @return [Hash<GraphQL::BaseType, Hash<String => Node>>]
  def scoped_children; end

  def subscription_topic; end

  # Each key is a {GraphQL::ObjectType} which this selection _may_ be made on.
  # The values for that key are selections which apply to that type.
  #
  # This value is derived from {#scoped_children} after the rewrite is finished.
  #
  # @return [Hash<GraphQL::ObjectType, Hash<String => Node>>]
  def typed_children; end

  protected

  # Sets the attribute owner_type
  #
  # @param value the value to set the attribute owner_type to.
  def owner_type=(_arg0); end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  def parent=(_arg0); end

  private

  # Get applicable children from {#scoped_children}
  #
  # @param obj_type [GraphQL::ObjectType]
  # @return [Hash<String => Node>]
  def get_typed_children(obj_type); end

  def initialize_copy(other_node); end
end

# @api private
GraphQL::InternalRepresentation::Node::DEFAULT_TYPED_CHILDREN = T.let(T.unsafe(nil), Proc)

# A specialized, reusable object for leaf nodes.
GraphQL::InternalRepresentation::Node::NO_TYPED_CHILDREN = T.let(T.unsafe(nil), Hash)

module GraphQL::InternalRepresentation::Print
  private

  def print(schema, query_string); end
  def print_node(node, indent: T.unsafe(nil)); end

  class << self
    def print(schema, query_string); end
    def print_node(node, indent: T.unsafe(nil)); end
  end
end

# While visiting an AST, build a normalized, flattened tree of {InternalRepresentation::Node}s.
#
# No unions or interfaces are present in this tree, only object types.
#
# Selections from the AST are attached to the object types they apply to.
#
# Inline fragments and fragment spreads are preserved in {InternalRepresentation::Node#ast_spreads},
# where they can be used to check for the presence of directives. This might not be sufficient
# for future directives, since the selections' grouping is lost.
#
# The rewritten query tree serves as the basis for the `FieldsWillMerge` validation.
module GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language

  def initialize(*_arg0); end

  def on_field(ast_node, ast_parent); end
  def on_fragment_definition(ast_node, parent); end
  def on_fragment_spread(ast_node, ast_parent); end
  def on_inline_fragment(node, parent); end
  def on_operation_definition(ast_node, parent); end

  # @return [Hash<String, Node>] Roots of this query
  def operations; end

  def push_root_node(ast_node, definitions); end

  # @return InternalRepresentation::Document
  def rewrite_document; end

  # @return [Boolean]
  def skip?(ast_node); end
end

GraphQL::InternalRepresentation::Rewrite::NO_DIRECTIVES = T.let(T.unsafe(nil), Array)

# At a point in the AST, selections may apply to one or more types.
# {Scope} represents those types which selections may apply to.
#
# Scopes can be defined by:
#
# - A single concrete or abstract type
# - An array of types
# - `nil`
#
# The AST may be scoped to an array of types when two abstractly-typed
# fragments occur in inside one another.
class GraphQL::InternalRepresentation::Scope
  # @param query [GraphQL::Query]
  # @param type_defn [GraphQL::BaseType, Array<GraphQL::BaseType>, nil]
  # @return [Scope] a new instance of Scope
  def initialize(query, type_defn); end

  # Call the block for each type in `self`.
  # This uses the simplest possible expression of `self`,
  # so if this scope is defined by an abstract type, it gets yielded.
  def each(&block); end

  # From a starting point of `self`, create a new scope by condition `other_type_defn`.
  #
  # @param other_type_defn [GraphQL::BaseType, nil]
  # @return [Scope]
  def enter(other_type_defn); end

  private

  def concrete_types; end
end

GraphQL::InternalRepresentation::Scope::NO_TYPES = T.let(T.unsafe(nil), Array)

# Traverse a re-written query tree, calling handlers for each node
module GraphQL::InternalRepresentation::Visit
  private

  # Traverse a node in a rewritten query tree,
  # visiting the node itself and each of its typed children.
  def each_node(node, &block); end

  def visit_each_node(operations, handlers); end

  class << self
    # Traverse a node in a rewritten query tree,
    # visiting the node itself and each of its typed children.
    #
    # @yield [node]
    def each_node(node, &block); end

    def visit_each_node(operations, handlers); end
  end
end

module GraphQL::Introspection
  class << self
    def query(include_deprecated_args: T.unsafe(nil), include_schema_description: T.unsafe(nil), include_is_repeatable: T.unsafe(nil), include_specified_by_url: T.unsafe(nil)); end
  end
end

class GraphQL::Introspection::BaseObject < ::GraphQL::Schema::Object
  class << self
    def field(*args, **kwargs, &block); end
  end
end

class GraphQL::Introspection::BaseObject::InvalidNullError < ::GraphQL::InvalidNullError; end
class GraphQL::Introspection::DirectiveLocationEnum < ::GraphQL::Schema::Enum; end
class GraphQL::Introspection::DirectiveLocationEnum::UnresolvedValueError < ::GraphQL::Schema::Enum::UnresolvedValueError; end

class GraphQL::Introspection::DirectiveType < ::GraphQL::Introspection::BaseObject
  def args(include_deprecated:); end
end

class GraphQL::Introspection::DirectiveType::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::DynamicFields < ::GraphQL::Introspection::BaseObject
  # `irep_node:` will be nil for the interpreter, since there is no such thing
  def __typename(irep_node: T.unsafe(nil)); end
end

class GraphQL::Introspection::DynamicFields::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::EntryPoints < ::GraphQL::Introspection::BaseObject
  def __schema; end
  def __type(name:); end
end

class GraphQL::Introspection::EntryPoints::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::EnumValueType < ::GraphQL::Introspection::BaseObject
  def is_deprecated; end
  def name; end
end

class GraphQL::Introspection::EnumValueType::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::FieldType < ::GraphQL::Introspection::BaseObject
  def args(include_deprecated:); end
  def is_deprecated; end
end

class GraphQL::Introspection::FieldType::InvalidNullError < ::GraphQL::InvalidNullError; end

# This query is used by graphql-client so don't add the includeDeprecated
# argument for inputFields since the server may not support it. Two stage
# introspection queries will be required to handle this in clients.
GraphQL::Introspection::INTROSPECTION_QUERY = T.let(T.unsafe(nil), String)

class GraphQL::Introspection::InputValueType < ::GraphQL::Introspection::BaseObject
  def default_value; end
  def is_deprecated; end

  private

  # Recursively serialize, taking care not to add quotes to enum values
  def serialize_default_value(value, type); end
end

class GraphQL::Introspection::InputValueType::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::Introspection::SchemaType < ::GraphQL::Introspection::BaseObject
  def directives; end
  def mutation_type; end
  def query_type; end
  def schema_description; end
  def subscription_type; end
  def types; end

  private

  def permitted_root_type(op_type); end
end

class GraphQL::Introspection::SchemaType::InvalidNullError < ::GraphQL::InvalidNullError; end
class GraphQL::Introspection::TypeKindEnum < ::GraphQL::Schema::Enum; end
class GraphQL::Introspection::TypeKindEnum::UnresolvedValueError < ::GraphQL::Schema::Enum::UnresolvedValueError; end

class GraphQL::Introspection::TypeType < ::GraphQL::Introspection::BaseObject
  def enum_values(include_deprecated:); end
  def fields(include_deprecated:); end
  def input_fields(include_deprecated:); end
  def interfaces; end
  def kind; end
  def of_type; end
  def possible_types; end
  def specified_by_url; end
end

class GraphQL::Introspection::TypeType::InvalidNullError < ::GraphQL::InvalidNullError; end

class GraphQL::InvalidNameError < ::GraphQL::ExecutionError
  # @return [InvalidNameError] a new instance of InvalidNameError
  def initialize(name, valid_regex); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute valid_regex.
  def valid_regex; end
end

# Raised automatically when a field's resolve function returns `nil`
# for a non-null field.
class GraphQL::InvalidNullError < ::GraphQL::RuntimeTypeError
  # @return [InvalidNullError] a new instance of InvalidNullError
  def initialize(parent_type, field, value); end

  # @return [GraphQL::Field] The field which failed to return a value
  def field; end

  # @deprecated always false
  # @return [Boolean]
  def parent_error?; end

  # @return [GraphQL::BaseType] The owner of {#field}
  def parent_type; end

  # @return [Hash] An entry for the response's "errors" key
  def to_h; end

  # @return [nil, GraphQL::ExecutionError] The invalid value for this field
  def value; end

  class << self
    def inspect; end

    # Returns the value of attribute parent_class.
    def parent_class; end

    # Sets the attribute parent_class
    #
    # @param value the value to set the attribute parent_class to.
    def parent_class=(_arg0); end

    def subclass_for(parent_class); end
  end
end

# This error is raised when GraphQL-Ruby encounters a situation
# that it *thought* would never happen. Please report this bug!
class GraphQL::InvariantError < ::GraphQL::Error
  # @return [InvariantError] a new instance of InvariantError
  def initialize(message); end
end

module GraphQL::Language
  class << self
    # @api private
    def serialize(value); end
  end
end

module GraphQL::Language::BlockString
  class << self
    def break_line(line, length); end
    def print(str, indent: T.unsafe(nil)); end

    # Remove leading and trailing whitespace from a block string.
    # See "Block Strings" in https://github.com/facebook/graphql/blob/master/spec/Section%202%20--%20Language.md
    def trim_whitespace(str); end
  end
end

class GraphQL::Language::Cache
  # @return [Cache] a new instance of Cache
  def initialize(path); end

  def fetch(filename); end
end

GraphQL::Language::Cache::DIGEST = T.let(T.unsafe(nil), Digest::SHA256)

module GraphQL::Language::DefinitionSlice
  extend ::GraphQL::Language::DefinitionSlice

  def slice(document, name); end
end

class GraphQL::Language::DefinitionSlice::DependencyVisitor < ::GraphQL::Language::Visitor
  # @return [DependencyVisitor] a new instance of DependencyVisitor
  def initialize(doc, definitions, names); end

  def on_fragment_spread(node, parent); end

  class << self
    def find_definition_dependencies(definitions, name, names); end
  end
end

# {GraphQL::Language::DocumentFromSchemaDefinition} is used to convert a {GraphQL::Schema} object
# To a {GraphQL::Language::Document} AST node.
#
# @api private
# @param context [Hash]
# @param only [<#call(member, ctx)>]
# @param except [<#call(member, ctx)>]
# @param include_introspection_types [Boolean] Whether or not to include introspection types in the AST
# @param include_built_in_scalars [Boolean] Whether or not to include built in scalars in the AST
# @param include_built_in_directives [Boolean] Whether or not to include built in directives in the AST
class GraphQL::Language::DocumentFromSchemaDefinition
  # @api private
  # @return [DocumentFromSchemaDefinition] a new instance of DocumentFromSchemaDefinition
  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), include_introspection_types: T.unsafe(nil), include_built_in_directives: T.unsafe(nil), include_built_in_scalars: T.unsafe(nil), always_include_schema: T.unsafe(nil)); end

  # @api private
  def build_argument_node(argument); end

  # @api private
  def build_argument_nodes(arguments); end

  # @api private
  def build_default_value(default_value, type); end

  # @api private
  def build_definition_nodes; end

  # @api private
  def build_directive_location_node(location); end

  # @api private
  def build_directive_location_nodes(locations); end

  # @api private
  def build_directive_node(directive); end

  # @api private
  def build_directive_nodes(directives); end

  # @api private
  def build_enum_type_node(enum_type); end

  # @api private
  def build_enum_value_node(enum_value); end

  # @api private
  def build_field_node(field); end

  # @api private
  def build_field_nodes(fields); end

  # @api private
  def build_input_object_node(input_object); end

  # @api private
  def build_interface_type_node(interface_type); end

  # @api private
  def build_object_type_node(object_type); end

  # @api private
  def build_scalar_type_node(scalar_type); end

  # @api private
  def build_schema_node; end

  # @api private
  def build_type_definition_node(type); end

  # @api private
  def build_type_definition_nodes(types); end

  # @api private
  def build_type_name_node(type); end

  # @api private
  def build_union_type_node(union_type); end

  # @api private
  def document; end

  private

  # @api private
  def always_include_schema; end

  # @api private
  def ast_directives(member); end

  # @api private
  def definition_directives(member); end

  # @api private
  def directives(member); end

  # @api private
  def include_built_in_directives; end

  # @api private
  def include_built_in_scalars; end

  # @api private
  def include_introspection_types; end

  # @api private
  # @return [Boolean]
  def include_schema_node?; end

  # @api private
  def schema; end

  # @api private
  # @return [Boolean]
  def schema_respects_root_name_conventions?(schema); end

  # @api private
  def warden; end
end

# Exposes {.generate}, which turns AST nodes back into query strings.
module GraphQL::Language::Generation
  extend ::GraphQL::Language::Generation

  # Turn an AST node back into a string.
  #
  # @example Turning a document into a query
  #   document = GraphQL.parse(query_string)
  #   GraphQL::Language::Generation.generate(document)
  #   # => "{ ... }"
  # @param node [GraphQL::Language::Nodes::AbstractNode] an AST node to recursively stringify
  # @param indent [String] Whitespace to add to each printed node
  # @param printer [GraphQL::Language::Printer] An optional custom printer for printing AST nodes. Defaults to GraphQL::Language::Printer
  # @return [String] Valid GraphQL for `node`
  def generate(node, indent: T.unsafe(nil), printer: T.unsafe(nil)); end
end

module GraphQL::Language::Lexer
  class << self
    def emit(token_name, ts, te, meta, token_value = T.unsafe(nil)); end
    def emit_string(ts, te, meta, block:); end

    # Returns the value of attribute graphql_lexer_en_main.
    def graphql_lexer_en_main; end

    # Sets the attribute graphql_lexer_en_main
    #
    # @param value the value to set the attribute graphql_lexer_en_main to.
    def graphql_lexer_en_main=(_arg0); end

    # Returns the value of attribute graphql_lexer_en_str.
    def graphql_lexer_en_str; end

    # Sets the attribute graphql_lexer_en_str
    #
    # @param value the value to set the attribute graphql_lexer_en_str to.
    def graphql_lexer_en_str=(_arg0); end

    # Returns the value of attribute graphql_lexer_error.
    def graphql_lexer_error; end

    # Sets the attribute graphql_lexer_error
    #
    # @param value the value to set the attribute graphql_lexer_error to.
    def graphql_lexer_error=(_arg0); end

    # Returns the value of attribute graphql_lexer_first_final.
    def graphql_lexer_first_final; end

    # Sets the attribute graphql_lexer_first_final
    #
    # @param value the value to set the attribute graphql_lexer_first_final to.
    def graphql_lexer_first_final=(_arg0); end

    # Returns the value of attribute graphql_lexer_start.
    def graphql_lexer_start; end

    # Sets the attribute graphql_lexer_start
    #
    # @param value the value to set the attribute graphql_lexer_start to.
    def graphql_lexer_start=(_arg0); end

    def record_comment(ts, te, meta); end

    # Replace any escaped unicode or whitespace with the _actual_ characters
    # To avoid allocating more strings, this modifies the string passed into it
    def replace_escaped_characters_in_place(raw_string); end

    def run_lexer(query_string); end
    def tokenize(query_string); end

    private

    # Returns the value of attribute _graphql_lexer_char_class.
    def _graphql_lexer_char_class; end

    # Sets the attribute _graphql_lexer_char_class
    #
    # @param value the value to set the attribute _graphql_lexer_char_class to.
    def _graphql_lexer_char_class=(_arg0); end

    # Returns the value of attribute _graphql_lexer_cond_actions.
    def _graphql_lexer_cond_actions; end

    # Sets the attribute _graphql_lexer_cond_actions
    #
    # @param value the value to set the attribute _graphql_lexer_cond_actions to.
    def _graphql_lexer_cond_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_cond_targs.
    def _graphql_lexer_cond_targs; end

    # Sets the attribute _graphql_lexer_cond_targs
    #
    # @param value the value to set the attribute _graphql_lexer_cond_targs to.
    def _graphql_lexer_cond_targs=(_arg0); end

    # Returns the value of attribute _graphql_lexer_eof_trans.
    def _graphql_lexer_eof_trans; end

    # Sets the attribute _graphql_lexer_eof_trans
    #
    # @param value the value to set the attribute _graphql_lexer_eof_trans to.
    def _graphql_lexer_eof_trans=(_arg0); end

    # Returns the value of attribute _graphql_lexer_from_state_actions.
    def _graphql_lexer_from_state_actions; end

    # Sets the attribute _graphql_lexer_from_state_actions
    #
    # @param value the value to set the attribute _graphql_lexer_from_state_actions to.
    def _graphql_lexer_from_state_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_index_defaults.
    def _graphql_lexer_index_defaults; end

    # Sets the attribute _graphql_lexer_index_defaults
    #
    # @param value the value to set the attribute _graphql_lexer_index_defaults to.
    def _graphql_lexer_index_defaults=(_arg0); end

    # Returns the value of attribute _graphql_lexer_index_offsets.
    def _graphql_lexer_index_offsets; end

    # Sets the attribute _graphql_lexer_index_offsets
    #
    # @param value the value to set the attribute _graphql_lexer_index_offsets to.
    def _graphql_lexer_index_offsets=(_arg0); end

    # Returns the value of attribute _graphql_lexer_indicies.
    def _graphql_lexer_indicies; end

    # Sets the attribute _graphql_lexer_indicies
    #
    # @param value the value to set the attribute _graphql_lexer_indicies to.
    def _graphql_lexer_indicies=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_offsets.
    def _graphql_lexer_nfa_offsets; end

    # Sets the attribute _graphql_lexer_nfa_offsets
    #
    # @param value the value to set the attribute _graphql_lexer_nfa_offsets to.
    def _graphql_lexer_nfa_offsets=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_pop_trans.
    def _graphql_lexer_nfa_pop_trans; end

    # Sets the attribute _graphql_lexer_nfa_pop_trans
    #
    # @param value the value to set the attribute _graphql_lexer_nfa_pop_trans to.
    def _graphql_lexer_nfa_pop_trans=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_push_actions.
    def _graphql_lexer_nfa_push_actions; end

    # Sets the attribute _graphql_lexer_nfa_push_actions
    #
    # @param value the value to set the attribute _graphql_lexer_nfa_push_actions to.
    def _graphql_lexer_nfa_push_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_targs.
    def _graphql_lexer_nfa_targs; end

    # Sets the attribute _graphql_lexer_nfa_targs
    #
    # @param value the value to set the attribute _graphql_lexer_nfa_targs to.
    def _graphql_lexer_nfa_targs=(_arg0); end

    # Returns the value of attribute _graphql_lexer_to_state_actions.
    def _graphql_lexer_to_state_actions; end

    # Sets the attribute _graphql_lexer_to_state_actions
    #
    # @param value the value to set the attribute _graphql_lexer_to_state_actions to.
    def _graphql_lexer_to_state_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_trans_cond_spaces.
    def _graphql_lexer_trans_cond_spaces; end

    # Sets the attribute _graphql_lexer_trans_cond_spaces
    #
    # @param value the value to set the attribute _graphql_lexer_trans_cond_spaces to.
    def _graphql_lexer_trans_cond_spaces=(_arg0); end

    # Returns the value of attribute _graphql_lexer_trans_keys.
    def _graphql_lexer_trans_keys; end

    # Sets the attribute _graphql_lexer_trans_keys
    #
    # @param value the value to set the attribute _graphql_lexer_trans_keys to.
    def _graphql_lexer_trans_keys=(_arg0); end
  end
end

GraphQL::Language::Lexer::ESCAPES = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::ESCAPES_REPLACE = T.let(T.unsafe(nil), Hash)
GraphQL::Language::Lexer::PACK_DIRECTIVE = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::UTF_8 = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::UTF_8_ENCODING = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::UTF_8_REPLACE = T.let(T.unsafe(nil), Proc)
GraphQL::Language::Lexer::VALID_STRING = T.let(T.unsafe(nil), Regexp)
module GraphQL::Language::Nodes; end

# {AbstractNode} is the base class for all nodes in a GraphQL AST.
#
# It provides some APIs for working with ASTs:
# - `children` returns all AST nodes attached to this one. Used for tree traversal.
# - `scalars` returns all scalar (Ruby) values attached to this one. Used for comparing nodes.
# - `to_query_string` turns an AST node into a GraphQL string
class GraphQL::Language::Nodes::AbstractNode
  # Initialize a node by extracting its position,
  # then calling the class's `initialize_node` method.
  #
  # @param options [Hash] Initial attributes for this node
  # @return [AbstractNode] a new instance of AbstractNode
  def initialize(options = T.unsafe(nil)); end

  # Value equality
  #
  # @return [Boolean] True if `self` is equivalent to `other`
  def ==(other); end

  # @return [Array<GraphQL::Language::Nodes::AbstractNode>] all nodes in the tree below this one
  def children; end

  def children_method_name; end

  # Returns the value of attribute col.
  def col; end

  # TODO DRY with `replace_child`
  def delete_child(previous_child); end

  # Returns the value of attribute filename.
  def filename; end

  # Returns the value of attribute line.
  def line; end

  # This creates a copy of `self`, with `new_options` applied.
  #
  # @param new_options [Hash]
  # @return [AbstractNode] a shallow copy of `self`
  def merge(new_options); end

  def position; end

  # Copy `self`, but modify the copy so that `previous_child` is replaced by `new_child`
  def replace_child(previous_child, new_child); end

  # @return [Array<Integer, Float, String, Boolean, Array>] Scalar values attached to this node
  def scalars; end

  def to_query_string(printer: T.unsafe(nil)); end

  protected

  def merge!(new_options); end

  private

  # This might be unnecessary, but its easiest to add it here.
  def initialize_copy(other); end

  class << self
    # Add a default `#visit_method` and `#children_method_name` using the class name
    def inherited(child_class); end

    private

    # Name accessors which return lists of nodes,
    # along with the kind of node they return, if possible.
    # - Add a reader for these children
    # - Add a persistent update method to add a child
    # - Generate a `#children` method
    def children_methods(children_of_type); end

    def generate_initialize_node; end

    # These methods return a plain Ruby value, not another node
    # - Add reader methods
    # - Add a `#scalars` method
    def scalar_methods(*method_names); end
  end
end

module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def initialize(options = T.unsafe(nil)); end

  # This AST node's {#line} returns the first line, which may be the description.
  #
  # @return [Integer] The first line of the definition (not the description)
  def definition_line; end
end

GraphQL::Language::Nodes::AbstractNode::NO_CHILDREN = T.let(T.unsafe(nil), Array)

# A key-value pair for a field's inputs
class GraphQL::Language::Nodes::Argument < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def initialize_node(name: T.unsafe(nil), value: T.unsafe(nil)); end

  # @return [String] the key for this argument
  def name; end

  def scalars; end

  # @return [String, Float, Integer, Boolean, Array, InputObject] The value passed for this key
  def value; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::Directive < ::GraphQL::Language::Nodes::AbstractNode
  def arguments; end
  def children; end
  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def merge_argument(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::DirectiveDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def arguments; end
  def children; end

  # Returns the value of attribute description.
  def description; end

  def initialize_node(name: T.unsafe(nil), repeatable: T.unsafe(nil), description: T.unsafe(nil), locations: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def locations; end
  def merge_argument(node_opts); end
  def merge_location(node_opts); end
  def name; end
  def repeatable; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::DirectiveLocation < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# This is the AST root for normal queries
#
# @example Deriving a document by parsing a string
#   document = GraphQL.parse(query_string)
# @example Creating a string from a document
#   document.to_query_string
#   # { ... }
# @example Creating a custom string from a document
#   class VariableScrubber < GraphQL::Language::Printer
#   def print_argument(arg)
#   "#{arg.name}: <HIDDEN>"
#   end
#   end
#
#   document.to_query_string(printer: VariableScrubber.new)
class GraphQL::Language::Nodes::Document < ::GraphQL::Language::Nodes::AbstractNode
  def children; end

  # @return [Array<OperationDefinition, FragmentDefinition>] top-level GraphQL units: operations or fragments
  def definitions; end

  def initialize_node(definitions: T.unsafe(nil)); end
  def slice_definition(name); end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An enum value. The string is available as {#name}.
class GraphQL::Language::Nodes::Enum < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_value(node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_value(node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumValueDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A single selection in a GraphQL query.
class GraphQL::Language::Nodes::Field < ::GraphQL::Language::Nodes::AbstractNode
  def alias; end
  def arguments; end
  def children; end
  def directives; end
  def initialize_node(attributes); end
  def merge_argument(node_opts); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def name; end
  def scalars; end

  # @return [Array<Nodes::Field>] Selections on this object (or empty array if this is a scalar field)
  def selections; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

GraphQL::Language::Nodes::Field::NONE = T.let(T.unsafe(nil), Array)

class GraphQL::Language::Nodes::FieldDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def arguments; end
  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end

  # this is so that `children_method_name` of `InputValueDefinition` works properly
  # with `#replace_child`
  def fields; end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def merge(new_options); end
  def merge_argument(node_opts); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A reusable fragment, defined at document-level.
class GraphQL::Language::Nodes::FragmentDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end

  # @return [String] the identifier for this fragment, which may be applied with `...#{name}`
  def name; end

  def scalars; end
  def selections; end

  # @return [String] the type condition for this fragment (name of type which it may apply to)
  def type; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Application of a named fragment in a selection
class GraphQL::Language::Nodes::FragmentSpread < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An unnamed fragment, defined directly in the query with `... {  }`
class GraphQL::Language::Nodes::InlineFragment < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(type: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def scalars; end
  def selections; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A collection of key-value inputs which may be a field argument
class GraphQL::Language::Nodes::InputObject < ::GraphQL::Language::Nodes::AbstractNode
  # @return [Array<Nodes::Argument>] A list of key-value pairs inside this input object
  def arguments; end

  def children; end
  def initialize_node(arguments: T.unsafe(nil)); end
  def merge_argument(node_opts); end

  # @return [Hash<String, Any>] Recursively turn this input object into a Ruby Hash
  def to_h(options = T.unsafe(nil)); end

  def visit_method; end

  private

  def serialize_value_for_hash(value); end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputValueDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end
  def default_value; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def merge_interface(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def merge_interface(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A list type definition, denoted with `[...]` (used for variable type definitions)
class GraphQL::Language::Nodes::ListType < ::GraphQL::Language::Nodes::WrapperType
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Base class for nodes whose only value is a name (no child nodes or other scalars)
class GraphQL::Language::Nodes::NameOnlyNode < ::GraphQL::Language::Nodes::AbstractNode
  def initialize_node(name: T.unsafe(nil)); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A non-null type definition, denoted with `...!` (used for variable type definitions)
class GraphQL::Language::Nodes::NonNullType < ::GraphQL::Language::Nodes::WrapperType
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A null value literal.
class GraphQL::Language::Nodes::NullValue < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ObjectTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A query, mutation or subscription.
# May be anonymous or named.
# May be explicitly typed (eg `mutation { ... }`) or implicitly a query (eg `{ ... }`).
class GraphQL::Language::Nodes::OperationDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def merge_variable(node_opts); end
  def name; end

  # @return [String, nil] The root type for this operation, or `nil` for implicit `"query"`
  def operation_type; end

  def scalars; end

  # @return [Array<Field>] Root-level fields on this operation
  def selections; end

  # @return [Array<VariableDefinition>] Variable $definitions for this operation
  def variables; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ScalarTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::SchemaDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end
  def directives; end
  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::SchemaExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A type name, used for variable definitions
class GraphQL::Language::Nodes::TypeName < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::UnionTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end

  # Returns the value of attribute types.
  def types; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::UnionTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end

  # Returns the value of attribute types.
  def types; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An operation-level query variable
class GraphQL::Language::Nodes::VariableDefinition < ::GraphQL::Language::Nodes::AbstractNode
  # @return [String, Integer, Float, Boolean, Array, NullValue] A Ruby value to use if no other value is provided
  def default_value; end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil)); end
  def name; end
  def scalars; end

  # @return [TypeName, NonNullType, ListType] The expected type of this value
  def type; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Usage of a variable in a query. Name does _not_ include `$`.
class GraphQL::Language::Nodes::VariableIdentifier < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Base class for non-null type names and list type names
class GraphQL::Language::Nodes::WrapperType < ::GraphQL::Language::Nodes::AbstractNode
  def initialize_node(of_type: T.unsafe(nil)); end
  def of_type; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Parser < ::Racc::Parser
  def initialize(query_string, filename:, tracer: T.unsafe(nil)); end

  def _reduce_10(val, _values, result); end
  def _reduce_100(val, _values, result); end
  def _reduce_102(val, _values, result); end
  def _reduce_103(val, _values, result); end
  def _reduce_104(val, _values, result); end
  def _reduce_105(val, _values, result); end
  def _reduce_106(val, _values, result); end
  def _reduce_107(val, _values, result); end
  def _reduce_108(val, _values, result); end
  def _reduce_109(val, _values, result); end
  def _reduce_11(val, _values, result); end
  def _reduce_114(val, _values, result); end
  def _reduce_116(val, _values, result); end
  def _reduce_117(val, _values, result); end
  def _reduce_12(val, _values, result); end
  def _reduce_126(val, _values, result); end
  def _reduce_127(val, _values, result); end
  def _reduce_134(val, _values, result); end
  def _reduce_135(val, _values, result); end
  def _reduce_136(val, _values, result); end
  def _reduce_137(val, _values, result); end
  def _reduce_138(val, _values, result); end
  def _reduce_139(val, _values, result); end
  def _reduce_140(val, _values, result); end
  def _reduce_141(val, _values, result); end
  def _reduce_142(val, _values, result); end
  def _reduce_143(val, _values, result); end
  def _reduce_144(val, _values, result); end
  def _reduce_145(val, _values, result); end
  def _reduce_146(val, _values, result); end
  def _reduce_147(val, _values, result); end
  def _reduce_151(val, _values, result); end
  def _reduce_152(val, _values, result); end
  def _reduce_153(val, _values, result); end
  def _reduce_155(val, _values, result); end
  def _reduce_156(val, _values, result); end
  def _reduce_157(val, _values, result); end
  def _reduce_158(val, _values, result); end
  def _reduce_159(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_160(val, _values, result); end
  def _reduce_161(val, _values, result); end
  def _reduce_162(val, _values, result); end
  def _reduce_163(val, _values, result); end
  def _reduce_164(val, _values, result); end
  def _reduce_165(val, _values, result); end
  def _reduce_166(val, _values, result); end
  def _reduce_167(val, _values, result); end
  def _reduce_168(val, _values, result); end
  def _reduce_169(val, _values, result); end
  def _reduce_170(val, _values, result); end
  def _reduce_171(val, _values, result); end
  def _reduce_172(val, _values, result); end
  def _reduce_173(val, _values, result); end
  def _reduce_174(val, _values, result); end
  def _reduce_175(val, _values, result); end
  def _reduce_176(val, _values, result); end
  def _reduce_177(val, _values, result); end
  def _reduce_18(val, _values, result); end
  def _reduce_180(val, _values, result); end
  def _reduce_181(val, _values, result); end
  def _reduce_19(val, _values, result); end
  def _reduce_2(val, _values, result); end
  def _reduce_20(val, _values, result); end
  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end
  def _reduce_23(val, _values, result); end
  def _reduce_24(val, _values, result); end
  def _reduce_25(val, _values, result); end
  def _reduce_26(val, _values, result); end
  def _reduce_27(val, _values, result); end
  def _reduce_28(val, _values, result); end
  def _reduce_29(val, _values, result); end
  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_33(val, _values, result); end
  def _reduce_37(val, _values, result); end
  def _reduce_38(val, _values, result); end
  def _reduce_4(val, _values, result); end
  def _reduce_63(val, _values, result); end
  def _reduce_64(val, _values, result); end
  def _reduce_65(val, _values, result); end
  def _reduce_66(val, _values, result); end
  def _reduce_67(val, _values, result); end
  def _reduce_68(val, _values, result); end
  def _reduce_69(val, _values, result); end
  def _reduce_70(val, _values, result); end
  def _reduce_71(val, _values, result); end
  def _reduce_72(val, _values, result); end
  def _reduce_73(val, _values, result); end
  def _reduce_74(val, _values, result); end
  def _reduce_75(val, _values, result); end
  def _reduce_83(val, _values, result); end
  def _reduce_84(val, _values, result); end
  def _reduce_85(val, _values, result); end
  def _reduce_86(val, _values, result); end
  def _reduce_87(val, _values, result); end
  def _reduce_88(val, _values, result); end
  def _reduce_89(val, _values, result); end
  def _reduce_90(val, _values, result); end
  def _reduce_91(val, _values, result); end
  def _reduce_92(val, _values, result); end
  def _reduce_93(val, _values, result); end
  def _reduce_94(val, _values, result); end
  def _reduce_95(val, _values, result); end
  def _reduce_96(val, _values, result); end
  def _reduce_97(val, _values, result); end
  def _reduce_98(val, _values, result); end
  def _reduce_99(val, _values, result); end
  def _reduce_none(val, _values, result); end
  def parse_document; end

  private

  def get_description(token); end
  def make_node(node_name, assigns); end
  def next_token; end
  def on_error(parser_token_id, lexer_token, vstack); end

  class << self
    def cache; end
    def cache=(_arg0); end
    def parse(query_string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end
    def parse_file(filename, tracer: T.unsafe(nil)); end
  end
end

GraphQL::Language::Parser::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
GraphQL::Language::Parser::Racc_arg = T.let(T.unsafe(nil), Array)
GraphQL::Language::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

class GraphQL::Language::Printer
  # Turn an arbitrary AST node back into a string.
  #
  # @example Turning a document into a query string
  #   document = GraphQL.parse(query_string)
  #   GraphQL::Language::Printer.new.print(document)
  #   # => "{ ... }"
  # @example Building a custom printer
  #
  #   class MyPrinter < GraphQL::Language::Printer
  #   def print_argument(arg)
  #   "#{arg.name}: <HIDDEN>"
  #   end
  #   end
  #
  #   MyPrinter.new.print(document)
  #   # => "mutation { pay(creditCard: <HIDDEN>) { success } }"
  # @param indent [String] Whitespace to add to the printed node
  # @return [String] Valid GraphQL for `node`
  def print(node, indent: T.unsafe(nil)); end

  protected

  def print_argument(argument); end
  def print_arguments(arguments, indent: T.unsafe(nil)); end
  def print_description(node, indent: T.unsafe(nil), first_in_block: T.unsafe(nil)); end
  def print_directive(directive); end
  def print_directive_definition(directive); end
  def print_directives(directives); end
  def print_document(document); end
  def print_enum(enum); end
  def print_enum_type_definition(enum_type); end
  def print_enum_value_definition(enum_value); end
  def print_field(field, indent: T.unsafe(nil)); end
  def print_field_definition(field); end
  def print_field_definitions(fields); end
  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end
  def print_fragment_spread(fragment_spread, indent: T.unsafe(nil)); end
  def print_implements(type); end
  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end
  def print_input_object(input_object); end
  def print_input_object_type_definition(input_object_type); end
  def print_input_value_definition(input_value); end
  def print_interface_type_definition(interface_type); end
  def print_list_type(list_type); end
  def print_node(node, indent: T.unsafe(nil)); end
  def print_non_null_type(non_null_type); end
  def print_null_value; end
  def print_object_type_definition(object_type); end
  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end
  def print_scalar_type_definition(scalar_type); end
  def print_schema_definition(schema); end
  def print_selections(selections, indent: T.unsafe(nil)); end
  def print_type_name(type_name); end
  def print_union_type_definition(union_type); end
  def print_variable_definition(variable_definition); end
  def print_variable_identifier(variable_identifier); end

  private

  # Returns the value of attribute node.
  def node; end
end

# A custom printer used to print sanitized queries. It inlines provided variables
# within the query for facilitate logging and analysis of queries.
#
# The printer returns `nil` if the query is invalid.
#
# Since the GraphQL Ruby AST for a GraphQL query doesnt contain any reference
# on the type of fields or arguments, we have to track the current object, field
# and input type while printing the query.
#
# @example Printing a scrubbed string
#   printer = QueryPrinter.new(query)
#   puts printer.sanitized_query_string
# @see {Query#sanitized_query_string}
class GraphQL::Language::SanitizedPrinter < ::GraphQL::Language::Printer
  # @return [SanitizedPrinter] a new instance of SanitizedPrinter
  def initialize(query, inline_variables: T.unsafe(nil)); end

  # @return [Boolean]
  def coerce_argument_value_to_list?(type, value); end

  def print_argument(argument); end
  def print_directive(directive); end
  def print_field(field, indent: T.unsafe(nil)); end
  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end
  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end
  def print_node(node, indent: T.unsafe(nil)); end

  # Print the operation definition but do not include the variable
  # definitions since we will inline them within the query
  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end

  def print_variable_identifier(variable_id); end

  # Indicates whether or not to redact non-null values for the given argument. Defaults to redacting all strings
  # arguments but this can be customized by subclasses.
  #
  # @return [Boolean]
  def redact_argument_value?(argument, value); end

  # Returns the value to use for redacted versions of the given argument. Defaults to the
  # string "<REDACTED>".
  def redacted_argument_value(argument); end

  # @return [String, nil] A scrubbed query string, if the query was valid.
  def sanitized_query_string; end

  private

  # Returns the value of attribute query.
  def query; end

  def value_to_ast(value, type); end
end

GraphQL::Language::SanitizedPrinter::REDACTED = T.let(T.unsafe(nil), String)

# Emitted by the lexer and passed to the parser.
# Contains type, value and position data.
class GraphQL::Language::Token
  # @return [Token] a new instance of Token
  def initialize(name, value, line, col, prev_token); end

  # Returns the value of attribute col.
  def col; end

  def inspect; end

  # Returns the value of attribute line.
  def line; end

  def line_and_column; end

  # @return [Symbol] The kind of token this is
  def name; end

  # Returns the value of attribute prev_token.
  def prev_token; end

  def to_f; end
  def to_i; end

  # @return [String] The text of this token
  def to_s; end

  # @return [String] The text of this token
  def value; end
end

# Depth-first traversal through the tree, calling hooks at each stop.
#
# @example Create a visitor counting certain field names
#   class NameCounter < GraphQL::Language::Visitor
#   def initialize(document, field_name)
#   super(document)
#   @field_name = field_name
#   @count = 0
#   end
#
#   attr_reader :count
#
#   def on_field(node, parent)
#   # if this field matches our search, increment the counter
#   if node.name == @field_name
#   @count += 1
#   end
#   # Continue visiting subfields:
#   super
#   end
#   end
#
#   # Initialize a visitor
#   visitor = NameCounter.new(document, "name")
#   # Run it
#   visitor.visit
#   # Check the result
#   visitor.count
#   # => 3
class GraphQL::Language::Visitor
  # @return [Visitor] a new instance of Visitor
  def initialize(document); end

  # Get a {NodeVisitor} for `node_class`
  #
  # @deprecated see `on_` methods, like {#on_field}
  # @example Run a hook whenever you enter a new Field
  #   visitor[GraphQL::Language::Nodes::Field] << ->(node, parent) { p "Here's a field" }
  # @param node_class [Class] The node class that you want to listen to
  # @return [NodeVisitor]
  def [](node_class); end

  # The default implementation for visiting an AST node.
  # It doesn't _do_ anything, but it continues to visiting the node's children.
  # To customize this hook, override one of its make_visit_methodes (or the base method?)
  # in your subclasses.
  #
  # For compatibility, it calls hook procs, too.
  #
  # @param node [GraphQL::Language::Nodes::AbstractNode] the node being visited
  # @param parent [GraphQL::Language::Nodes::AbstractNode, nil] the previously-visited node, or `nil` if this is the root node.
  # @return [Array, nil] If there were modifications, it returns an array of new nodes, otherwise, it returns `nil`.
  def on_abstract_node(node, parent); end

  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_directive_definition(node, parent); end
  def on_directive_location(node, parent); end
  def on_document(node, parent); end
  def on_enum(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_list_type(node, parent); end
  def on_non_null_type(node, parent); end
  def on_null_value(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_type_name(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
  def on_variable_definition(node, parent); end
  def on_variable_identifier(node, parent); end

  # @return [GraphQL::Language::Nodes::Document] The document with any modifications applied
  def result; end

  # Visit `document` and all children, applying hooks as you go
  #
  # @return [void]
  def visit; end

  # Call the user-defined handler for `node`.
  def visit_node(node, parent); end

  private

  def begin_visit(node, parent); end

  # Should global `leave` visitors come first or last?
  def end_visit(node, parent); end

  # Run the hooks for `node`, and if the hooks return a copy of `node`,
  # copy `parent` so that it contains the copy of that node as a child,
  # then return the copies
  # If a non-array value is returned, consuming functions should ignore
  # said value
  def on_node_with_modifications(node, parent); end

  class << self
    # If one of the visitors returns SKIP, stop visiting this node
    def apply_hooks(hooks, node, parent); end

    # We don't use `alias` here because it breaks `super`
    def make_visit_method(node_method); end
  end
end

# When this is returned from a visitor method,
# Then the `node` passed into the method is removed from `parent`'s children.
GraphQL::Language::Visitor::DELETE_NODE = T.let(T.unsafe(nil), GraphQL::Language::Visitor::DeleteNode)

class GraphQL::Language::Visitor::DeleteNode; end

# Collect `enter` and `leave` hooks for classes in {GraphQL::Language::Nodes}
#
# Access {NodeVisitor}s via {GraphQL::Language::Visitor#[]}
class GraphQL::Language::Visitor::NodeVisitor
  # @return [NodeVisitor] a new instance of NodeVisitor
  def initialize; end

  # Shorthand to add a hook to the {#enter} array
  #
  # @param hook [Proc] A hook to add
  def <<(hook); end

  # @return [Array<Proc>] Hooks to call when entering a node of this type
  def enter; end

  # @return [Array<Proc>] Hooks to call when leaving a node of this type
  def leave; end
end

# If any hook returns this value, the {Visitor} stops visiting this
# node right away
#
# @deprecated Use `super` to continue the visit; or don't call it to halt.
GraphQL::Language::Visitor::SKIP = T.let(T.unsafe(nil), Symbol)

# A list type modifies another type.
#
# List types can be created with the type helper (`types[InnerType]`)
# or {BaseType#to_list_type} (`InnerType.to_list_type`)
#
# For return types, it says that the returned value will be a list of the modified.
#
# For input types, it says that the incoming value will be a list of the modified type.
#
# Given a list type, you can always get the underlying type with {#unwrap}.
#
# @example A field which returns a list of items
#   field :items, types[ItemType]
#   # or
#   field :items, ItemType.to_list_type
# @example A field which accepts a list of strings
#   field :newNames do
#   # ...
#   argument :values, types[types.String]
#   # or
#   argument :values, types.String.to_list_type
#   end
class GraphQL::ListType < ::GraphQL::BaseType
  include ::GraphQL::BaseType::ModifiesAnotherType

  # @return [ListType] a new instance of ListType
  def initialize(of_type:); end

  def coerce_result(value, ctx = T.unsafe(nil)); end
  def inspect; end
  def kind; end

  # @return [Boolean]
  def list?; end

  # Returns the value of attribute of_type.
  def of_type; end

  def to_s; end
  def to_type_signature; end

  private

  def coerce_non_null_input(value, ctx); end
  def ensure_array(value); end
  def validate_non_null_input(value, ctx); end
end

# Raised when a argument is configured with `loads:` and the client provides an `ID`,
# but no object is loaded for that ID.
#
# @see GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader#load_application_object_failed, A hook which you can override in resolvers, mutations and input objects.
class GraphQL::LoadApplicationObjectFailedError < ::GraphQL::ExecutionError
  # @return [LoadApplicationObjectFailedError] a new instance of LoadApplicationObjectFailedError
  def initialize(argument:, id:, object:); end

  # @return [GraphQL::Schema::Argument] the argument definition for the argument that was looked up
  def argument; end

  # @return [String] The ID provided by the client
  def id; end

  # @return [Object] The value found with this ID
  def object; end
end

class GraphQL::NameValidator
  class << self
    # @raise [GraphQL::InvalidNameError]
    def validate!(name); end
  end
end

GraphQL::NameValidator::VALID_NAME_REGEX = T.let(T.unsafe(nil), Regexp)

# A non-null type modifies another type.
#
# Non-null types can be created with `!` (`InnerType!`)
# or {BaseType#to_non_null_type} (`InnerType.to_non_null_type`)
#
# For return types, it says that the returned value will _always_ be present.
#
# (If the application fails to return a value, {InvalidNullError} will be passed to {Schema#type_error}.)
#
# For input types, it says that the incoming value _must_ be provided by the query.
#
# (If a value isn't provided, {Query::VariableValidationError} will be raised).
#
# Given a non-null type, you can always get the underlying type with {#unwrap}.
#
# @example A field which _always_ returns an error
#   field :items, !ItemType
#   # or
#   field :items, ItemType.to_non_null_type
# @example A field which _requires_ a string input
#   field :newNames do
#   # ...
#   argument :values, !types.String
#   # or
#   argument :values, types.String.to_non_null_type
#   end
class GraphQL::NonNullType < ::GraphQL::BaseType
  include ::GraphQL::BaseType::ModifiesAnotherType
  extend ::Forwardable

  # @return [NonNullType] a new instance of NonNullType
  def initialize(of_type:); end

  def coerce_input(*args, **_arg1, &block); end
  def coerce_result(*args, **_arg1, &block); end
  def inspect; end
  def kind; end
  def list?(*args, **_arg1, &block); end

  # @return [Boolean]
  def non_null?; end

  # Returns the value of attribute of_type.
  def of_type; end

  def to_s; end
  def to_type_signature; end

  # @return [Boolean]
  def valid_input?(value, ctx); end

  def validate_input(value, ctx); end
end

# @api deprecated
class GraphQL::ObjectType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  # @api deprecated
  # @return [ObjectType] a new instance of ObjectType
  def initialize; end

  # These fields don't have instrumenation applied
  #
  # @api deprecated
  # @return [Array<GraphQL::Field>] All fields, including ones inherited from interfaces
  # @see [Schema#get_fields] Get fields with instrumentation
  def all_fields; end

  # @return [Hash<String => GraphQL::Field>] Map String fieldnames to their {GraphQL::Field} implementations
  def fields; end

  # @return [Hash<String => GraphQL::Field>] Map String fieldnames to their {GraphQL::Field} implementations
  def fields=(_arg0); end

  # This fields doesnt have instrumenation applied
  #
  # @api deprecated
  # @return [GraphQL::Field] The field definition for `field_name` (may be inherited from interfaces)
  # @see [Schema#get_field] Get field with instrumentation
  def get_field(field_name); end

  # Declare that this object implements this interface.
  # This declaration will be validated when the schema is defined.
  #
  # @api deprecated
  # @param interfaces [Array<GraphQL::Interface>] add a new interface that this type implements
  # @param inherits [Boolean] If true, copy the interfaces' field definitions to this type
  def implements(interfaces, inherit: T.unsafe(nil), **options); end

  # @api deprecated
  def interfaces(ctx = T.unsafe(nil)); end

  # This method declares interfaces for this type AND inherits any field definitions
  #
  # @api deprecated
  # @deprecated Use `implements` instead of `interfaces`.
  # @param new_interfaces [Array<GraphQL::Interface>] interfaces that this type implements
  def interfaces=(new_interfaces); end

  # @api deprecated
  def kind; end

  # @return [GraphQL::Relay::Mutation, nil] The mutation this object type was derived from, if it is an auto-generated payload type.
  def mutation; end

  # @return [GraphQL::Relay::Mutation, nil] The mutation this object type was derived from, if it is an auto-generated payload type.
  def mutation=(_arg0); end

  # @api deprecated
  def relay_node_type; end

  # @api deprecated
  def relay_node_type=(_arg0); end

  # @api deprecated
  def resolve_type_proc; end

  # @api deprecated
  def structural_interface_type_memberships=(_arg0); end

  protected

  # @api deprecated
  def inherited_interface_type_memberships; end

  # @api deprecated
  def structural_interface_type_memberships; end

  private

  # @api deprecated
  def initialize_copy(other); end

  # @api deprecated
  def interface_fields; end

  # @api deprecated
  def normalize_interfaces(ifaces); end
end

module GraphQL::Pagination; end

# Customizes `RelationConnection` to work with `ActiveRecord::Relation`s.
class GraphQL::Pagination::ActiveRecordRelationConnection < ::GraphQL::Pagination::RelationConnection
  private

  # @return [Boolean]
  def already_loaded?(relation); end

  def null_relation(relation); end
  def relation_count(relation); end
  def relation_larger_than(relation, initial_offset, size); end
  def relation_limit(relation); end
  def relation_offset(relation); end
  def set_limit(nodes, limit); end
  def set_offset(nodes, offset); end
end

class GraphQL::Pagination::ArrayConnection < ::GraphQL::Pagination::Connection
  def cursor_for(item); end
  def has_next_page; end
  def has_previous_page; end
  def nodes; end

  private

  def index_from_cursor(cursor); end

  # Populate all the pagination info _once_,
  # It doesn't do anything on subsequent calls.
  def load_nodes; end
end

# A Connection wraps a list of items and provides cursor-based pagination over it.
#
# Connections were introduced by Facebook's `Relay` front-end framework, but
# proved to be generally useful for GraphQL APIs. When in doubt, use connections
# to serve lists (like Arrays, ActiveRecord::Relations) via GraphQL.
#
# Unlike the previous connection implementation, these default to bidirectional pagination.
#
# Pagination arguments and context may be provided at initialization or assigned later (see {Schema::Field::ConnectionExtension}).
class GraphQL::Pagination::Connection
  # @param items [Object] some unpaginated collection item, like an `Array` or `ActiveRecord::Relation`
  # @param context [Query::Context]
  # @param parent [Object] The object this collection belongs to
  # @param first [Integer, nil] The limit parameter from the client, if it provided one
  # @param after [String, nil] A cursor for pagination, if the client provided one
  # @param last [Integer, nil] Limit parameter from the client, if provided
  # @param before [String, nil] A cursor for pagination, if the client provided one.
  # @param arguments [Hash] The arguments to the field that returned the collection wrapped by this connection
  # @param max_page_size [Integer, nil] A configured value to cap the result size. Applied as `first` if neither first or last are given.
  # @return [Connection] a new instance of Connection
  def initialize(items, parent: T.unsafe(nil), field: T.unsafe(nil), context: T.unsafe(nil), first: T.unsafe(nil), after: T.unsafe(nil), max_page_size: T.unsafe(nil), last: T.unsafe(nil), before: T.unsafe(nil), edge_class: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # @return [String, nil] the client-provided cursor. `""` is treated as `nil`.
  def after; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def after_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def after_value=(_arg0); end

  # @return [Hash<Symbol => Object>] The field arguments from the field that returned this connection
  def arguments; end

  # @return [Hash<Symbol => Object>] The field arguments from the field that returned this connection
  def arguments=(_arg0); end

  # @return [String, nil] the client-provided cursor. `""` is treated as `nil`.
  def before; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def before_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def before_value=(_arg0); end

  # @return [GraphQL::Query::Context]
  def context; end

  # @return [GraphQL::Query::Context]
  def context=(_arg0); end

  # Return a cursor for this item.
  #
  # @param item [Object] one of the passed in {items}, taken from {nodes}
  # @raise [PaginationImplementationMissingError]
  # @return [String]
  def cursor_for(item); end

  # @return [Class] A wrapper class for edges of this connection
  def edge_class; end

  # @return [Class] A wrapper class for edges of this connection
  def edge_class=(_arg0); end

  # A dynamic alias for compatibility with {Relay::BaseConnection}.
  #
  # @deprecated use {#nodes} instead
  def edge_nodes; end

  # @return [Array<Edge>] {nodes}, but wrapped with Edge instances
  def edges; end

  # @return [String] The cursor of the last item in {nodes}
  def end_cursor; end

  # @return [GraphQL::Schema::Field] The field this connection was returned by
  def field; end

  # @return [GraphQL::Schema::Field] The field this connection was returned by
  def field=(_arg0); end

  # @return [Integer, nil] A clamped `first` value.
  #   (The underlying instance variable doesn't have limits on it.)
  #   If neither `first` nor `last` is given, but `max_page_size` is present, max_page_size is used for first.
  def first; end

  # Sets the attribute first
  #
  # @param value the value to set the attribute first to.
  def first=(_arg0); end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def first_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def first_value=(_arg0); end

  # @return [Boolean]
  def has_max_page_size_override?; end

  # @raise [PaginationImplementationMissingError]
  # @return [Boolean] True if there are more items after this page
  def has_next_page; end

  # @raise [PaginationImplementationMissingError]
  # @return [Boolean] True if there were items before these items
  def has_previous_page; end

  # @return [Object] A list object, from the application. This is the unpaginated value passed into the connection.
  def items; end

  # @return [Integer, nil] A clamped `last` value. (The underlying instance variable doesn't have limits on it)
  def last; end

  # Sets the attribute last
  #
  # @param value the value to set the attribute last to.
  def last=(_arg0); end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def last_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def last_value=(_arg0); end

  def max_page_size; end
  def max_page_size=(new_value); end

  # @raise [PaginationImplementationMissingError]
  # @return [Array<Object>] A slice of {items}, constrained by {@first_value}/{@after_value}/{@last_value}/{@before_value}
  def nodes; end

  # The connection object itself implements `PageInfo` fields
  def page_info; end

  # @return [Object] the object this collection belongs to
  def parent; end

  # @return [Object] the object this collection belongs to
  def parent=(_arg0); end

  # This is called by `Relay::RangeAdd` -- it can be overridden
  # when `item` needs some modifications based on this connection's state.
  #
  # @param item [Object] An item newly added to `items`
  # @return [Edge]
  def range_add_edge(item); end

  # @return [String] The cursor of the first item in {nodes}
  def start_cursor; end

  private

  def decode(cursor); end
  def encode(cursor); end

  # @param argument [nil, Integer] `first` or `last`, as provided by the client
  # @param max_page_size [nil, Integer]
  # @return [nil, Integer] `nil` if the input was `nil`, otherwise a value between `0` and `max_page_size`
  def limit_pagination_argument(argument, max_page_size); end
end

# A wrapper around paginated items. It includes a {cursor} for pagination
# and could be extended with custom relationship-level data.
class GraphQL::Pagination::Connection::Edge
  # @return [Edge] a new instance of Edge
  def initialize(node, connection); end

  def cursor; end

  # Returns the value of attribute node.
  def node; end

  def parent; end
end

class GraphQL::Pagination::Connection::PaginationImplementationMissingError < ::GraphQL::Error; end

# A schema-level connection wrapper manager.
#
# Attach as a plugin.
#
# @example Adding a custom wrapper
#   class MySchema < GraphQL::Schema
#   connections.add(MyApp::SearchResults, MyApp::SearchResultsConnection)
#   end
# @example Removing default connection support for arrays (they can still be manually wrapped)
#   class MySchema < GraphQL::Schema
#   connections.delete(Array)
#   end
# @see {Schema.connections}
class GraphQL::Pagination::Connections
  # @return [Connections] a new instance of Connections
  def initialize(schema:); end

  def add(nodes_class, implementation); end
  def all_wrappers; end
  def delete(nodes_class); end

  # use an override if there is one
  #
  # @api private
  def edge_class_for_field(field); end

  # Used by the runtime to wrap values in connection wrappers.
  #
  # @api Private
  def wrap(field, parent, items, arguments, context); end

  def wrapper_for(items, wrappers: T.unsafe(nil)); end

  protected

  # Returns the value of attribute wrappers.
  def wrappers; end

  private

  def add_default; end

  class << self
    def use(schema_defn); end
  end
end

class GraphQL::Pagination::Connections::ImplementationMissingError < ::GraphQL::Error; end

class GraphQL::Pagination::MongoidRelationConnection < ::GraphQL::Pagination::RelationConnection
  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

# A generic class for working with database query objects.
class GraphQL::Pagination::RelationConnection < ::GraphQL::Pagination::Connection
  def cursor_for(item); end
  def has_next_page; end
  def has_previous_page; end
  def nodes; end

  private

  # @return [Integer, nil]
  def after_offset; end

  # @return [Integer, nil]
  def before_offset; end

  def calculate_sliced_nodes_parameters; end

  # Apply `first` and `last` to `sliced_nodes`,
  # returning a new relation
  def limited_nodes; end

  # Load nodes after applying first/last/before/after,
  # returns an array of nodes
  def load_nodes; end

  # @param relation [Object] A database query object
  # @return [Object] A modified query object which will return no records
  def null_relation(relation); end

  # @return [Integer]
  def offset_from_cursor(cursor); end

  # @param relation [Object] A database query object
  # @return [Integer, nil] The number of items in this relation (hopefully determined without loading all records into memory!)
  def relation_count(relation); end

  # @param relation [Object] A database query object
  # @param _initial_offset [Integer] The number of items already excluded from the relation
  # @param size [Integer] The value against which we check the relation size
  # @return [Boolean] True if the number of items in this relation is larger than `size`
  def relation_larger_than(relation, _initial_offset, size); end

  # @param relation [Object] A database query object
  # @return [Integer, nil] The limit value, or nil if there isn't one
  def relation_limit(relation); end

  # @param relation [Object] A database query object
  # @return [Integer, nil] The offset value, or nil if there isn't one
  def relation_offset(relation); end

  # Abstract this operation so we can always ignore inputs less than zero.
  # (Sequel doesn't like it, understandably.)
  def set_limit(relation, limit_value); end

  # Abstract this operation so we can always ignore inputs less than zero.
  # (Sequel doesn't like it, understandably.)
  def set_offset(relation, offset_value); end

  # Apply `before` and `after` to the underlying `items`,
  # returning a new relation.
  def sliced_nodes; end
end

# Customizes `RelationConnection` to work with `Sequel::Dataset`s.
class GraphQL::Pagination::SequelDatasetConnection < ::GraphQL::Pagination::RelationConnection
  private

  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

class GraphQL::ParseError < ::GraphQL::Error
  # @return [ParseError] a new instance of ParseError
  def initialize(message, line, col, query, filename: T.unsafe(nil)); end

  # Returns the value of attribute col.
  def col; end

  # Returns the value of attribute line.
  def line; end

  # Returns the value of attribute query.
  def query; end

  def to_h; end
end

# A combination of query string and {Schema} instance which can be reduced to a {#result}.
class GraphQL::Query
  include ::GraphQL::Tracing::Traceable
  extend ::Forwardable

  # Prepare query `query_string` on `schema`
  #
  # @param schema [GraphQL::Schema]
  # @param query_string [String]
  # @param context [#[]] an arbitrary hash of values which you can access in {GraphQL::Field#resolve}
  # @param variables [Hash] values for `$variables` in the query
  # @param operation_name [String] if the query string contains many operations, this is the one which should be executed
  # @param root_value [Object] the object used to resolve fields on the root type
  # @param max_depth [Numeric] the maximum number of nested selections allowed for this query (falls back to schema-level value)
  # @param max_complexity [Numeric] the maximum field complexity for this query (falls back to schema-level value)
  # @param except [<#call(schema_member, context)>] If provided, objects will be hidden from the schema when `.call(schema_member, context)` returns truthy
  # @param only [<#call(schema_member, context)>] If provided, objects will be hidden from the schema when `.call(schema_member, context)` returns false
  # @return [Query] a new instance of Query
  def initialize(schema, query_string = T.unsafe(nil), query: T.unsafe(nil), document: T.unsafe(nil), context: T.unsafe(nil), variables: T.unsafe(nil), validate: T.unsafe(nil), subscription_topic: T.unsafe(nil), operation_name: T.unsafe(nil), root_value: T.unsafe(nil), max_depth: T.unsafe(nil), max_complexity: T.unsafe(nil), except: T.unsafe(nil), only: T.unsafe(nil), warden: T.unsafe(nil)); end

  # Returns the value of attribute analysis_errors.
  def analysis_errors; end

  # Sets the attribute analysis_errors
  #
  # @param value the value to set the attribute analysis_errors to.
  def analysis_errors=(_arg0); end

  def analyzers(*args, **_arg1, &block); end
  def arguments_cache; end

  # Node-level cache for calculating arguments. Used during execution and query analysis.
  #
  # @param ast_node [GraphQL::Language::Nodes::AbstractNode]
  # @param definition [GraphQL::Schema::Field]
  # @param parent_object [GraphQL::Schema::Object]
  def arguments_for(ast_node, definition, parent_object: T.unsafe(nil)); end

  def ast_analyzers(*args, **_arg1, &block); end

  # Returns the value of attribute context.
  def context; end

  # @return [GraphQL::Language::Nodes::Document]
  def document; end

  # @return [Boolean]
  def executed?; end

  # This contains a few components:
  #
  # - The selected operation name (or `anonymous`)
  # - The fingerprint of the query string
  # - The number of given variables (for readability)
  # - The fingerprint of the given variables
  #
  # This fingerprint can be used to track runs of the same operation-variables combination over time.
  #
  # @return [String] An opaque hash identifying this operation-variables combination
  # @see operation_fingerprint
  # @see variables_fingerprint
  def fingerprint; end

  def fragments; end
  def get_field(*args, **_arg1, &block); end
  def get_type(*args, **_arg1, &block); end
  def inspect; end
  def internal_representation(*args, **_arg1, &block); end

  # @return [Boolean]
  def interpreter?; end

  def irep_selection; end

  # A lookahead for the root selections of this query
  #
  # @return [GraphQL::Execution::Lookahead]
  def lookahead; end

  def max_complexity(*args, **_arg1, &block); end
  def max_depth(*args, **_arg1, &block); end

  # @return [void]
  def merge_filters(only: T.unsafe(nil), except: T.unsafe(nil)); end

  # Returns the value of attribute multiplex.
  def multiplex; end

  # Sets the attribute multiplex
  #
  # @param value the value to set the attribute multiplex to.
  def multiplex=(_arg0); end

  # @return [Boolean]
  def mutation?; end

  # @return [String] An opaque hash for identifying this query's given query string and selected operation
  def operation_fingerprint; end

  # @return [nil, String] The operation name provided by client or the one inferred from the document. Used to determine which operation to run.
  def operation_name; end

  # @return [nil, String] The operation name provided by client or the one inferred from the document. Used to determine which operation to run.
  def operation_name=(_arg0); end

  def operations; end
  def possible_types(*args, **_arg1, &block); end

  # Returns the value of attribute provided_variables.
  def provided_variables; end

  # @return [Boolean]
  def query?; end

  # If a document was provided to `GraphQL::Schema#execute` instead of the raw query string, we will need to get it from the document
  def query_string; end

  # Sets the attribute query_string
  #
  # @param value the value to set the attribute query_string to.
  def query_string=(_arg0); end

  # @param abstract_type [GraphQL::UnionType, GraphQL::InterfaceType]
  # @param value [Object] Any runtime value
  # @return [GraphQL::ObjectType, nil] The runtime type of `value` from {Schema#resolve_type}
  # @see {#possible_types} to apply filtering from `only` / `except`
  def resolve_type(abstract_type, value = T.unsafe(nil)); end

  # Get the result for this query, executing it once
  #
  # @return [Hash] A GraphQL response, with `"data"` and/or `"errors"` keys
  def result; end

  # @api private
  def result_values; end

  # @api private
  def result_values=(result_hash); end

  def root_type_for_operation(*args, **_arg1, &block); end

  # The value for root types
  def root_value; end

  # The value for root types
  def root_value=(_arg0); end

  # A version of the given query string, with:
  # - Variables inlined to the query
  # - Strings replaced with `<REDACTED>`
  #
  # @return [String, nil] Returns nil if the query is invalid.
  def sanitized_query_string(inline_variables: T.unsafe(nil)); end

  # Returns the value of attribute schema.
  def schema; end

  # This is the operation to run for this query.
  # If more than one operation is present, it must be named at runtime.
  #
  # @return [GraphQL::Language::Nodes::OperationDefinition, nil]
  def selected_operation; end

  # @return [String, nil] The name of the operation to run (may be inferred)
  def selected_operation_name; end

  def static_errors; end

  # @return [Boolean]
  def subscription?; end

  # @return [String, nil] the triggered event, if this query is a subscription update
  def subscription_topic; end

  # @return [Boolean]
  def subscription_update?; end

  # Returns the value of attribute tracers.
  def tracers; end

  # @return [Boolean]
  def valid?; end

  # @return [Boolean] if false, static validation is skipped (execution behavior for invalid queries is undefined)
  def validate; end

  # @return [Boolean] if false, static validation is skipped (execution behavior for invalid queries is undefined)
  def validate=(_arg0); end

  def validation_errors(*args, **_arg1, &block); end
  def validation_pipeline; end

  # Determine the values for variables of this query, using default values
  # if a value isn't provided at runtime.
  #
  # If some variable is invalid, errors are added to {#validation_errors}.
  #
  # @return [GraphQL::Query::Variables] Variables to apply to this query
  def variables; end

  # @return [String] An opaque hash for identifying this query's given a variable values (not including defaults)
  def variables_fingerprint; end

  def warden; end

  # @api private
  def with_error_handling; end

  private

  def find_operation(operations, operation_name); end
  def prepare_ast; end

  # Since the query string is processed at the last possible moment,
  # any internal values which depend on it should be accessed within this wrapper.
  def with_prepared_ast; end
end

# Read-only access to values, normalizing all keys to strings
#
# {Arguments} recursively wraps the input in {Arguments} instances.
class GraphQL::Query::Arguments
  include ::GraphQL::Dig
  extend ::Forwardable

  # @return [Arguments] a new instance of Arguments
  def initialize(values, context:, defaults_used:); end

  # @param key [String, Symbol] name or index of value to access
  # @return [Object] the argument at that key
  def [](key); end

  def any?(*args, **_arg1, &block); end

  # Returns the value of attribute argument_values.
  def argument_values; end

  # @param key [String, Symbol] name of value to access
  # @return [Boolean] true if the argument default was passed as the argument value to the resolver
  def default_used?(key); end

  def each(*args, **_arg1, &block); end

  # Access each key, value and type for the arguments in this set.
  #
  # @yield [argument_value] The {ArgumentValue} for each argument
  # @yieldparam argument_value [ArgumentValue]
  def each_value; end

  # @param key [String, Symbol] name of value to access
  # @return [Boolean] true if the argument was present in this field
  def key?(key); end

  def keys(*args, **_arg1, &block); end
  def prepare; end

  # Get the hash of all values, with stringified keys
  #
  # @return [Hash] the stringified hash
  def to_h; end

  # Convert this instance into valid Ruby keyword arguments
  #
  # @return [{Symbol=>Object}]
  def to_hash; end

  # Convert this instance into valid Ruby keyword arguments
  #
  # @return [{Symbol=>Object}]
  def to_kwargs; end

  def values(*args, **_arg1, &block); end

  private

  def unwrap_value(value); end
  def wrap_value(value, arg_defn_type, context); end

  class << self
    # Returns the value of attribute argument_definitions.
    def argument_definitions; end

    # Sets the attribute argument_definitions
    #
    # @param value the value to set the attribute argument_definitions to.
    def argument_definitions=(_arg0); end

    # Returns the value of attribute argument_owner.
    def argument_owner; end

    # Sets the attribute argument_owner
    #
    # @param value the value to set the attribute argument_owner to.
    def argument_owner=(_arg0); end

    def construct_arguments_class(argument_owner); end
  end
end

class GraphQL::Query::Arguments::ArgumentValue
  # @return [ArgumentValue] a new instance of ArgumentValue
  def initialize(key, value, definition, default_used); end

  # Sets the attribute default_used
  #
  # @param value the value to set the attribute default_used to.
  def default_used=(_arg0); end

  # @return [Boolean] true if the argument default was passed as the argument value to the resolver
  def default_used?; end

  # Returns the value of attribute definition.
  def definition; end

  # Returns the value of attribute key.
  def key; end

  # Returns the value of attribute value.
  def value; end
end

GraphQL::Query::Arguments::NO_ARGS = T.let(T.unsafe(nil), GraphQL::Query::Arguments::NoArguments)
GraphQL::Query::Arguments::NULL_ARGUMENT_VALUE = T.let(T.unsafe(nil), GraphQL::Query::Arguments::ArgumentValue)
class GraphQL::Query::Arguments::NoArguments < ::GraphQL::Query::Arguments; end

module GraphQL::Query::ArgumentsCache
  class << self
    # @return [Hash<InternalRepresentation::Node, GraphQL::Language::NodesDirectiveNode => Hash<GraphQL::Field, GraphQL::Directive => GraphQL::Query::Arguments>>]
    def build(query); end
  end
end

# Expose some query-specific info to field resolve functions.
# It delegates `[]` to the hash that's passed to `GraphQL::Query#initialize`.
class GraphQL::Query::Context
  include ::GraphQL::Query::Context::SharedMethods
  extend ::Forwardable

  # Make a new context which delegates key lookup to `values`
  #
  # @param query [GraphQL::Query] the query who owns this context
  # @param values [Hash] A hash of arbitrary values which will be accessible at query-time
  # @return [Context] a new instance of Context
  def initialize(query:, values:, object:, schema: T.unsafe(nil)); end

  # Lookup `key` from the hash passed to {Schema#execute} as `context:`
  def [](key); end

  # Reassign `key` to the hash passed to {Schema#execute} as `context:`
  def []=(key, value); end

  # @return [GraphQL::Language::Nodes::Field] The AST node for the currently-executing field
  def ast_node; end

  def dataloader; end
  def delete(key); end
  def dig(key, *other_keys); end

  # @return [Array<GraphQL::ExecutionError>] errors returned during execution
  def errors; end

  # Returns the value of attribute execution_strategy.
  def execution_strategy; end

  def execution_strategy=(new_strategy); end
  def fetch(key, default = T.unsafe(nil)); end
  def inspect; end

  # @api private
  def interpreter=(_arg0); end

  def interpreter?(*args, **_arg1, &block); end

  # @return [GraphQL::InternalRepresentation::Node] The internal representation for this query node
  def irep_node; end

  # @return [Boolean]
  def key?(key); end

  # Get an isolated hash for `ns`. Doesn't affect user-provided storage.
  #
  # @param ns [Object] a usage-specific namespace identifier
  # @return [Hash] namespaced storage
  def namespace(ns); end

  # @return [Boolean] true if this namespace was accessed before
  def namespace?(ns); end

  # @return [Array<String, Integer>] The current position in the result
  def path; end

  # @return [GraphQL::Query] The query whose context this is
  def query; end

  # @api private
  def received_null_child; end

  # @return [Hash] A hash that will be added verbatim to the result hash, as `"extensions" => { ... }`
  def response_extensions; end

  # @return [GraphQL::Schema]
  def schema; end

  # @api private
  def scoped_context; end

  # @api private
  def scoped_context=(_arg0); end

  def scoped_merge!(hash); end
  def scoped_set!(key, value); end

  # Returns the value of attribute execution_strategy.
  # `strategy` is required by GraphQL::Batch
  def strategy; end

  def to_h; end
  def to_hash; end
  def trace(*args, **_arg1, &block); end

  # @api private
  def value=(_arg0); end

  # @return [GraphQL::Schema::Warden]
  def warden; end

  # @api private
  def warden=(_arg0); end
end

class GraphQL::Query::Context::ExecutionErrors
  # @return [ExecutionErrors] a new instance of ExecutionErrors
  def initialize(ctx); end

  def >>(err_or_msg); end
  def add(err_or_msg); end
  def push(err_or_msg); end
end

class GraphQL::Query::Context::FieldResolutionContext
  include ::GraphQL::Query::Context::SharedMethods
  include ::GraphQL::Tracing::Traceable
  extend ::Forwardable

  # @return [FieldResolutionContext] a new instance of FieldResolutionContext
  def initialize(context, key, irep_node, parent, object); end

  def [](*args, **_arg1, &block); end
  def []=(*args, **_arg1, &block); end

  # Add error to current field resolution.
  #
  # @param error [GraphQL::ExecutionError] an execution error
  # @return [void]
  def add_error(error); end

  # @return [GraphQL::Language::Nodes::Field] The AST node for the currently-executing field
  def ast_node; end

  def dig(*args, **_arg1, &block); end
  def errors(*args, **_arg1, &block); end
  def execution_strategy(*args, **_arg1, &block); end
  def fetch(*args, **_arg1, &block); end

  # Returns the value of attribute field.
  def field; end

  def inspect; end
  def interpreter?(*args, **_arg1, &block); end

  # Returns the value of attribute irep_node.
  def irep_node; end

  # Returns the value of attribute key.
  def key; end

  def key?(*args, **_arg1, &block); end
  def namespace(*args, **_arg1, &block); end

  # Returns the value of attribute parent.
  def parent; end

  # Returns the value of attribute parent_type.
  def parent_type; end

  def path; end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute schema.
  def schema; end

  # Returns the value of attribute irep_node.
  def selection; end

  def spawn(*args, **_arg1, &block); end
  def strategy(*args, **_arg1, &block); end
  def to_h(*args, **_arg1, &block); end

  # Returns the value of attribute type.
  def type; end

  # Set a new value for this field in the response.
  # It may be updated after resolving a {Lazy}.
  # If it is {Execute::PROPAGATE_NULL}, tell the owner to propagate null.
  # If it's {Execute::Execution::SKIP}, remove this field result from its parent
  #
  # @api private
  # @param new_value [Any] The GraphQL-ready value
  def value=(new_value); end

  def warden(*args, **_arg1, &block); end

  # @api private
  def wrapped_connection; end

  # @api private
  def wrapped_connection=(_arg0); end

  # @api private
  def wrapped_object; end

  # @api private
  def wrapped_object=(_arg0); end

  protected

  def received_null_child; end

  private

  # @return [Boolean]
  def list_of_non_null_items?(type); end
end

module GraphQL::Query::Context::SharedMethods
  # Add error at query-level.
  #
  # @param error [GraphQL::ExecutionError] an execution error
  # @return [void]
  def add_error(error); end

  # @example Print the GraphQL backtrace during field resolution
  #   puts ctx.backtrace
  # @return [GraphQL::Backtrace] The backtrace for this point in query execution
  def backtrace; end

  # Remove this child from the result value
  # (used for null propagation and skip)
  #
  # @api private
  def delete_child(child_ctx); end

  def execution_errors; end

  # @return [Boolean] True if this selection has been nullified by a null child
  def invalid_null?; end

  def lookahead; end

  # @return [Object] The target for field resolution
  def object; end

  # @return [Object] The target for field resolution
  def object=(_arg0); end

  # Return this value to tell the runtime
  # to exclude this field from the response altogether
  def skip; end

  # @return [Boolean] were any fields of this selection skipped?
  def skipped; end

  # @api private
  def skipped=(_arg0); end

  # @return [Boolean] were any fields of this selection skipped?
  def skipped?; end

  # Create a child context to use for `key`
  #
  # @api private
  # @param key [String, Integer] The key in the response (name or index)
  # @param irep_node [InternalRepresentation::Node] The node being evaluated
  def spawn_child(key:, irep_node:, object:); end

  # @return [Hash, Array, String, Integer, Float, Boolean, nil] The resolved value for this field
  def value; end
end

GraphQL::Query::Context::UNSPECIFIED_FETCH_DEFAULT = T.let(T.unsafe(nil), Object)

class GraphQL::Query::Executor
  # @return [Executor] a new instance of Executor
  def initialize(query); end

  # @return [GraphQL::Query] the query being executed
  def query; end

  # Evaluate {operation_name} on {query}.
  # Handle {GraphQL::ExecutionError}s by putting them in the "errors" key.
  #
  # @return [Hash] A GraphQL response, with either a "data" key or an "errors" key
  def result; end

  private

  def execute; end
end

class GraphQL::Query::Executor::PropagateNull < ::StandardError; end

# @api private
# @see Query#query_fingerprint
# @see Query#variables_fingerprint
# @see Query#fingerprint
module GraphQL::Query::Fingerprint
  class << self
    # Make an obfuscated hash of the given string (either a query string or variables JSON)
    #
    # @api private
    # @param string [String]
    # @return [String] A normalized, opaque hash
    def generate(input_str); end
  end
end

class GraphQL::Query::InputValidationResult
  # @return [InputValidationResult] a new instance of InputValidationResult
  def initialize(valid: T.unsafe(nil), problems: T.unsafe(nil)); end

  def add_problem(explanation, path = T.unsafe(nil), extensions: T.unsafe(nil), message: T.unsafe(nil)); end
  def merge_result!(path, inner_result); end

  # Returns the value of attribute problems.
  def problems; end

  # Sets the attribute problems
  #
  # @param value the value to set the attribute problems to.
  def problems=(_arg0); end

  # @return [Boolean]
  def valid?; end
end

# Turn query string values into something useful for query execution
class GraphQL::Query::LiteralInput
  class << self
    def coerce(type, ast_node, variables); end
    def from_arguments(ast_arguments, argument_owner, variables); end
  end
end

# This object can be `ctx` in places where there is no query
class GraphQL::Query::NullContext
  # @return [NullContext] a new instance of NullContext
  def initialize; end

  def [](key); end

  # Returns the value of attribute dataloader.
  def dataloader; end

  # @return [Boolean]
  def interpreter?; end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute schema.
  def schema; end

  # Returns the value of attribute warden.
  def warden; end

  class << self
    def [](key); end
    def dataloader(*args, **_arg1, &block); end
    def instance; end
    def interpreter?(*args, **_arg1, &block); end
    def query(*args, **_arg1, &block); end
    def schema(*args, **_arg1, &block); end
    def warden(*args, **_arg1, &block); end
  end
end

class GraphQL::Query::NullContext::NullQuery
  def with_error_handling; end
end

class GraphQL::Query::NullContext::NullSchema < ::GraphQL::Schema; end

class GraphQL::Query::NullContext::NullWarden < ::GraphQL::Schema::Warden
  # @return [Boolean]
  def visible_argument?(arg, ctx); end

  # @return [Boolean]
  def visible_enum_value?(ev, ctx); end

  # @return [Boolean]
  def visible_field?(field, ctx); end

  # @return [Boolean]
  def visible_type?(type, ctx); end

  # @return [Boolean]
  def visible_type_membership?(tm, ctx); end
end

class GraphQL::Query::OperationNameMissingError < ::GraphQL::ExecutionError
  # @return [OperationNameMissingError] a new instance of OperationNameMissingError
  def initialize(name); end
end

# A result from {Schema#execute}.
# It provides the requested data and
# access to the {Query} and {Query::Context}.
class GraphQL::Query::Result
  extend ::Forwardable

  # @return [Result] a new instance of Result
  def initialize(query:, values:); end

  # A result is equal to another object when:
  #
  # - The other object is a Hash whose value matches `result.to_h`
  # - The other object is a Result whose value matches `result.to_h`
  #
  # (The query is ignored for comparing result equality.)
  #
  # @return [Boolean]
  def ==(other); end

  def [](*args, **_arg1, &block); end
  def as_json(*args, **_arg1, &block); end
  def context(*args, **_arg1, &block); end
  def inspect; end
  def keys(*args, **_arg1, &block); end

  # Delegate any hash-like method to the underlying hash.
  def method_missing(method_name, *args, &block); end

  def mutation?(*args, **_arg1, &block); end

  # @return [GraphQL::Query] The query that was executed
  def query; end

  def query?(*args, **_arg1, &block); end
  def subscription?(*args, **_arg1, &block); end

  # @return [Hash] The resulting hash of "data" and/or "errors"
  def to_h; end

  def to_json(*args, **_arg1, &block); end
  def values(*args, **_arg1, &block); end

  private

  # @return [Boolean]
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

class GraphQL::Query::SerialExecution
  # This is the only required method for an Execution strategy.
  # You could create a custom execution strategy and configure your schema to
  # use that custom strategy instead.
  #
  # @param ast_operation [GraphQL::Language::Nodes::OperationDefinition] The operation definition to run
  # @param root_type [GraphQL::ObjectType] either the query type or the mutation type
  # @param query_object [GraphQL::Query] the query object for this execution
  # @return [Hash] a spec-compliant GraphQL result, as a hash
  def execute(ast_operation, root_type, query_object); end

  def field_resolution; end
  def operation_resolution; end
  def selection_resolution; end
end

class GraphQL::Query::SerialExecution::FieldResolution
  # @return [FieldResolution] a new instance of FieldResolution
  def initialize(selection, parent_type, target, query_ctx); end

  # Returns the value of attribute arguments.
  def arguments; end

  # GraphQL::Batch depends on this
  def execution_context; end

  # Returns the value of attribute field.
  def field; end

  # Returns the value of attribute irep_node.
  def irep_node; end

  # Returns the value of attribute parent_type.
  def parent_type; end

  # Returns the value of attribute query.
  def query; end

  def result; end

  # Returns the value of attribute target.
  def target; end

  private

  # After getting the value from the field's resolve method,
  # continue by "finishing" the value, eg. executing sub-fields or coercing values
  def get_finished_value(raw_value); end

  # Get the result of:
  # - Any middleware on this schema
  # - The field's resolve method
  # If the middleware chain returns a GraphQL::ExecutionError, its message
  # is added to the "errors" key.
  def get_raw_value; end
end

module GraphQL::Query::SerialExecution::OperationResolution
  class << self
    def resolve(selection, target, query); end
  end
end

module GraphQL::Query::SerialExecution::SelectionResolution
  class << self
    def resolve(target, current_type, selection, query_ctx); end
  end
end

module GraphQL::Query::SerialExecution::ValueResolution
  class << self
    def resolve(parent_type, field_defn, field_type, value, selection, query_ctx); end
  end
end

# Contain the validation pipeline and expose the results.
#
# 0. Checks in {Query#initialize}:
#   - Rescue a ParseError, halt if there is one
#   - Check for selected operation, halt if not found
# 1. Validate the AST, halt if errors
# 2. Validate the variables, halt if errors
# 3. Run query analyzers, halt if errors
#
# {#valid?} is false if any of the above checks halted the pipeline.
#
# @api private
class GraphQL::Query::ValidationPipeline
  # @api private
  # @return [ValidationPipeline] a new instance of ValidationPipeline
  def initialize(query:, validate:, parse_error:, operation_name_error:, max_depth:, max_complexity:); end

  # @api private
  def analyzers; end

  # @api private
  # @return [Hash<String, nil => GraphQL::InternalRepresentation::Node] Operation name -] Irep node pairs
  def internal_representation; end

  # @api private
  def max_complexity; end

  # @api private
  def max_depth; end

  # @api private
  # @return [Boolean] does this query have errors that should prevent it from running?
  def valid?; end

  # @api private
  # @return [Array<GraphQL::StaticValidation::Error, GraphQL::Query::VariableValidationError>] Static validation errors for the query string
  def validation_errors; end

  private

  # If there are max_* values, add them,
  # otherwise reuse the schema's list of analyzers.
  #
  # @api private
  def build_analyzers(schema, max_depth, max_complexity); end

  # If the pipeline wasn't run yet, run it.
  # If it was already run, do nothing.
  #
  # @api private
  def ensure_has_validated; end
end

class GraphQL::Query::VariableValidationError < ::GraphQL::ExecutionError
  # @return [VariableValidationError] a new instance of VariableValidationError
  def initialize(variable_ast, type, value, validation_result); end

  def to_h; end

  # Returns the value of attribute validation_result.
  def validation_result; end

  # Sets the attribute validation_result
  #
  # @param value the value to set the attribute validation_result to.
  def validation_result=(_arg0); end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  def value=(_arg0); end

  private

  def problem_fields; end
end

# Read-only access to query variables, applying default values if needed.
class GraphQL::Query::Variables
  extend ::Forwardable

  # @return [Variables] a new instance of Variables
  def initialize(ctx, ast_variables, provided_variables); end

  def [](*args, **_arg1, &block); end

  # Returns the value of attribute context.
  def context; end

  # @return [Array<GraphQL::Query::VariableValidationError>] Any errors encountered when parsing the provided variables and literal values
  def errors; end

  def fetch(*args, **_arg1, &block); end
  def key?(*args, **_arg1, &block); end
  def length(*args, **_arg1, &block); end
  def to_h(*args, **_arg1, &block); end
end

class GraphQL::Railtie < ::Rails::Railtie; end
module GraphQL::Relay; end

class GraphQL::Relay::ArrayConnection < ::GraphQL::Relay::BaseConnection
  def cursor_from_node(item); end
  def first; end
  def has_next_page; end
  def has_previous_page; end
  def last; end

  private

  def index_from_cursor(cursor); end

  # apply first / last limit results
  def paged_nodes; end

  # Apply cursors to edges
  def sliced_nodes; end
end

# Subclasses must implement:
#   - {#cursor_from_node}, which returns an opaque cursor for the given item
#   - {#sliced_nodes}, which slices by `before` & `after`
#   - {#paged_nodes}, which applies `first` & `last` limits
#
# In a subclass, you have access to
#   - {#nodes}, the collection which the connection will wrap
#   - {#first}, {#after}, {#last}, {#before} (arguments passed to the field)
#   - {#max_page_size} (the specified maximum page size that can be returned from a connection)
class GraphQL::Relay::BaseConnection
  # Make a connection, wrapping `nodes`
  #
  # @param nodes [Object] The collection of nodes
  # @param arguments [GraphQL::Query::Arguments] Query arguments
  # @param field [GraphQL::Field] The underlying field
  # @param max_page_size [Int] The maximum number of results to return
  # @param parent [Object] The object which this collection belongs to
  # @param context [GraphQL::Query::Context] The context from the field being resolved
  # @return [BaseConnection] a new instance of BaseConnection
  def initialize(nodes, arguments, field: T.unsafe(nil), max_page_size: T.unsafe(nil), parent: T.unsafe(nil), context: T.unsafe(nil)); end

  # The value passed as `after:`, if there was one
  #
  # @return [String, nil]
  def after; end

  # Returns the value of attribute arguments.
  def arguments; end

  # The value passed as `before:`, if there was one
  #
  # @return [String, nil]
  def before; end

  # Returns the value of attribute context.
  def context; end

  # An opaque operation which returns a connection-specific cursor.
  #
  # @raise [GraphQL::RequiredImplementationMissingError]
  def cursor_from_node(object); end

  def decode(data); end

  # These are the nodes to render for this connection,
  # probably wrapped by {GraphQL::Relay::Edge}
  def edge_nodes; end

  def encode(data); end

  # Used by `pageInfo`
  def end_cursor; end

  # Returns the value of attribute field.
  def field; end

  # The value passed as `first:`, if there was one. Negative numbers become `0`.
  #
  # @return [Integer, nil]
  def first; end

  # Used by `pageInfo`
  def has_next_page; end

  # Used by `pageInfo`
  def has_previous_page; end

  def inspect; end

  # The value passed as `last:`, if there was one. Negative numbers become `0`.
  #
  # @return [Integer, nil]
  def last; end

  # Returns the value of attribute max_page_size.
  def max_page_size; end

  # Returns the value of attribute nodes.
  def nodes; end

  # Support the `pageInfo` field
  def page_info; end

  # Returns the value of attribute parent.
  def parent; end

  # Used by `pageInfo`
  def start_cursor; end

  private

  # @param argument [nil, Integer] `first` or `last`, as provided by the client
  # @param max_page_size [nil, Integer]
  # @return [nil, Integer] `nil` if the input was `nil`, otherwise a value between `0` and `max_page_size`
  def limit_pagination_argument(argument, max_page_size); end

  # @raise [GraphQL::RequiredImplementationMissingError]
  def paged_nodes; end

  # @raise [GraphQL::RequiredImplementationMissingError]
  def sliced_nodes; end

  class << self
    # Find a connection implementation suitable for exposing `nodes`
    #
    # @param nodes [Object] A collection of nodes (eg, Array, AR::Relation)
    # @return [subclass of BaseConnection] a connection Class for wrapping `nodes`
    def connection_for_nodes(nodes); end

    # Add `connection_class` as the connection wrapper for `nodes_class`
    # eg, `RelationConnection` is the implementation for `AR::Relation`
    #
    # @param nodes_class [Class] A class representing a collection (eg, Array, AR::Relation)
    # @param connection_class [Class] A class implementing Connection methods
    def register_connection_implementation(nodes_class, connection_class); end
  end
end

# Map of collection class names -> connection_classes
# eg `{"Array" => ArrayConnection}`
GraphQL::Relay::BaseConnection::CONNECTION_IMPLEMENTATIONS = T.let(T.unsafe(nil), Hash)

# Just to encode data in the cursor, use something that won't conflict
GraphQL::Relay::BaseConnection::CURSOR_SEPARATOR = T.let(T.unsafe(nil), String)

# Provided a GraphQL field which returns a collection of nodes,
# wrap that field to expose those nodes as a connection.
#
# The original resolve proc is used to fetch nodes,
# then a connection implementation is fetched with {BaseConnection.connection_for_nodes}.
module GraphQL::Relay::ConnectionInstrumentation
  class << self
    def default_arguments; end

    # Build a connection field from a {GraphQL::Field} by:
    # - Merging in the default arguments
    # - Transforming its resolve function to return a connection object
    def instrument(type, field); end
  end
end

class GraphQL::Relay::ConnectionResolve
  # @return [ConnectionResolve] a new instance of ConnectionResolve
  def initialize(field, underlying_resolve); end

  def call(obj, args, ctx); end

  private

  def build_connection(nodes, args, parent, ctx); end
end

# @api deprecated
module GraphQL::Relay::ConnectionType
  class << self
    # @api deprecated
    def bidirectional_pagination; end

    # @api deprecated
    # @return [Boolean] If true, connections check for reverse-direction `has*Page` values
    def bidirectional_pagination=(new_setting); end

    # @api deprecated
    def create_type(wrapped_type, edge_type: T.unsafe(nil), edge_class: T.unsafe(nil), nodes_field: T.unsafe(nil), &block); end

    # @api deprecated
    def default_nodes_field; end

    # @api deprecated
    # @return [Boolean] If true, connection types get a `nodes` shortcut field
    def default_nodes_field=(new_setting); end
  end
end

# Mostly an internal concern.
#
# Wraps an object as a `node`, and exposes a connection-specific `cursor`.
class GraphQL::Relay::Edge
  # @return [Edge] a new instance of Edge
  def initialize(node, connection); end

  # Returns the value of attribute connection.
  def connection; end

  def cursor; end
  def inspect; end

  # Returns the value of attribute node.
  def node; end

  def parent; end
end

module GraphQL::Relay::EdgeType
  class << self
    # @api deprecated
    def create_type(wrapped_type, name: T.unsafe(nil), &block); end
  end
end

module GraphQL::Relay::EdgesInstrumentation
  class << self
    def instrument(type, field); end
  end
end

class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
  # @return [EdgesResolve] a new instance of EdgesResolve
  def initialize(edge_class:, resolve:); end

  # A user's custom Connection may return a lazy object,
  # if so, handle it later.
  def call(obj, args, ctx); end
end

class GraphQL::Relay::GlobalIdResolve
  # @return [GlobalIdResolve] a new instance of GlobalIdResolve
  def initialize(type:); end

  def call(obj, args, ctx); end
end

# A connection implementation to expose MongoDB collection objects.
# It works for:
# - `Mongoid::Criteria`
class GraphQL::Relay::MongoRelationConnection < ::GraphQL::Relay::RelationConnection
  private

  def limit_nodes(sliced_nodes, limit); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

# @api deprecated
class GraphQL::Relay::Mutation
  include ::GraphQL::Define::InstanceDefinable
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods

  # @api deprecated
  # @return [Mutation] a new instance of Mutation
  def initialize; end

  # @api deprecated
  def arguments; end

  # @api deprecated
  def arguments=(_arg0); end

  # @api deprecated
  def description; end

  # @api deprecated
  def description=(_arg0); end

  # @api deprecated
  def field; end

  # @api deprecated
  def fields; end

  # @api deprecated
  def fields=(_arg0); end

  # @api deprecated
  # @return [Boolean]
  def has_generated_return_type?; end

  # @api deprecated
  def input_fields; end

  # @api deprecated
  def input_type; end

  # @api deprecated
  def name; end

  # @api deprecated
  def name=(_arg0); end

  # @api deprecated
  def resolve=(new_resolve_proc); end

  # @api deprecated
  def result_class; end

  # For backwards compat, but do we need this separate API?
  #
  # @api deprecated
  def return_fields; end

  # @api deprecated
  def return_interfaces; end

  # @api deprecated
  def return_interfaces=(_arg0); end

  # @api deprecated
  def return_type; end

  # @api deprecated
  def return_type=(_arg0); end
end

# @api private
module GraphQL::Relay::Mutation::Instrumentation
  class << self
    # Modify mutation `return_field` resolves by wrapping the returned object
    # in a {Mutation::Result}.
    #
    # By using an instrumention, we can apply our wrapper _last_,
    # giving users access to the original resolve function in earlier instrumentation.
    #
    # @api private
    def instrument(type, field); end
  end
end

# Wrap a user-provided resolve function,
# wrapping the returned value in a {Mutation::Result}.
# Also, pass the `clientMutationId` to that result object.
#
# @api private
class GraphQL::Relay::Mutation::Resolve
  # @api private
  # @return [Resolve] a new instance of Resolve
  def initialize(mutation, resolve); end

  # @api private
  def call(obj, args, ctx); end

  private

  # @api private
  def build_result(mutation_result, args, ctx); end
end

# Use this when the mutation's return type was generated from `return_field`s.
# It delegates field lookups to the hash returned from `resolve`.
#
# @api private
class GraphQL::Relay::Mutation::Result
  # @api private
  # @return [Result] a new instance of Result
  def initialize(client_mutation_id:, result:); end

  # @api private
  def client_mutation_id; end

  class << self
    # Build a subclass whose instances have a method
    # for each of `mutation_defn`'s `return_field`s
    #
    # @api private
    # @param mutation_defn [GraphQL::Relay::Mutation]
    # @return [Class]
    def define_subclass(mutation_defn); end

    # @api private
    def mutation; end

    # @api private
    def mutation=(_arg0); end
  end
end

# Helpers for working with Relay-specific Node objects.
module GraphQL::Relay::Node
  class << self
    # @return [GraphQL::Field] a field for finding objects by their global ID.
    def field(**kwargs, &block); end

    # @return [GraphQL::InterfaceType] The interface which all Relay types must implement
    def interface; end

    def plural_field(**kwargs, &block); end
  end
end

# Wrap a Connection and expose its page info
GraphQL::Relay::PageInfo = T.let(T.unsafe(nil), GraphQL::ObjectType)

# This provides some isolation from `GraphQL::Relay` internals.
#
# Given a list of items and a new item, it will provide a connection and an edge.
#
# The connection doesn't receive outside arguments, so the list of items
# should be ordered and paginated before providing it here.
#
# @example Adding a comment to list of comments
#   post = Post.find(args[:post_id])
#   comments = post.comments
#   new_comment = comments.build(body: args[:body])
#   new_comment.save!
#
#   range_add = GraphQL::Relay::RangeAdd.new(
#   parent: post,
#   collection: comments,
#   item: new_comment,
#   context: context,
#   )
#
#   response = {
#   post: post,
#   comments_connection: range_add.connection,
#   new_comment_edge: range_add.edge,
#   }
class GraphQL::Relay::RangeAdd
  # @param collection [Object] The list of items to wrap in a connection
  # @param item [Object] The newly-added item (will be wrapped in `edge_class`)
  # @param parent [Object] The owner of `collection`, will be passed to the connection if provided
  # @param context [GraphQL::Query::Context] The surrounding `ctx`, will be passed to the connection if provided (this is required for cursor encoders)
  # @param edge_class [Class] The class to wrap `item` with (defaults to the connection's edge class)
  # @return [RangeAdd] a new instance of RangeAdd
  def initialize(collection:, item:, parent: T.unsafe(nil), context: T.unsafe(nil), edge_class: T.unsafe(nil)); end

  # Returns the value of attribute connection.
  def connection; end

  # Returns the value of attribute edge.
  def edge; end

  # Returns the value of attribute parent.
  def parent; end
end

# A connection implementation to expose SQL collection objects.
# It works for:
# - `ActiveRecord::Relation`
# - `Sequel::Dataset`
class GraphQL::Relay::RelationConnection < ::GraphQL::Relay::BaseConnection
  def cursor_from_node(item); end
  def first; end
  def has_next_page; end
  def has_previous_page; end
  def last; end

  private

  def limit_nodes(sliced_nodes, limit); end
  def offset_from_cursor(cursor); end

  # apply first / last limit results
  #
  # @return [Array]
  def paged_nodes; end

  def paged_nodes_offset; end

  # If a relation contains a `.group` clause, a `.count` will return a Hash.
  def relation_count(relation); end

  def relation_limit(relation); end
  def relation_offset(relation); end

  # Apply cursors to edges
  def sliced_nodes; end

  def sliced_nodes_count; end
end

# Mixin for Relay-related methods in type objects
# (used by BaseType and Schema::Member).
module GraphQL::Relay::TypeExtensions
  # @return [GraphQL::ObjectType] The default connection type for this object type
  def connection_type; end

  # Define a custom connection type for this object type
  #
  # @return [GraphQL::ObjectType]
  def define_connection(**kwargs, &block); end

  # Define a custom edge type for this object type
  #
  # @return [GraphQL::ObjectType]
  def define_edge(**kwargs, &block); end

  # @return [GraphQL::ObjectType] The default edge type for this object type
  def edge_type; end
end

class GraphQL::RequiredImplementationMissingError < ::GraphQL::Error; end

# forwards-compat for argument handling
module GraphQL::Ruby2Keywords; end

class GraphQL::RuntimeTypeError < ::GraphQL::Error; end
GraphQL::STRING_TYPE = T.let(T.unsafe(nil), GraphQL::ScalarType)

# @api deprecated
class GraphQL::ScalarType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  # @api deprecated
  # @return [ScalarType] a new instance of ScalarType
  def initialize; end

  # @api deprecated
  def coerce=(proc); end

  # @api deprecated
  def coerce_input=(coerce_input_fn); end

  # @api deprecated
  def coerce_result(value, ctx = T.unsafe(nil)); end

  # @api deprecated
  def coerce_result=(coerce_result_fn); end

  # @api deprecated
  def kind; end

  private

  # @api deprecated
  def coerce_non_null_input(value, ctx); end

  # @api deprecated
  def ensure_two_arg(callable, method_name); end

  # @api deprecated
  def raw_coercion_input(value); end

  # @api deprecated
  def validate_non_null_input(value, ctx); end
end

# @api deprecated
module GraphQL::ScalarType::NoOpCoerce
  class << self
    # @api deprecated
    def call(val, ctx); end
  end
end

# A GraphQL schema which may be queried with {GraphQL::Query}.
#
# The {Schema} contains:
#
#  - types for exposing your application
#  - query analyzers for assessing incoming queries (including max depth & max complexity restrictions)
#  - execution strategies for running incoming queries
#
# Schemas start with root types, {Schema#query}, {Schema#mutation} and {Schema#subscription}.
# The schema will traverse the tree of fields & types, using those as starting points.
# Any undiscoverable types may be provided with the `types` configuration.
#
# Schemas can restrict large incoming queries with `max_depth` and `max_complexity` configurations.
# (These configurations can be overridden by specific calls to {Schema#execute})
#
# Schemas can specify how queries should be executed against them.
# `query_execution_strategy`, `mutation_execution_strategy` and `subscription_execution_strategy`
# each apply to corresponding root types.
#  #
#
# @example defining a schema
#   class MySchema < GraphQL::Schema
#   query QueryType
#   # If types are only connected by way of interfaces, they must be added here
#   orphan_types ImageType, AudioType
#   end
class GraphQL::Schema
  include ::GraphQL::Define::InstanceDefinable
  include ::GraphQL::Schema::LazyHandlingMethods
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Define::InstanceDefinable::ClassMethods
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::LazyHandlingMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  # @return [Schema] a new instance of Schema
  def initialize; end

  # Can't delegate to `class`
  def _schema_class; end

  # @return [Boolean]
  def accessible?(member, context); end

  # Returns the value of attribute analysis_engine.
  def analysis_engine; end

  # Sets the attribute analysis_engine
  #
  # @param value the value to set the attribute analysis_engine to.
  def analysis_engine=(_arg0); end

  # Return the Hash response of {Introspection::INTROSPECTION_QUERY}.
  #
  # @param context [Hash]
  # @param only [<#call(member, ctx)>]
  # @param except [<#call(member, ctx)>]
  # @return [Hash] GraphQL result
  def as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  #
  # @param value the value to set the attribute ast_node to.
  def ast_node=(_arg0); end

  # Given this schema member, find the class-based definition object
  # whose `method_name` should be treated as an application hook
  #
  # @see {.visible?}
  # @see {.accessible?}
  def call_on_type_class(member, method_name, context, default:); end

  # This is a compatibility hack so that instance-level and class-level
  # methods can get correctness checks without calling one another
  #
  # @api private
  def check_resolved_type(type, object, ctx = T.unsafe(nil)); end

  # Returns the value of attribute connections.
  def connections; end

  # Sets the attribute connections
  #
  # @param value the value to set the attribute connections to.
  def connections=(_arg0); end

  # @return [Class] Instantiated for each query
  # @see {GraphQL::Query::Context} The parent class of these classes
  def context_class; end

  # @return [Class] Instantiated for each query
  # @see {GraphQL::Query::Context} The parent class of these classes
  def context_class=(_arg0); end

  # Returns the value of attribute cursor_encoder.
  def cursor_encoder; end

  # Sets the attribute cursor_encoder
  #
  # @param value the value to set the attribute cursor_encoder to.
  def cursor_encoder=(_arg0); end

  def dataloader_class; end
  def default_filter; end

  # @return [<#call(member, ctx)>] A callable for filtering members of the schema
  # @see {Query.new} for query-specific filters with `except:`
  def default_mask; end

  # @return [<#call(member, ctx)>] A callable for filtering members of the schema
  # @see {Query.new} for query-specific filters with `except:`
  def default_mask=(_arg0); end

  # Returns the value of attribute default_max_page_size.
  def default_max_page_size; end

  # Sets the attribute default_max_page_size
  #
  # @param value the value to set the attribute default_max_page_size to.
  def default_max_page_size=(_arg0); end

  def deprecated_define(**kwargs, &block); end
  def directive(*args, **_arg1, &block); end

  # Returns the value of attribute directives.
  def directives; end

  # Sets the attribute directives
  #
  # @param value the value to set the attribute directives to.
  def directives=(_arg0); end

  # [Boolean] True if this object disables the introspection entry point fields
  def disable_introspection_entry_points; end

  # [Boolean] True if this object disables the introspection entry point fields
  def disable_introspection_entry_points=(_arg0); end

  # @return [Boolean]
  def disable_introspection_entry_points?; end

  # [Boolean] True if this object disables the __schema introspection entry point field
  def disable_schema_introspection_entry_point; end

  # [Boolean] True if this object disables the __schema introspection entry point field
  def disable_schema_introspection_entry_point=(_arg0); end

  # @return [Boolean]
  def disable_schema_introspection_entry_point?; end

  # [Boolean] True if this object disables the __type introspection entry point field
  def disable_type_introspection_entry_point; end

  # [Boolean] True if this object disables the __type introspection entry point field
  def disable_type_introspection_entry_point=(_arg0); end

  # @return [Boolean]
  def disable_type_introspection_entry_point?; end

  # [Boolean] True if this object bubbles validation errors up from a field into its parent InputObject, if there is one.
  def error_bubbling; end

  # [Boolean] True if this object bubbles validation errors up from a field into its parent InputObject, if there is one.
  def error_bubbling=(_arg0); end

  def error_handler(*args, **_arg1, &block); end

  # Execute a query on itself. Raises an error if the schema definition is invalid.
  #
  # @return [Hash] query result, ready to be serialized as JSON
  # @see {Query#initialize} for arguments.
  def execute(query_str = T.unsafe(nil), **kwargs); end

  def execution_strategy_for_operation(operation); end

  # Search for a schema member using a string path
  # Schema.find("Ensemble.musicians")
  #
  # @example Finding a Field
  # @param path [String] A dot-separated path to the member
  # @raise [Schema::Finder::MemberNotFoundError] if path could not be found
  # @return [GraphQL::BaseType, GraphQL::Field, GraphQL::Argument, GraphQL::Directive] A GraphQL Schema Member
  # @see {GraphQL::Schema::Finder} for more examples
  def find(path); end

  # Resolve field named `field_name` for type `parent_type`.
  # Handles dynamic fields `__typename`, `__type` and `__schema`, too
  #
  # @param parent_type [String, GraphQL::BaseType]
  # @param field_name [String]
  # @return [GraphQL::Field, nil] The field named `field_name` on `parent_type`
  # @see [GraphQL::Schema::Warden] Restricted access to members of a schema
  def get_field(parent_type, field_name); end

  # Fields for this type, after instrumentation is applied
  #
  # @return [Hash<String, GraphQL::Field>]
  def get_fields(type); end

  def get_type(type_name); end

  # For forwards-compatibility with Schema classes
  def graphql_definition; end

  # Get a unique identifier from this object
  #
  # @param object [Any] An application object
  # @param type [GraphQL::BaseType] The current type definition
  # @param ctx [GraphQL::Query::Context] the context for the current query
  # @return [String] a unique identifier for `object` which clients can use to refetch it
  def id_from_object(object, type, ctx); end

  # @param new_proc [#call] A new callable for generating unique IDs
  def id_from_object=(new_proc); end

  # Returns the value of attribute id_from_object_proc.
  def id_from_object_proc; end

  def inaccessible_fields(*args, **_arg1, &block); end
  def inspect; end

  # Attach `instrumenter` to this schema for instrumenting events of `instrumentation_type`.
  #
  # @param instrumentation_type [Symbol]
  # @param instrumenter
  # @return [void]
  def instrument(instrumentation_type, instrumenter); end

  # Returns the value of attribute instrumenters.
  def instrumenters; end

  # Sets the attribute instrumenters
  #
  # @param value the value to set the attribute instrumenters to.
  def instrumenters=(_arg0); end

  # @return [Boolean] True if using the new {GraphQL::Execution::Interpreter}
  def interpreter?; end

  # Returns the value of attribute introspection_namespace.
  def introspection_namespace; end

  # Sets the attribute introspection_namespace
  #
  # @param value the value to set the attribute introspection_namespace to.
  def introspection_namespace=(_arg0); end

  # @api private
  def introspection_system; end

  # Returns the value of attribute lazy_methods.
  def lazy_methods; end

  # Sets the attribute lazy_methods
  #
  # @param value the value to set the attribute lazy_methods to.
  def lazy_methods=(_arg0); end

  # Returns the value of attribute max_complexity.
  def max_complexity; end

  # Sets the attribute max_complexity
  #
  # @param value the value to set the attribute max_complexity to.
  def max_complexity=(_arg0); end

  # Returns the value of attribute max_depth.
  def max_depth; end

  # Sets the attribute max_depth
  #
  # @param value the value to set the attribute max_depth to.
  def max_depth=(_arg0); end

  # @return [MiddlewareChain] MiddlewareChain which is applied to fields during execution
  def middleware; end

  # @return [MiddlewareChain] MiddlewareChain which is applied to fields during execution
  def middleware=(_arg0); end

  # Execute several queries on itself. Raises an error if the schema definition is invalid.
  #
  # @example Run several queries at once
  #   context = { ... }
  #   queries = [
  #   { query: params[:query_1], variables: params[:variables_1], context: context },
  #   { query: params[:query_2], variables: params[:variables_2], context: context },
  #   ]
  #   results = MySchema.multiplex(queries)
  #   render json: {
  #   result_1: results[0],
  #   result_2: results[1],
  #   }
  # @param queries [Array<Hash>] Keyword arguments for each query
  # @param context [Hash] Multiplex-level context
  # @return [Array<Hash>] One result for each query in the input
  # @see {Query#initialize} for query keyword arguments
  # @see {Execution::Multiplex#run_queries} for multiplex keyword arguments
  def multiplex(queries, **kwargs); end

  # Returns the value of attribute multiplex_analyzers.
  def multiplex_analyzers; end

  # Sets the attribute multiplex_analyzers
  #
  # @param value the value to set the attribute multiplex_analyzers to.
  def multiplex_analyzers=(_arg0); end

  # Returns the value of attribute mutation.
  def mutation; end

  # Sets the attribute mutation
  #
  # @param value the value to set the attribute mutation to.
  def mutation=(_arg0); end

  # Returns the value of attribute mutation_execution_strategy.
  def mutation_execution_strategy; end

  # Sets the attribute mutation_execution_strategy
  #
  # @param value the value to set the attribute mutation_execution_strategy to.
  def mutation_execution_strategy=(_arg0); end

  # @return [Boolean]
  def new_connections?; end

  # Fetch an application object by its unique id
  #
  # @param id [String] A unique identifier, provided previously by this GraphQL schema
  # @param ctx [GraphQL::Query::Context] The context for the current query
  # @return [Any] The application object identified by `id`
  def object_from_id(id, ctx); end

  # @param new_proc [#call] A new callable for fetching objects by ID
  def object_from_id=(new_proc); end

  # Returns the value of attribute object_from_id_proc.
  def object_from_id_proc; end

  # Returns the value of attribute orphan_types.
  def orphan_types; end

  # Sets the attribute orphan_types
  #
  # @param value the value to set the attribute orphan_types to.
  def orphan_types=(_arg0); end

  # A function to call when {#execute} receives an invalid query string
  #
  # @param err [GraphQL::ParseError] The error encountered during parsing
  # @param ctx [GraphQL::Query::Context] The context for the query where the error occurred
  # @return void
  # @see {DefaultParseError} is the default behavior.
  def parse_error(err, ctx); end

  # @param new_proc [#call] A new callable for handling parse errors during execution
  def parse_error=(new_proc); end

  # @param type_defn [GraphQL::InterfaceType, GraphQL::UnionType] the type whose members you want to retrieve
  # @param context [GraphQL::Query::Context] The context for the current query
  # @return [Array<GraphQL::ObjectType>] types which belong to `type_defn` in this schema
  # @see [GraphQL::Schema::Warden] Restricted access to members of a schema
  def possible_types(type_defn, context = T.unsafe(nil)); end

  # Returns the value of attribute query.
  def query; end

  # Sets the attribute query
  #
  # @param value the value to set the attribute query to.
  def query=(_arg0); end

  # Returns the value of attribute query_analyzers.
  def query_analyzers; end

  # Sets the attribute query_analyzers
  #
  # @param value the value to set the attribute query_analyzers to.
  def query_analyzers=(_arg0); end

  # Returns the value of attribute query_execution_strategy.
  def query_execution_strategy; end

  # Sets the attribute query_execution_strategy
  #
  # @param value the value to set the attribute query_execution_strategy to.
  def query_execution_strategy=(_arg0); end

  # Returns the value of attribute raise_definition_error.
  def raise_definition_error; end

  # Sets the attribute raise_definition_error
  #
  # @param value the value to set the attribute raise_definition_error to.
  def raise_definition_error=(_arg0); end

  # Returns a list of Arguments and Fields referencing a certain type
  #
  # @param type_name [String]
  # @return [Hash]
  def references_to(type_name = T.unsafe(nil)); end

  def remove_handler(*args, &block); end
  def rescue_from(*args, &block); end

  # Determine the GraphQL type for a given object.
  # This is required for unions and interfaces (including Relay's `Node` interface)
  #
  # @param type [GraphQL::UnionType, GraphQL:InterfaceType] the abstract type which is being resolved
  # @param object [Any] An application object which GraphQL is currently resolving on
  # @param ctx [GraphQL::Query::Context] The context for the current query
  # @return [GraphQL::ObjectType] The type for exposing `object` in GraphQL
  # @see [GraphQL::Schema::Warden] Restricted access to members of a schema
  def resolve_type(type, object, ctx = T.unsafe(nil)); end

  def resolve_type=(new_resolve_type_proc); end

  # Returns the value of attribute resolve_type_proc.
  def resolve_type_proc; end

  # @return [GraphQL::ObjectType, nil]
  # @see [GraphQL::Schema::Warden] Restricted access to root types
  def root_type_for_operation(operation); end

  # @return [Array<GraphQL::BaseType>] The root types of this schema
  def root_types; end

  # Returns the value of attribute static_validator.
  def static_validator; end

  # Returns the value of attribute subscription.
  def subscription; end

  # Sets the attribute subscription
  #
  # @param value the value to set the attribute subscription to.
  def subscription=(_arg0); end

  # Returns the value of attribute subscription_execution_strategy.
  def subscription_execution_strategy; end

  # Sets the attribute subscription_execution_strategy
  #
  # @param value the value to set the attribute subscription_execution_strategy to.
  def subscription_execution_strategy=(_arg0); end

  # Single, long-lived instance of the provided subscriptions class, if there is one.
  #
  # @return [GraphQL::Subscriptions]
  def subscriptions; end

  # Single, long-lived instance of the provided subscriptions class, if there is one.
  #
  # @return [GraphQL::Subscriptions]
  def subscriptions=(_arg0); end

  # Return the GraphQL IDL for the schema
  #
  # @param context [Hash]
  # @param only [<#call(member, ctx)>]
  # @param except [<#call(member, ctx)>]
  # @return [String]
  def to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  # Return the GraphQL::Language::Document IDL AST for the schema
  #
  # @param context [Hash]
  # @param only [<#call(member, ctx)>]
  # @param except [<#call(member, ctx)>]
  # @return [GraphQL::Language::Document]
  def to_document(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  # Returns the JSON response of {Introspection::INTROSPECTION_QUERY}.
  #
  # @return [String]
  # @see {#as_json}
  def to_json(*args); end

  # @return [Array<#trace(key, data)>] Tracers applied to every query
  # @see {Query#tracers} for query-specific tracers
  def tracers; end

  # When we encounter a type error during query execution, we call this hook.
  #
  # You can use this hook to write a log entry,
  # add a {GraphQL::ExecutionError} to the response (with `ctx.add_error`)
  # or raise an exception and halt query execution.
  #
  # @example A `nil` is encountered by a non-null field
  #   type_error ->(err, query_ctx) {
  #   err.is_a?(GraphQL::InvalidNullError) # => true
  #   }
  # @example An object doesn't resolve to one of a {UnionType}'s members
  #   type_error ->(err, query_ctx) {
  #   err.is_a?(GraphQL::UnresolvedTypeError) # => true
  #   }
  # @param err [GraphQL::TypeError] The error encountered during execution
  # @param ctx [GraphQL::Query::Context] The context for the field where the error occurred
  # @return void
  # @see {DefaultTypeError} is the default behavior.
  def type_error(err, ctx); end

  # @param new_proc [#call] A new callable for handling type errors during execution
  def type_error=(new_proc); end

  def type_from_ast(ast_node, context:); end

  # @return [GraphQL::Schema::TypeMap] `{ name => type }` pairs of types in this schema
  # @see [GraphQL::Schema::Warden] Restricted access to members of a schema
  def types; end

  def unauthorized_field(*args, **_arg1, &block); end
  def unauthorized_object(*args, **_arg1, &block); end

  # Returns a list of Union types in which a type is a member
  #
  # @param type [GraphQL::ObjectType]
  # @return [Array<GraphQL::UnionType>] list of union types of which the type is a member
  def union_memberships(type); end

  # @return [Boolean]
  def using_ast_analysis?; end

  def validate(*args, **_arg1, &block); end

  # Returns the value of attribute validate_max_errors.
  def validate_max_errors; end

  # Sets the attribute validate_max_errors
  #
  # @param value the value to set the attribute validate_max_errors to.
  def validate_max_errors=(_arg0); end

  # Returns the value of attribute validate_timeout.
  def validate_timeout; end

  # Sets the attribute validate_timeout
  #
  # @param value the value to set the attribute validate_timeout to.
  def validate_timeout=(_arg0); end

  # @return [Boolean]
  def visible?(member, context); end

  protected

  # Lazily create a middleware and add it to the schema
  # (Don't add it if it's not used)
  def rescue_middleware; end

  # @return [Boolean]
  def rescues?; end

  private

  def initialize_copy(other); end
  def rebuild_artifacts; end
  def with_definition_error_check; end

  class << self
    # @return [Boolean]
    def accessible?(member, ctx); end

    # @api private
    def add_subscription_extension_if_necessary; end

    def analysis_engine; end

    # Sets the attribute analysis_engine
    #
    # @param value the value to set the attribute analysis_engine to.
    def analysis_engine=(_arg0); end

    # Return the Hash response of {Introspection::INTROSPECTION_QUERY}.
    #
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @return [Hash] GraphQL result
    def as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

    # @return [GraphQL::Pagination::Connections] if installed
    def connections; end

    # @api private
    def connections=(_arg0); end

    def context_class(new_context_class = T.unsafe(nil)); end
    def cursor_encoder(new_encoder = T.unsafe(nil)); end

    # @api private
    # @see GraphQL::Dataloader
    def dataloader_class; end

    # Sets the attribute dataloader_class
    #
    # @param value the value to set the attribute dataloader_class to.
    def dataloader_class=(_arg0); end

    def default_analysis_engine; end
    def default_directives; end
    def default_execution_strategy; end

    # Sets the attribute default_execution_strategy
    #
    # @param value the value to set the attribute default_execution_strategy to.
    def default_execution_strategy=(_arg0); end

    def default_filter; end
    def default_mask(new_mask = T.unsafe(nil)); end
    def default_max_page_size(new_default_max_page_size = T.unsafe(nil)); end
    def deprecated_graphql_definition; end

    # @return [String, nil]
    def description(new_description = T.unsafe(nil)); end

    # Attach a single directive to this schema
    #
    # @param new_directive [Class]
    # @return void
    def directive(new_directive); end

    # Add several directives at once
    #
    # @param new_directives [Class]
    def directives(*new_directives); end

    def disable_introspection_entry_points; end

    # @return [Boolean]
    def disable_introspection_entry_points?; end

    def disable_schema_introspection_entry_point; end

    # @return [Boolean]
    def disable_schema_introspection_entry_point?; end

    def disable_type_introspection_entry_point; end

    # @return [Boolean]
    def disable_type_introspection_entry_point?; end

    def error_bubbling(new_error_bubbling = T.unsafe(nil)); end

    # Sets the attribute error_bubbling
    #
    # @param value the value to set the attribute error_bubbling to.
    def error_bubbling=(_arg0); end

    # @return [GraphQL::Execution::Errors]
    def error_handler; end

    # Execute a query on itself.
    #
    # @return [Hash] query result, ready to be serialized as JSON
    # @see {Query#initialize} for arguments.
    def execute(query_str = T.unsafe(nil), **kwargs); end

    def execution_strategy_for_operation(*args, **_arg1, &block); end
    def find(path); end

    # Create schema from an IDL schema or file containing an IDL definition.
    #
    # @param definition_or_path [String] A schema definition string, or a path to a file containing the definition
    # @param default_resolve [<#call(type, field, obj, args, ctx)>] A callable for handling field resolution
    # @param parser [Object] An object for handling definition string parsing (must respond to `parse`)
    # @param using [Hash] Plugins to attach to the created schema with `use(key, value)`
    # @return [Class] the schema described by `document`
    def from_definition(definition_or_path, default_resolve: T.unsafe(nil), parser: T.unsafe(nil), using: T.unsafe(nil)); end

    # Create schema with the result of an introspection query.
    #
    # @param introspection_result [Hash] A response from {GraphQL::Introspection::INTROSPECTION_QUERY}
    # @return [GraphQL::Schema] the schema described by `input`
    def from_introspection(introspection_result); end

    def get_field(type_or_name, field_name, context = T.unsafe(nil)); end
    def get_fields(type, context = T.unsafe(nil)); end

    # @param type_name [String]
    # @return [Module, nil] A type, or nil if there's no type called `type_name`
    def get_type(type_name, context = T.unsafe(nil)); end

    def graphql_definition(silence_deprecation_warning: T.unsafe(nil)); end

    # @raise [GraphQL::RequiredImplementationMissingError]
    def id_from_object(object, type, ctx); end

    def id_from_object=(*args, **_arg1, &block); end
    def id_from_object_proc(*args, **_arg1, &block); end

    # This hook is called when a client tries to access one or more
    # fields that fail the `accessible?` check.
    #
    # By default, an error is added to the response. Override this hook to
    # track metrics or return a different error to the client.
    #
    # @param error [InaccessibleFieldsError] The analysis error for this check
    # @return [AnalysisError, nil] Return an error to skip the query
    def inaccessible_fields(error); end

    def inherited(child_class); end
    def instrument(instrument_step, instrumenter, options = T.unsafe(nil)); end
    def instrumenters; end

    # Sets the attribute interpreter
    #
    # @param value the value to set the attribute interpreter to.
    def interpreter=(_arg0); end

    # @return [Boolean]
    def interpreter?; end

    def introspection(new_introspection_namespace = T.unsafe(nil)); end
    def introspection_system; end
    def lazy_resolve(lazy_class, value_method); end
    def max_complexity(max_complexity = T.unsafe(nil)); end

    # Sets the attribute max_complexity
    #
    # @param value the value to set the attribute max_complexity to.
    def max_complexity=(_arg0); end

    def max_depth(new_max_depth = T.unsafe(nil)); end

    # Sets the attribute max_depth
    #
    # @param value the value to set the attribute max_depth to.
    def max_depth=(_arg0); end

    def metadata(*args, **_arg1, &block); end
    def middleware(new_middleware = T.unsafe(nil)); end

    # Execute several queries on itself, concurrently.
    #
    # @example Run several queries at once
    #   context = { ... }
    #   queries = [
    #   { query: params[:query_1], variables: params[:variables_1], context: context },
    #   { query: params[:query_2], variables: params[:variables_2], context: context },
    #   ]
    #   results = MySchema.multiplex(queries)
    #   render json: {
    #   result_1: results[0],
    #   result_2: results[1],
    #   }
    # @param queries [Array<Hash>] Keyword arguments for each query
    # @param context [Hash] Multiplex-level context
    # @return [Array<Hash>] One result for each query in the input
    # @see {Query#initialize} for query keyword arguments
    # @see {Execution::Multiplex#run_queries} for multiplex keyword arguments
    def multiplex(queries, **kwargs); end

    def multiplex_analyzer(new_analyzer); end
    def multiplex_analyzers; end
    def mutation(new_mutation_object = T.unsafe(nil)); end
    def mutation_execution_strategy(new_mutation_execution_strategy = T.unsafe(nil)); end

    # @return [Boolean]
    def new_connections?; end

    # @raise [GraphQL::RequiredImplementationMissingError]
    def object_from_id(node_id, ctx); end

    def object_from_id=(*args, **_arg1, &block); end
    def object_from_id_proc(*args, **_arg1, &block); end
    def orphan_types(*new_orphan_types); end

    # A function to call when {#execute} receives an invalid query string
    #
    # The default is to add the error to `context.errors`
    #
    # @param err [GraphQL::ParseError] The error encountered during parsing
    # @param ctx [GraphQL::Query::Context] The context for the query where the error occurred
    # @return void
    def parse_error(parse_err, ctx); end

    def plugins; end

    # @param type [Module] The type definition whose possible types you want to see
    # @return [Hash<String, Module>] All possible types, if no `type` is given.
    # @return [Array<Module>] Possible types for `type`, if it's given.
    def possible_types(type = T.unsafe(nil), context = T.unsafe(nil)); end

    def query(new_query_object = T.unsafe(nil)); end
    def query_analyzer(new_analyzer); end
    def query_analyzers; end
    def query_execution_strategy(new_query_execution_strategy = T.unsafe(nil)); end
    def query_stack_error(query, err); end
    def redefine(*args, **_arg1, &block); end
    def references_to(to_type = T.unsafe(nil), from: T.unsafe(nil)); end
    def remove_handler(*args, **_arg1, &block); end
    def rescue_from(*err_classes, &handler_block); end
    def resolve_type(type, obj, ctx); end

    # @return [GraphQL::ObjectType, nil]
    # @see [GraphQL::Schema::Warden] Restricted access to root types
    def root_type_for_operation(operation); end

    def root_types; end
    def sanitized_printer(new_sanitized_printer = T.unsafe(nil)); end
    def static_validator; end
    def subscription(new_subscription_object = T.unsafe(nil)); end
    def subscription_execution_strategy(new_subscription_execution_strategy = T.unsafe(nil)); end

    # @return [GraphQL::Subscriptions]
    def subscriptions; end

    # @return [GraphQL::Subscriptions]
    def subscriptions=(_arg0); end

    # Return the GraphQL IDL for the schema
    #
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @return [String]
    def to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

    # Return the GraphQL::Language::Document IDL AST for the schema
    #
    # @return [GraphQL::Language::Document]
    def to_document; end

    def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end

    # Returns the JSON response of {Introspection::INTROSPECTION_QUERY}.
    #
    # @return [String]
    # @see {#as_json}
    def to_json(**args); end

    def tracer(new_tracer); end
    def tracers; end
    def type_error(type_err, ctx); end
    def type_from_ast(ast_node, context: T.unsafe(nil)); end

    # Build a map of `{ name => type }` and return it
    #
    # @return [Hash<String => Class>] A dictionary of type classes by their GraphQL name
    # @see get_type Which is more efficient for finding _one type_ by name, because it doesn't merge hashes.
    def types(context = T.unsafe(nil)); end

    # This hook is called when a field fails an `authorized?` check.
    #
    # By default, this hook implements the same behavior as unauthorized_object.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized field . If an error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    #
    # @param unauthorized_error [GraphQL::UnauthorizedFieldError]
    # @return [Field] The returned field will be put in the GraphQL response
    def unauthorized_field(unauthorized_error); end

    # This hook is called when an object fails an `authorized?` check.
    # You might report to your bug tracker here, so you can correct
    # the field resolvers not to return unauthorized objects.
    #
    # By default, this hook just replaces the unauthorized object with `nil`.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized object (accessible as `unauthorized_error.object`). If an
    # error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    #
    # @param unauthorized_error [GraphQL::UnauthorizedError]
    # @return [Object] The returned object will be put in the GraphQL response
    def unauthorized_object(unauthorized_error); end

    def union_memberships(type = T.unsafe(nil)); end
    def use(plugin, **kwargs); end

    # @return [Boolean]
    def using_ast_analysis?; end

    # Validate a query string according to this schema.
    #
    # @param string_or_document [String, GraphQL::Language::Nodes::Document]
    # @return [Array<GraphQL::StaticValidation::Error >]
    def validate(string_or_document, rules: T.unsafe(nil), context: T.unsafe(nil)); end

    def validate_max_errors(new_validate_max_errors = T.unsafe(nil)); end

    # Sets the attribute validate_max_errors
    #
    # @param value the value to set the attribute validate_max_errors to.
    def validate_max_errors=(_arg0); end

    def validate_timeout(new_validate_timeout = T.unsafe(nil)); end

    # Sets the attribute validate_timeout
    #
    # @param value the value to set the attribute validate_timeout to.
    def validate_timeout=(_arg0); end

    # @return [Boolean]
    def visible?(member, ctx); end

    private

    # @param t [Module, Array<Module>]
    # @return [void]
    def add_type_and_traverse(t, root:); end

    def all_middleware; end
    def lazy_methods; end
    def non_introspection_types; end
    def own_directives; end
    def own_instrumenters; end
    def own_middleware; end
    def own_multiplex_analyzers; end
    def own_orphan_types; end
    def own_plugins; end
    def own_possible_types; end
    def own_query_analyzers; end
    def own_tracers; end
    def own_types; end
    def own_union_memberships; end
  end
end

class GraphQL::Schema::Addition
  # @return [Addition] a new instance of Addition
  def initialize(schema:, own_types:, new_types:); end

  # Returns the value of attribute arguments_with_default_values.
  def arguments_with_default_values; end

  # Returns the value of attribute directives.
  def directives; end

  # Returns the value of attribute possible_types.
  def possible_types; end

  # Returns the value of attribute references.
  def references; end

  # Returns the value of attribute types.
  def types; end

  # Returns the value of attribute union_memberships.
  def union_memberships; end

  private

  def add_directives_from(owner); end
  def add_type(type, owner:, late_types:, path:); end
  def add_type_and_traverse(new_types); end

  # Lookup using `own_types` here because it's ok to override
  # inherited types by name
  def get_local_type(name); end

  def get_type(name); end
  def references_to(thing, from:); end
  def update_type_owner(owner, type); end
end

class GraphQL::Schema::Argument
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods

  # @param arg_name [Symbol]
  # @param type_expr
  # @param desc [String]
  # @param required [Boolean, :nullable] if true, this argument is non-null; if false, this argument is nullable. If `:nullable`, then the argument must be provided, though it may be `null`.
  # @param description [String]
  # @param default_value [Object]
  # @param as [Symbol] Override the keyword name when passed to a method
  # @param prepare [Symbol] A method to call to transform this argument's valuebefore sending it to field resolution
  # @param camelize [Boolean] if true, the name will be camelized when building the schema
  # @param from_resolver [Boolean] if true, a Resolver class defined this argument
  # @param method_access [Boolean] If false, don't build method access on legacy {Query::Arguments} instances.
  # @param directives [Hash{Class => Hash}]
  # @param deprecation_reason [String]
  # @param validates [Hash, nil] Options for building validators, if any should be applied
  # @param replace_null_with_default [Boolean] if `true`, incoming values of `null` will be replaced with the configured `default_value`
  # @return [Argument] a new instance of Argument
  def initialize(*args, **kwargs, &block); end

  # @return [Boolean]
  def accessible?(context); end

  # @return [Boolean]
  def authorized?(obj, value, ctx); end

  # @return [Boolean]
  def authorized_as_type?(obj, value, ctx, as_type:); end

  # @api private
  def coerce_into_values(parent_object, values, context, argument_values); end

  # @return [Object] the value used when the client doesn't provide a value for this argument
  def default_value; end

  # @return [Boolean] True if this argument has a default value
  def default_value?; end

  # @return [String] Deprecation reason for this argument
  def deprecation_reason(text = T.unsafe(nil)); end

  def deprecation_reason=(new_reason); end

  # @return [String] Documentation for this argument
  def description(text = T.unsafe(nil)); end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  def description=(_arg0); end

  # @return [Boolean] true if a resolver defined this argument
  def from_resolver?; end

  # @return [String] the GraphQL name for this argument, camelized unless `camelize: false` is provided
  def graphql_name; end

  def inspect; end

  # @return [Symbol] This argument's name in Ruby keyword arguments
  def keyword; end

  def load_and_authorize_value(load_method_owner, coerced_value, context); end

  # @return [Class, Module, nil] If this argument should load an application object, this is the type of object to load
  def loads; end

  # @return [String] the GraphQL name for this argument, camelized unless `camelize: false` is provided
  def name; end

  # @return [GraphQL::Schema::Field, Class] The field or input object this argument belongs to
  def owner; end

  # @return [Symbol] A method to call to transform this value before sending it to field resolution method
  def prepare; end

  # Apply the {prepare} configuration to `value`, using methods from `obj`.
  # Used by the runtime.
  #
  # @api private
  def prepare_value(obj, value, context: T.unsafe(nil)); end

  # @return [Boolean]
  def replace_null_with_default?; end

  # @return [Boolean]
  def statically_coercible?; end

  def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
  def type; end
  def type=(new_type); end

  # @api private
  def validate_default_value; end

  # @return [Boolean]
  def visible?(context); end

  private

  def validate_deprecated_or_optional(null:, deprecation_reason:); end
  def validate_input_type(input_type); end
end

class GraphQL::Schema::Argument::InvalidDefaultValueError < ::GraphQL::Error
  # @return [InvalidDefaultValueError] a new instance of InvalidDefaultValueError
  def initialize(argument); end
end

GraphQL::Schema::Argument::NO_DEFAULT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::BUILT_IN_TYPES = T.let(T.unsafe(nil), Hash)

# @api private
module GraphQL::Schema::Base64Encoder
  class << self
    # @api private
    def decode(encoded_text, nonce: T.unsafe(nil)); end

    # @api private
    def encode(unencoded_text, nonce: T.unsafe(nil)); end
  end
end

module GraphQL::Schema::BuildFromDefinition
  class << self
    # @see {Schema.from_definition}
    def from_definition(definition_string, parser: T.unsafe(nil), **kwargs); end

    def from_definition_path(definition_path, parser: T.unsafe(nil), **kwargs); end
    def from_document(document, default_resolve:, using: T.unsafe(nil), relay: T.unsafe(nil)); end
  end
end

# @api private
module GraphQL::Schema::BuildFromDefinition::Builder
  extend ::GraphQL::Schema::BuildFromDefinition::Builder

  # @api private
  def args_to_kwargs(arg_owner, node); end

  # @api private
  # @raise [InvalidDocumentError]
  def build(document, default_resolve:, relay:, using: T.unsafe(nil)); end

  # @api private
  def build_arguments(type_class, arguments, type_resolver); end

  # @api private
  def build_default_value(default_value); end

  # @api private
  def build_definition_from_node(definition, type_resolver, default_resolve); end

  # @api private
  def build_deprecation_reason(directives); end

  # @api private
  def build_directive(directive_definition, type_resolver); end

  # @api private
  def build_directives(definition, ast_node, type_resolver); end

  # @api private
  def build_enum_type(enum_type_definition, type_resolver); end

  # @api private
  def build_fields(owner, field_definitions, type_resolver, default_resolve:); end

  # @api private
  def build_input_object_type(input_object_type_definition, type_resolver); end

  # @api private
  def build_interface_type(interface_type_definition, type_resolver); end

  # @api private
  def build_object_type(object_type_definition, type_resolver); end

  # @api private
  def build_resolve_type(lookup_hash, directives, missing_type_handler); end

  # @api private
  def build_scalar_type(scalar_type_definition, type_resolver, default_resolve:); end

  # @api private
  def build_scalar_type_coerce_method(scalar_class, method_name, default_definition_resolve); end

  # @api private
  def build_union_type(union_type_definition, type_resolver); end

  # @api private
  def prepare_directives(ast_node, type_resolver); end

  # Modify `types`, replacing any late-bound references to built-in types
  # with their actual definitions.
  #
  # (Schema definitions are allowed to reference those built-ins without redefining them.)
  #
  # @api private
  # @return void
  def replace_late_bound_types_with_built_in(types); end

  # @api private
  def resolve_type_name(type); end
end

# @api private
GraphQL::Schema::BuildFromDefinition::Builder::NO_DEFAULT_VALUE = T.let(T.unsafe(nil), Hash)

# @api private
GraphQL::Schema::BuildFromDefinition::Builder::NullResolveType = T.let(T.unsafe(nil), Proc)

# Wrap a user-provided hash of resolution behavior for easy access at runtime.
#
# Coerce scalar values by:
# - Checking for a function in the map like `{ Date: { coerce_input: ->(val, ctx) { ... }, coerce_result: ->(val, ctx) { ... } } }`
# - Falling back to a passthrough
#
# Interface/union resolution can be provided as a `resolve_type:` key.
#
# @api private
class GraphQL::Schema::BuildFromDefinition::ResolveMap
  # @api private
  # @return [ResolveMap] a new instance of ResolveMap
  def initialize(user_resolve_hash); end

  # @api private
  def call(type, field, obj, args, ctx); end

  # @api private
  def coerce_input(type, value, ctx); end

  # @api private
  def coerce_result(type, value, ctx); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
  # @return [DefaultResolve] a new instance of DefaultResolve
  def initialize(field_map, field_name); end

  # Make some runtime checks about
  # how `obj` implements the `field_name`.
  #
  # Create a new resolve function according to that implementation, then:
  #   - update `field_map` with this implementation
  #   - call the implementation now (to satisfy this field execution)
  #
  # If `obj` doesn't implement `field_name`, raise an error.
  def call(obj, args, ctx); end
end

# @api private
module GraphQL::Schema::BuildFromDefinition::ResolveMap::NullScalarCoerce
  class << self
    # @api private
    def call(val, _ctx); end
  end
end

# In early GraphQL versions, errors would be "automatically"
# rescued and replaced with `"Internal error"`. That behavior
# was undesirable but this middleware is offered for people who
# want to preserve it.
#
# It has a couple of differences from the previous behavior:
#
# - Other parts of the query _will_ be run (previously,
#   execution would stop when the error was raised and the result
#   would have no `"data"` key at all)
# - The entry in {Query::Context#errors} is a {GraphQL::ExecutionError}, _not_
#   the originally-raised error.
# - The entry in the `"errors"` key includes the location of the field
#   which raised the errors.
#
# @example Use CatchallMiddleware with your schema
#   # All errors will be suppressed and replaced with "Internal error" messages
#   MySchema.middleware << GraphQL::Schema::CatchallMiddleware
module GraphQL::Schema::CatchallMiddleware
  class << self
    # Rescue any error and replace it with a {GraphQL::ExecutionError}
    # whose message is {MESSAGE}
    def call(parent_type, parent_object, field_definition, field_args, query_context); end
  end
end

GraphQL::Schema::CatchallMiddleware::MESSAGE = T.let(T.unsafe(nil), String)
class GraphQL::Schema::CyclicalDefinitionError < ::GraphQL::Error; end
GraphQL::Schema::DYNAMIC_FIELDS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::DefaultParseError
  class << self
    def call(parse_error, ctx); end
  end
end

module GraphQL::Schema::DefaultTypeError
  class << self
    def call(type_error, ctx); end
  end
end

# Subclasses of this can influence how {GraphQL::Execution::Interpreter} runs queries.
#
# - {.include?}: if it returns `false`, the field or fragment will be skipped altogether, as if it were absent
# - {.resolve}: Wraps field resolution (so it should call `yield` to continue)
class GraphQL::Schema::Directive < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  # @return [Directive] a new instance of Directive
  def initialize(owner, **arguments); end

  # @return [GraphQL::Interpreter::Arguments]
  def arguments; end

  def graphql_name; end

  # @return [GraphQL::Schema::Field, GraphQL::Schema::Argument, Class, Module]
  def owner; end

  private

  def assert_has_location(location); end
  def assert_valid_owner; end

  class << self
    def default_directive(new_default_directive = T.unsafe(nil)); end

    # @return [Boolean]
    def default_directive?; end

    # Return a name based on the class name,
    # but downcase the first letter.
    def default_graphql_name; end

    # If false, this part of the query won't be evaluated
    #
    # @return [Boolean]
    def include?(_object, arguments, context); end

    def locations(*new_locations); end

    # @return [Boolean]
    def on_field?; end

    # @return [Boolean]
    def on_fragment?; end

    # @return [Boolean]
    def on_operation?; end

    def path; end
    def repeatable(new_value); end

    # @return [Boolean]
    def repeatable?; end

    # Continuing is passed as a block; `yield` to continue
    def resolve(object, arguments, context); end

    # Continuing is passed as a block, yield to continue.
    def resolve_each(object, arguments, context); end

    # Determines whether {Execution::Lookahead} considers the field to be selected
    #
    # @return [Boolean]
    def static_include?(_arguments, _context); end

    def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
  end
end

GraphQL::Schema::Directive::ARGUMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::DEFAULT_DEPRECATION_REASON = T.let(T.unsafe(nil), String)

class GraphQL::Schema::Directive::Deprecated < ::GraphQL::Schema::Directive
  class << self
    def load_reason(value, _context = T.unsafe(nil)); end
  end
end

GraphQL::Schema::Directive::ENUM = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::ENUM_VALUE = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FIELD = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FRAGMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FRAGMENT_SPREAD = T.let(T.unsafe(nil), Symbol)

# An example directive to show how you might interact with the runtime.
#
# This directive might be used along with a server-side feature flag system like Flipper.
#
# With that system, you could use this directive to exclude parts of a query
# if the current viewer doesn't have certain flags enabled.
# (So, this flag would be for internal clients, like your iOS app, not third-party API clients.)
#
# To use it, you have to implement `.enabled?`, for example:
#
# @example Implementing the Feature directive
#   # app/graphql/directives/feature.rb
#   class Directives::Feature < GraphQL::Schema::Directive::Feature
#   def self.enabled?(flag_name, _obj, context)
#   # Translate some GraphQL data for Ruby:
#   flag_key = flag_name.underscore
#   current_user = context[:viewer]
#   # Check the feature flag however your app does it:
#   MyFeatureFlags.enabled?(current_user, flag_key)
#   end
#   end
# @example Flagging a part of the query
#   viewer {
#   # This field only runs if `.enabled?("recommendationEngine", obj, context)`
#   # returns true. Otherwise, it's treated as if it didn't exist.
#   recommendations @feature(flag: "recommendationEngine") {
#   name
#   rating
#   }
#   }
class GraphQL::Schema::Directive::Feature < ::GraphQL::Schema::Directive
  class << self
    # Override this method in your app's subclass of this directive.
    #
    # @param flag_name [String] The client-provided string of a feature to check
    # @param object [GraphQL::Schema::Objct] The currently-evaluated GraphQL object instance
    # @param context [GraphQL::Query::Context]
    # @raise [GraphQL::RequiredImplementationMissingError]
    # @return [Boolean] If truthy, execution will continue
    def enabled?(flag_name, object, context); end

    # Implement the Directive API
    #
    # @return [Boolean]
    def include?(object, arguments, context); end

    def load_flag(value, _context = T.unsafe(nil)); end
  end
end

# This is _similar_ to {Directive::Feature}, except it's prescribed by the server, not the client.
#
# In this case, the server hides types and fields _entirely_, unless the current context has certain `:flags` present.
class GraphQL::Schema::Directive::Flagged < ::GraphQL::Schema::Directive
  # @return [Flagged] a new instance of Flagged
  def initialize(target, **options); end

  class << self
    def load_by(value, _context = T.unsafe(nil)); end
  end
end

module GraphQL::Schema::Directive::Flagged::VisibleByFlag
  # @return [Boolean]
  def visible?(context); end

  class << self
    # @private
    def included(schema_class); end
  end
end

GraphQL::Schema::Directive::INLINE_FRAGMENT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INPUT_FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INPUT_OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INTERFACE = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Include < ::GraphQL::Schema::Directive
  class << self
    def load_if(value, _context = T.unsafe(nil)); end

    # @return [Boolean]
    def static_include?(args, ctx); end
  end
end

GraphQL::Schema::Directive::LOCATIONS = T.let(T.unsafe(nil), Array)
GraphQL::Schema::Directive::LOCATION_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
GraphQL::Schema::Directive::MUTATION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::QUERY = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SCALAR = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SCHEMA = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SUBSCRIPTION = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Skip < ::GraphQL::Schema::Directive
  class << self
    def load_if(value, _context = T.unsafe(nil)); end

    # @return [Boolean]
    def static_include?(args, ctx); end
  end
end

# An example directive to show how you might interact with the runtime.
#
# This directive takes the return value of the tagged part of the query,
# and if the named transform is whitelisted and applies to the return value,
# it's applied by calling a method with that name.
#
# @example Installing the directive
#   class MySchema < GraphQL::Schema
#   directive(GraphQL::Schema::Directive::Transform)
#   end
# @example Transforming strings
#   viewer {
#   username @transform(by: "upcase")
#   }
class GraphQL::Schema::Directive::Transform < ::GraphQL::Schema::Directive
  class << self
    def load_by(value, _context = T.unsafe(nil)); end

    # Implement the Directive API
    def resolve(object, arguments, context); end
  end
end

GraphQL::Schema::Directive::Transform::TRANSFORMS = T.let(T.unsafe(nil), Array)
GraphQL::Schema::Directive::UNION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::VARIABLE_DEFINITION = T.let(T.unsafe(nil), Symbol)
class GraphQL::Schema::DuplicateNamesError < ::GraphQL::Error; end

class GraphQL::Schema::DuplicateTypeNamesError < ::GraphQL::Error
  # @return [DuplicateTypeNamesError] a new instance of DuplicateTypeNamesError
  def initialize(type_name:, first_definition:, second_definition:, path:); end
end

class GraphQL::Schema::Enum < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  class << self
    # @return [Array<Schema::EnumValue>] An unfiltered list of all definitions
    def all_enum_value_definitions; end

    def coerce_input(value_name, ctx); end
    def coerce_result(value, ctx); end

    # @return [Class] for handling `value(...)` inputs and building `GraphQL::Enum::EnumValue`s out of them
    def enum_value_class(new_enum_value_class = T.unsafe(nil)); end

    # @return [Array<GraphQL::Schema::EnumValue>] Possible values of this enum
    def enum_values(context = T.unsafe(nil)); end

    # @private
    def inherited(child_class); end

    def kind; end

    # @return [GraphQL::EnumType]
    def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end

    def validate_non_null_input(value_name, ctx); end

    # Define a value for this enum
    #
    # @param graphql_name [String, Symbol] the GraphQL value for this, usually `SCREAMING_CASE`
    # @param description [String] , the GraphQL description for this value, present in documentation
    # @param value [Object] , the translated Ruby value for this object (defaults to `graphql_name`)
    # @param deprecation_reason [String] if this object is deprecated, include a message here
    # @return [void]
    # @see {Schema::EnumValue} which handles these inputs by default
    def value(*args, **kwargs, &block); end

    # @return [Hash<String => GraphQL::Schema::EnumValue>] Possible values of this enum, keyed by name.
    def values(context = T.unsafe(nil)); end

    private

    def own_values; end
  end
end

class GraphQL::Schema::Enum::UnresolvedValueError < ::GraphQL::EnumType::UnresolvedValueError
  # @return [UnresolvedValueError] a new instance of UnresolvedValueError
  def initialize(value:, enum:, context:); end
end

# A possible value for an {Enum}.
#
# You can extend this class to customize enum values in your schema.
#
# @example custom enum value class
#   # define a custom class:
#   class CustomEnumValue < GraphQL::Schema::EnumValue
#   def initialize(*args)
#   # arguments to `value(...)` in Enum classes are passed here
#   super
#   end
#
#   def to_graphql
#   enum_value = super
#   # customize the derived GraphQL::EnumValue here
#   enum_value
#   end
#   end
#
#   class BaseEnum < GraphQL::Schema::Enum
#   # use it for these enums:
#   enum_value_class CustomEnumValue
#   end
class GraphQL::Schema::EnumValue < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods

  # @return [EnumValue] a new instance of EnumValue
  def initialize(*args, **kwargs, &block); end

  # @return [Boolean]
  def accessible?(_ctx); end

  # @return [Boolean]
  def authorized?(_ctx); end

  def description(new_desc = T.unsafe(nil)); end

  # Returns the value of attribute graphql_name.
  def graphql_name; end

  def inspect; end

  # @return [Class] The enum type that owns this value
  def owner; end

  # @return [GraphQL::EnumType::EnumValue] A runtime-ready object derived from this object
  def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end

  def value(new_val = T.unsafe(nil)); end

  # @return [Boolean]
  def visible?(_ctx); end
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::HasValidators
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # @param name [Symbol] The underscore-cased version of this field name (will be camelized for the GraphQL API)
  # @param type [Class, GraphQL::BaseType, Array] The return type of this field
  # @param owner [Class] The type that this field belongs to
  # @param null [Boolean] `true` if this field may return `null`, `false` if it is never `null`
  # @param description [String] Field description
  # @param deprecation_reason [String] If present, the field is marked "deprecated" with this message
  # @param method [Symbol] The method to call on the underlying object to resolve this field (defaults to `name`)
  # @param hash_key [String, Symbol] The hash key to lookup on the underlying object (if its a Hash) to resolve this field (defaults to `name` or `name.to_s`)
  # @param dig [Array<String, Symbol>] The nested hash keys to lookup on the underlying hash to resolve this field using dig
  # @param resolver_method [Symbol] The method on the type to call to resolve this field (defaults to `name`)
  # @param connection [Boolean] `true` if this field should get automagic connection behavior; default is to infer by `*Connection` in the return type name
  # @param connection_extension [Class] The extension to add, to implement connections. If `nil`, no extension is added.
  # @param max_page_size [Integer, nil] For connections, the maximum number of items to return from this field, or `nil` to allow unlimited results.
  # @param introspection [Boolean] If true, this field will be marked as `#introspection?` and the name may begin with `__`
  # @param resolve [<#call(obj, args, ctx)>] **deprecated** for compatibility with <1.8.0
  # @param field [GraphQL::Field, GraphQL::Schema::Field] **deprecated** for compatibility with <1.8.0
  # @param function [GraphQL::Function] **deprecated** for compatibility with <1.8.0
  # @param resolver_class [Class] (Private) A {Schema::Resolver} which this field was derived from. Use `resolver:` to create a field with a resolver.
  # @param arguments [{String=>GraphQL::Schema::Argument, Hash}] Arguments for this field (may be added in the block, also)
  # @param camelize [Boolean] If true, the field name will be camelized when building the schema
  # @param complexity [Numeric] When provided, set the complexity for this field
  # @param scope [Boolean] If true, the return type's `.scope_items` method will be called on the return value
  # @param subscription_scope [Symbol, String] A key in `context` which will be used to scope subscription payloads
  # @param extensions [Array<Class, Hash<Class => Object>>] Named extensions to apply to this field (see also {#extension})
  # @param directives [Hash{Class => Hash}] Directives to apply to this field
  # @param trace [Boolean] If true, a {GraphQL::Tracing} tracer will measure this scalar field
  # @param broadcastable [Boolean] Whether or not this field can be distributed in subscription broadcasts
  # @param ast_node [Language::Nodes::FieldDefinition, nil] If this schema was parsed from definition, this AST node defined the field
  # @param method_conflict_warning [Boolean] If false, skip the warning if this field's method conflicts with a built-in method
  # @param validates [Array<Hash>] Configurations for validating this field
  # @param legacy_edge_class [Class, nil] (DEPRECATED) If present, pass this along to the legacy field definition
  # @return [Field] a new instance of Field
  def initialize(*args, **kwargs, &block); end

  # @return [Boolean]
  def accessible?(context); end

  # @return [Boolean]
  def authorized?(object, args, context); end

  # If true, subscription updates with this field can be shared between viewers
  #
  # @return [Boolean, nil]
  # @see GraphQL::Subscriptions::BroadcastAnalyzer
  def broadcastable?; end

  def calculate_complexity(query:, nodes:, child_complexity:); end
  def complexity(new_complexity = T.unsafe(nil)); end

  # Can be set with `connection: true|false` or inferred from a type name ending in `*Connection`
  #
  # @return [Boolean] if true, this field will be wrapped with Relay connection behavior
  def connection?; end

  # @param text [String]
  # @return [String]
  def description(text = T.unsafe(nil)); end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  def description=(_arg0); end

  # Add `extension` to this field, initialized with `options` if provided.
  #
  # @example adding an extension
  #   extension(MyExtensionClass)
  # @example adding an extension with options
  #   extension(MyExtensionClass, filter: true)
  # @param extension_class [Class] subclass of {Schema::FieldExtension}
  # @param options [Hash] if provided, given as `options:` when initializing `extension`.
  # @return [void]
  def extension(extension_class, options = T.unsafe(nil)); end

  # Read extension instances from this field,
  # or add new classes/options to be initialized on this field.
  # Extensions are executed in the order they are added.
  #
  # @example adding an extension
  #   extensions([MyExtensionClass])
  # @example adding multiple extensions
  #   extensions([MyExtensionClass, AnotherExtensionClass])
  # @example adding an extension with options
  #   extensions([MyExtensionClass, { AnotherExtensionClass => { filter: true } }])
  # @param extensions [Array<Class, Hash<Class => Hash>>] Add extensions to this field. For hash elements, only the first key/value is used.
  # @return [Array<GraphQL::Schema::FieldExtension>] extensions to apply to this field
  def extensions(new_extensions = T.unsafe(nil)); end

  # Read extras (as symbols) from this field,
  # or add new extras to be opted into by this field's resolver.
  #
  # @param new_extras [Array<Symbol>] Add extras to this field
  # @return [Array<Symbol>]
  def extras(new_extras = T.unsafe(nil)); end

  # @param ctx [GraphQL::Query::Context::FieldResolutionContext]
  def fetch_extra(extra_name, ctx); end

  # @return [String] the GraphQL name for this field, camelized unless `camelize: false` is provided
  def graphql_name; end

  # @return [Boolean] True if this field's {#max_page_size} should override the schema default.
  def has_max_page_size?; end

  def inspect; end

  # @return [Boolean] Is this field a predefined introspection field?
  def introspection?; end

  # @return [Integer, nil] Applied to connections if {#has_max_page_size?}
  def max_page_size; end

  # @return [Boolean] Should we warn if this field's name conflicts with a built-in method?
  def method_conflict_warning?; end

  # @return [String] Method or hash key on the underlying object to look up
  def method_str; end

  # @return [Symbol] Method or hash key on the underlying object to look up
  def method_sym; end

  # @return [Class, nil] The {Schema::Resolver} this field was derived from, if there is one
  def mutation; end

  # @return [String] the GraphQL name for this field, camelized unless `camelize: false` is provided
  def name; end

  # @return [Symbol] the original name of the field, passed in by the user
  def original_name; end

  # @return [Class] The thing this field was defined on (type, mutation, resolver)
  def owner; end

  # @return [Class] The thing this field was defined on (type, mutation, resolver)
  def owner=(_arg0); end

  # @return [Class] The GraphQL type this field belongs to. (For fields defined on mutations, it's the payload type)
  def owner_type; end

  # @return Boolean
  def relay_node_field; end

  # This method is called by the interpreter for each field.
  # You can extend it in your base field classes.
  #
  # @param object [GraphQL::Schema::Object] An instance of some type class, wrapping an application object
  # @param args [Hash] A symbol-keyed hash of Ruby keyword arguments. (Empty if no args)
  # @param ctx [GraphQL::Query::Context]
  def resolve(object, args, ctx); end

  # Implement {GraphQL::Field}'s resolve API.
  #
  # Eventually, we might hook up field instances to execution in another way. TBD.
  #
  # @see #resolve for how the interpreter hooks up to it
  def resolve_field(obj, args, ctx); end

  # @return [Class, nil] The {Schema::Resolver} this field was derived from, if there is one
  def resolver; end

  # @return [Symbol] The method on the type to look up
  def resolver_method; end

  # @return [Boolean] if true, the return type's `.scope_items` method will be applied to this field's return value
  def scoped?; end

  # @return [String, nil]
  def subscription_scope; end

  # @return [String, nil]
  def subscription_scope=(_arg0); end

  # @return [GraphQL::Field]
  def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end

  # @return [Boolean] Apply tracing to this field? (Default: skip scalars, this is the override value)
  def trace; end

  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end

  # @return [Boolean]
  def visible?(context); end

  private

  def assert_satisfactory_implementation(receiver, method_name, ruby_kwargs); end
  def public_send_field(unextended_obj, unextended_ruby_kwargs, query_ctx); end
  def run_extensions_before_resolve(obj, args, ctx, extended, idx: T.unsafe(nil)); end

  # Convert a GraphQL arguments instance into a Ruby-style hash.
  #
  # @param obj [GraphQL::Schema::Object] The object where this field is being resolved
  # @param graphql_args [GraphQL::Query::Arguments]
  # @param field_ctx [GraphQL::Query::Context::FieldResolutionContext]
  # @return [Hash<Symbol => Any>]
  def to_ruby_args(obj, graphql_args, field_ctx); end

  # Wrap execution with hooks.
  # Written iteratively to avoid big stack traces.
  #
  # @return [Object] Whatever the
  def with_extensions(obj, args, ctx); end

  class << self
    # This extension is applied to fields when {#connection?} is true.
    #
    # You can override it in your base field definition.
    #
    # @example Configuring a custom extension
    #   class Types::BaseField < GraphQL::Schema::Field
    #   connection_extension(MyCustomExtension)
    #   end
    # @return [Class] A {FieldExtension} subclass for implementing pagination behavior.
    def connection_extension(new_extension_class = T.unsafe(nil)); end

    # Create a field instance from a list of arguments, keyword arguments, and a block.
    #
    # This method implements prioritization between the `resolver` or `mutation` defaults
    # and the local overrides via other keywords.
    #
    # It also normalizes positional arguments into keywords for {Schema::Field#initialize}.
    #
    # @param resolver [Class] A {GraphQL::Schema::Resolver} class to use for field configuration
    # @param mutation [Class] A {GraphQL::Schema::Mutation} class to use for field configuration
    # @param subscription [Class] A {GraphQL::Schema::Subscription} class to use for field configuration
    # @return [GraphQL::Schema:Field] an instance of `self
    # @see {.initialize} for other options
    def from_options(name = T.unsafe(nil), type = T.unsafe(nil), desc = T.unsafe(nil), resolver: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), **kwargs, &block); end
  end
end

class GraphQL::Schema::Field::ConnectionExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(value:, object:, arguments:, context:, memo:); end
  def apply; end

  # Remove pagination args before passing it to a user method
  #
  # @yield [object, next_args, arguments]
  def resolve(object:, arguments:, context:); end
end

class GraphQL::Schema::Field::FieldImplementationFailed < ::GraphQL::Error; end
class GraphQL::Schema::Field::MissingReturnTypeError < ::GraphQL::Error; end
GraphQL::Schema::Field::NO_ARGS = T.let(T.unsafe(nil), Hash)

class GraphQL::Schema::Field::ScopeExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(object:, arguments:, context:, value:, memo:); end
end

# Extend this class to make field-level customizations to resolve behavior.
#
# When a extension is added to a field with `extension(MyExtension)`, a `MyExtension` instance
# is created, and its hooks are applied whenever that field is called.
#
# The instance is frozen so that instance variables aren't modified during query execution,
# which could cause all kinds of issues due to race conditions.
class GraphQL::Schema::FieldExtension
  # Called when the extension is mounted with `extension(name, options)`.
  # The instance will be frozen to avoid improper use of state during execution.
  #
  # @param field [GraphQL::Schema::Field] The field where this extension was mounted
  # @param options [Object] The second argument to `extension`, or `{}` if nothing was passed.
  # @return [FieldExtension] a new instance of FieldExtension
  def initialize(field:, options:); end

  # @return [Array<Symbol>, nil] `default_argument`s added, if any were added (otherwise, `nil`)
  def added_default_arguments; end

  # @api private
  def added_extras; end

  # Called after the field's definition block has been executed.
  # (Any arguments from the block are present on `field`)
  #
  # @return [void]
  def after_define; end

  # @api private
  def after_define_apply; end

  # Called after {#field} was resolved, and after any lazy values (like `Promise`s) were synced,
  # but before the value was added to the GraphQL response.
  #
  # Whatever this hook returns will be used as the return value.
  #
  # @param object [Object] The object the field is being resolved on
  # @param arguments [Hash] Ruby keyword arguments for resolving this field
  # @param context [Query::Context] the context for this query
  # @param value [Object] Whatever the field previously returned
  # @param memo [Object] The third value yielded by {#resolve}, or `nil` if there wasn't one
  # @return [Object] The return value for this field.
  def after_resolve(object:, arguments:, context:, value:, memo:); end

  # Called when this extension is attached to a field.
  # The field definition may be extended during this method.
  #
  # @return [void]
  def apply; end

  # @return [GraphQL::Schema::Field]
  def field; end

  # @return [Object]
  def options; end

  # Called before resolving {#field}. It should either:
  #
  # - `yield` values to continue execution; OR
  # - return something else to shortcut field execution.
  #
  # Whatever this method returns will be used for execution.
  #
  # @param object [Object] The object the field is being resolved on
  # @param arguments [Hash] Ruby keyword arguments for resolving this field
  # @param context [Query::Context] the context for this query
  # @return [Object] The return value for this field.
  # @yieldparam object [Object] The object to continue resolving the field on
  # @yieldparam arguments [Hash] The keyword arguments to continue resolving with
  # @yieldparam memo [Object] Any extension-specific value which will be passed to {#after_resolve} later
  def resolve(object:, arguments:, context:); end

  class << self
    # @see Argument#initialize
    # @see HasArguments#argument
    def default_argument(*argument_args, **argument_kwargs); end

    # @return [Array(Array, Hash), nil] A list of default argument configs, or `nil` if there aren't any
    def default_argument_configurations; end

    # If configured, these `extras` will be added to the field if they aren't already present,
    # but removed by from `arguments` before the field's `resolve` is called.
    # (The extras _will_ be present for other extensions, though.)
    #
    # @param new_extras [Array<Symbol>] If provided, assign extras used by this extension
    # @return [Array<Symbol>] any extras assigned to this extension
    def extras(new_extras = T.unsafe(nil)); end
  end
end

GraphQL::Schema::FieldExtension::NO_EXTRAS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  private

  def find_inherited_value(method_name, default_value = T.unsafe(nil)); end

  class << self
    # @private
    def extended(child_cls); end

    # @private
    def included(child_cls); end
  end
end

module GraphQL::Schema::FindInheritedValue::EmptyObjects; end
GraphQL::Schema::FindInheritedValue::EmptyObjects::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
GraphQL::Schema::FindInheritedValue::EmptyObjects::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Find schema members using string paths
#
# @example Finding object types
#   MySchema.find("SomeObjectType")
# @example Finding fields
#   MySchema.find("SomeObjectType.myField")
# @example Finding arguments
#   MySchema.find("SomeObjectType.myField.anArgument")
# @example Finding directives
#   MySchema.find("@include")
class GraphQL::Schema::Finder
  # @return [Finder] a new instance of Finder
  def initialize(schema); end

  def find(path); end

  private

  def find_in_directive(directive, path:); end
  def find_in_enum_type(enum_type, path:); end
  def find_in_field(field, path:); end
  def find_in_fields_type(type, kind:, path:); end
  def find_in_input_object(input_object, path:); end
  def find_in_type(type, path:); end

  # Returns the value of attribute schema.
  def schema; end
end

class GraphQL::Schema::Finder::MemberNotFoundError < ::ArgumentError; end

class GraphQL::Schema::InputObject < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Dig
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  # @return [InputObject] a new instance of InputObject
  def initialize(arguments = T.unsafe(nil), context:, defaults_used:, ruby_kwargs: T.unsafe(nil)); end

  # Lookup a key on this object, it accepts new-style underscored symbols
  # Or old-style camelized identifiers.
  #
  # @param key [Symbol, String]
  def [](key); end

  def any?(*args, **_arg1, &block); end

  # @return [GraphQL::Query::Arguments, GraphQL::Execution::Interpereter::Arguments] The underlying arguments instance
  def arguments; end

  # @return [GraphQL::Query::Context] The context for this query
  def context; end

  def each(*args, **_arg1, &block); end
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  def key?(key); end

  def keys(*args, **_arg1, &block); end
  def map(*args, **_arg1, &block); end
  def prepare; end
  def to_h; end
  def to_hash; end

  # A copy of the Ruby-style hash
  def to_kwargs; end

  def unwrap_value(value); end
  def values(*args, **_arg1, &block); end

  private

  def overwrite_argument(key, value); end

  class << self
    def argument(*args, **kwargs, &block); end

    # @return [Class<GraphQL::Arguments>]
    def arguments_class; end

    # @return [Class<GraphQL::Arguments>]
    def arguments_class=(_arg0); end

    # @return [Boolean]
    def authorized?(obj, value, ctx); end

    def coerce_input(value, ctx); end

    # It's funny to think of a _result_ of an input object.
    # This is used for rendering the default value in introspection responses.
    def coerce_result(value, ctx); end

    def kind; end
    def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
    def validate_non_null_input(input, ctx); end
  end
end

module GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::HasDirectives
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension

  def unwrap; end
end

module GraphQL::Schema::Interface::DefinitionMethods
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Relay::TypeExtensions
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::Member::TypeSystemHelpers
  include ::GraphQL::Schema::Member::HasFields
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::RelayShortcuts
  include ::GraphQL::Schema::Member::Scoped
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasUnresolvedTypeError
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasInterfaces
  include ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods

  # The interface is accessible if any of its possible types are accessible
  #
  # @return [Boolean]
  def accessible?(context); end

  # Methods defined in this block will be:
  # - Added as class methods to this interface
  # - Added as class methods to all child interfaces
  def definition_methods(&block); end

  # Here's the tricky part. Make sure behavior keeps making its way down the inheritance chain.
  def included(child_class); end

  def kind; end
  def orphan_types(*types); end
  def to_graphql(*args, **kwargs); end
  def type_membership_class(membership_class = T.unsafe(nil)); end

  # @return [Boolean]
  # @see {Schema::Warden} hides interfaces without visible implementations
  def visible?(context); end
end

class GraphQL::Schema::IntrospectionSystem
  # @return [IntrospectionSystem] a new instance of IntrospectionSystem
  def initialize(schema); end

  def dynamic_field(name:); end
  def dynamic_fields; end
  def entry_point(name:); end
  def entry_points; end

  # Returns the value of attribute possible_types.
  def possible_types; end

  # The introspection system is prepared with a bunch of LateBoundTypes.
  # Replace those with the objects that they refer to, since LateBoundTypes
  # aren't handled at runtime.
  #
  # @api private
  # @return void
  def resolve_late_bindings; end

  # Returns the value of attribute types.
  def types; end

  private

  # This is probably not 100% robust -- but it has to be good enough to avoid modifying the built-in introspection types
  def dup_type_class(type_class); end

  def get_fields_from_class(class_sym:); end
  def load_constant(class_name); end
  def resolve_late_binding(late_bound_type); end
end

class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
  # @return [PerFieldProxyResolve] a new instance of PerFieldProxyResolve
  def initialize(object_class:, inner_resolve:); end

  def call(obj, args, ctx); end
end

# Error that is raised when [#Schema#from_definition] is passed an invalid schema definition string.
class GraphQL::Schema::InvalidDocumentError < ::GraphQL::Error; end

class GraphQL::Schema::InvalidTypeError < ::GraphQL::Error; end

# A stand-in for a type which will be resolved in a given schema, by name.
# TODO: support argument types too, make this a public API somehow
#
# @api Private
class GraphQL::Schema::LateBoundType
  # @api Private
  # @return [LateBoundType] a new instance of LateBoundType
  def initialize(local_name); end

  # @api Private
  def graphql_name; end

  # @api Private
  def inspect; end

  # @api Private
  def name; end

  # @api Private
  def to_list_type; end

  # @api Private
  def to_non_null_type; end

  # @api Private
  def to_s; end

  # @api Private
  def unwrap; end
end

module GraphQL::Schema::LazyHandlingMethods
  # Return a lazy if any of `maybe_lazies` are lazy,
  # otherwise, call the block eagerly and return the result.
  #
  # @api private
  # @param maybe_lazies [Array]
  def after_any_lazies(maybe_lazies); end

  # Call the given block at the right time, either:
  # - Right away, if `value` is not registered with `lazy_resolve`
  # - After resolving `value`, if it's registered with `lazy_resolve` (eg, `Promise`)
  #
  # @api private
  def after_lazy(value, &block); end

  # @return [Boolean] True if this object should be lazily resolved
  def lazy?(obj); end

  # @return [Symbol, nil] The method name to lazily resolve `obj`, or nil if `obj`'s class wasn't registered with {#lazy_resolve}.
  def lazy_method_name(obj); end

  # Override this method to handle lazy objects in a custom way.
  #
  # @api private
  # @param value [Object] an instance of a class registered with {.lazy_resolve}
  # @return [Object] A GraphQL-ready (non-lazy) object
  def sync_lazy(value); end
end

# Represents a list type in the schema.
# Wraps a {Schema::Member} as a list type.
#
# @see {Schema::Member::TypeSystemHelpers#to_list_type}
class GraphQL::Schema::List < ::GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::ValidatesInput

  def coerce_input(value, ctx); end
  def coerce_result(value, ctx); end

  # Also for implementing introspection
  def description; end

  # This is for introspection, where it's expected the name will be `null`
  def graphql_name; end

  # @return [GraphQL::TypeKinds::LIST]
  def kind; end

  # @return [true]
  def list?; end

  def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
  def to_type_signature; end
  def validate_non_null_input(value, ctx); end

  private

  def ensure_array(value); end
end

# You can use the result of {GraphQL::Introspection::INTROSPECTION_QUERY}
# to make a schema. This schema is missing some important details like
# `resolve` functions, but it does include the full type system,
# so you can use it to validate queries.
#
# @see GraphQL::Schema.from_introspection for a public API
module GraphQL::Schema::Loader
  extend ::GraphQL::Schema::Loader

  # Create schema with the result of an introspection query.
  #
  # @param introspection_result [Hash] A response from {GraphQL::Introspection::INTROSPECTION_QUERY}
  # @return [Class] the schema described by `input`
  def load(introspection_result); end

  class << self
    def build_arguments(arg_owner, args, type_resolver); end
    def build_fields(type_defn, fields, type_resolver); end

    private

    def define_directive(directive, type_resolver); end
    def define_type(type, type_resolver); end
    def extract_default_value(default_value_str, input_value_ast); end
    def resolve_type(types, type); end
  end
end

GraphQL::Schema::Loader::NullScalarCoerce = T.let(T.unsafe(nil), Proc)

# The base class for things that make up the schema,
# eg objects, enums, scalars.
#
# @api private
class GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasDirectives
end

# Support for legacy `accepts_definitions` functions.
#
# Keep the legacy handler hooked up. Class-based types and fields
# will call those legacy handlers during their `.to_graphql`
# methods.
#
# This can help out while transitioning from one to the other.
# Eventually, `GraphQL::{X}Type` objects will be removed entirely,
# But this can help during the transition.
#
# @example Applying a function to base object class
#   # Here's the legacy-style config, which we're calling back to:
#   GraphQL::ObjectType.accepts_definition({
#   permission_level: ->(defn, value) { defn.metadata[:permission_level] = value }
#   })
#
#   class BaseObject < GraphQL::Schema::Object
#   # Setup a named pass-through to the legacy config functions
#   accepts_definition :permission_level
#   end
#
#   class Account < BaseObject
#   # This value will be passed to the legacy handler:
#   permission_level 1
#   end
#
#   # The class gets a reader method which returns the args,
#   # only marginally useful.
#   Account.permission_level # => [1]
#
#   # The legacy handler is called, as before:
#   Account.graphql_definition.metadata[:permission_level] # => 1
module GraphQL::Schema::Member::AcceptsDefinition
  mixes_in_class_methods ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods

  class << self
    # @private
    def extended(child); end

    # @private
    def included(child); end
  end
end

module GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  def accepts_definition(name); end
  def accepts_definition_methods; end
  def own_accepts_definition_methods; end
end

module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def initialize(*args, **kwargs, &block); end

  def accepts_definition_methods; end
end

module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def to_graphql(*args, **kwargs); end
end

# DSL methods shared by lots of things in the GraphQL Schema.
#
# @api private
# @see Classes that extend this, eg {GraphQL::Schema::Object}
module GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # @api private
  # @return [Boolean]
  def accessible?(context); end

  # @api private
  # @return [Boolean]
  def authorized?(object, context); end

  # Creates the default name for a schema member.
  # The default name is the Ruby constant name,
  # without any namespaces and with any `-Type` suffix removed
  #
  # @api private
  def default_graphql_name; end

  # Call this method to provide a new description; OR
  # call it without an argument to get the description
  #
  # @api private
  # @param new_description [String]
  # @return [String]
  def description(new_description = T.unsafe(nil)); end

  # Call this with a new name to override the default name for this schema member; OR
  # call it without an argument to get the name of this schema member
  #
  # The default name is implemented in default_graphql_name
  #
  # @api private
  # @param new_name [String]
  # @return [String]
  def graphql_name(new_name = T.unsafe(nil)); end

  # @api private
  # @return [Boolean] If true, this object is part of the introspection system
  def introspection(new_introspection = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def introspection?; end

  # The mutation this type was derived from, if it was derived from a mutation
  #
  # @api private
  # @return [Class]
  def mutation(mutation_class = T.unsafe(nil)); end

  # Just a convenience method to point out that people should use graphql_name instead
  #
  # @api private
  def name(new_name = T.unsafe(nil)); end

  # @api private
  def overridden_graphql_name; end

  # @api private
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [GraphQL::BaseType] Convert this type to a legacy-style object.
  def to_graphql; end

  # @api private
  def unwrap; end

  # @api private
  # @return [Boolean]
  def visible?(context); end
end

# This pushes some configurations _down_ the inheritance tree,
# in order to prevent repetitive lookups at runtime.
#
# @api private
module GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  # @api private
  def inherited(child_class); end
end

# @api private
module GraphQL::Schema::Member::BuildType
  private

  # @api private
  def camelize(string); end

  # Resolves constant from string (based on Rails `ActiveSupport::Inflector.constantize`)
  #
  # @api private
  def constantize(string); end

  # @api private
  # @param type_expr [String, Class, GraphQL::BaseType]
  # @return [GraphQL::BaseType]
  def parse_type(type_expr, null:); end

  # @api private
  def to_type_name(something); end

  # @api private
  def underscore(string); end

  class << self
    # @api private
    def camelize(string); end

    # Resolves constant from string (based on Rails `ActiveSupport::Inflector.constantize`)
    #
    # @api private
    def constantize(string); end

    # @api private
    # @param type_expr [String, Class, GraphQL::BaseType]
    # @return [GraphQL::BaseType]
    def parse_type(type_expr, null:); end

    # @api private
    def to_type_name(something); end

    # @api private
    def underscore(string); end
  end
end

# @api private
GraphQL::Schema::Member::BuildType::LIST_TYPE_ERROR = T.let(T.unsafe(nil), String)

# Adds a layer of caching over user-supplied `.to_graphql` methods.
# Users override `.to_graphql`, but all runtime code should use `.graphql_definition`.
#
# @api private
# @see concrete classes that extend this, eg {Schema::Object}
module GraphQL::Schema::Member::CachedGraphQLDefinition
  # @api private
  def deprecated_to_graphql; end

  # A cached result of {.to_graphql}.
  # It's cached here so that user-overridden {.to_graphql} implementations
  # are also cached
  #
  # @api private
  def graphql_definition(silence_deprecation_warning: T.unsafe(nil)); end

  # This is for a common interface with .define-based types
  #
  # @api private
  def type_class; end

  private

  # Wipe out the cached graphql_definition so that `.to_graphql` will be called again.
  #
  # @api private
  def initialize_copy(original); end
end

# @api private
module GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  # @api private
  def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
end

# These constants are interpreted as GraphQL types when defining fields or arguments
#
# @api private
# @example
#   field :is_draft, Boolean, null: false
#   field :id, ID, null: false
#   field :score, Int, null: false
module GraphQL::Schema::Member::GraphQLTypeNames; end

# @api private
GraphQL::Schema::Member::GraphQLTypeNames::Boolean = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Schema::Member::GraphQLTypeNames::ID = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Schema::Member::GraphQLTypeNames::Int = T.let(T.unsafe(nil), String)

module GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader

  mixes_in_class_methods ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor

  # Register this argument with the class.
  #
  # @param arg_defn [GraphQL::Schema::Argument]
  # @return [GraphQL::Schema::Argument]
  def add_argument(arg_defn); end

  def all_argument_definitions; end

  # @return [GraphQL::Schema::Argument] An instance of {arguments_class}, created from `*args`
  # @see {GraphQL::Schema::Argument#initialize} for parameters
  def argument(*args, **kwargs, &block); end

  # @param new_arg_class [Class] A class to use for building argument definitions
  def argument_class(new_arg_class = T.unsafe(nil)); end

  # @return [Hash<String => GraphQL::Schema::Argument] Arguments defined on this thing, keyed by name. Includes inherited definitions] Hash<String => GraphQL::Schema::Argument] Arguments defined on this thing, keyed by name. Includes inherited definitions
  def arguments(context = T.unsafe(nil)); end

  # @return [Boolean]
  def arguments_statically_coercible?; end

  # If given a block, it will eventually yield the loaded args to the block.
  #
  # If no block is given, it will immediately dataload (but might return a Lazy).
  #
  # @api private
  # @param values [Hash<String, Object>]
  # @param context [GraphQL::Query::Context]
  # @return [Interpreter::Arguments, Execution::Lazy<Interpeter::Arguments>]
  # @yield [Interpreter::Arguments, Execution::Lazy<Interpeter::Arguments>]
  def coerce_arguments(parent_object, values, context, &block); end

  # @return [GraphQL::Schema::Argument, nil] Argument defined on this thing, fetched by name.
  def get_argument(argument_name, context = T.unsafe(nil)); end

  def own_arguments; end

  # Usually, this is validated statically by RequiredArgumentsArePresent,
  # but not for directives.
  # TODO apply static validations on schema definitions?
  def validate_directive_argument(arg_defn, value); end

  class << self
    # @private
    def extended(cls); end

    # @private
    def included(cls); end
  end
end

module GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  def argument_class(new_arg_class = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def authorize_application_object(argument, id, context, loaded_application_object); end
  def load_and_authorize_application_object(argument, id, context); end
  def load_application_object(argument, id, context); end
  def load_application_object_failed(err); end

  # Look up the corresponding object for a provided ID.
  # By default, it uses Relay-style {Schema.object_from_id},
  # override this to find objects another way.
  #
  # @param type [Class, Module] A GraphQL type definition
  # @param id [String] A client-provided to look up
  # @param context [GraphQL::Query::Context] the current context
  def object_from_id(type, id, context); end
end

GraphQL::Schema::Member::HasArguments::NO_ARGUMENTS = T.let(T.unsafe(nil), Hash)

module GraphQL::Schema::Member::HasAstNode
  # If this schema was parsed from a `.graphql` file (or other SDL),
  # this is the AST node that defined this part of the schema.
  def ast_node(new_ast_node = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasDeprecationReason
  # @return [String, nil] Explains why this member was deprecated (if present, this will be marked deprecated in introspection)
  def deprecation_reason; end

  # Set the deprecation reason for this member, or remove it by assigning `nil`
  #
  # @param text [String, nil]
  def deprecation_reason=(text); end
end

module GraphQL::Schema::Member::HasDirectives
  # Create an instance of `dir_class` for `self`, using `options`.
  #
  # It removes a previously-attached instance of `dir_class`, if there is one.
  #
  # @return [void]
  def directive(dir_class, **options); end

  def directives; end

  # Remove an attached instance of `dir_class`, if there is one
  #
  # @param dir_class [Class<GraphQL::Schema::Directive>]
  # @return [viod]
  def remove_directive(dir_class); end

  protected

  def own_directives; end

  private

  # Modify `target` by adding items from `dirs` such that:
  # - Any name conflict is overriden by the incoming member of `dirs`
  # - Any other member of `dirs` is appended
  #
  # @param target [Array<GraphQL::Schema::Directive>]
  # @param dirs [Array<GraphQL::Schema::Directive>]
  # @return [void]
  def merge_directives(target, dirs); end
end

GraphQL::Schema::Member::HasDirectives::NO_DIRECTIVES = T.let(T.unsafe(nil), Array)

# Shared code for Objects, Interfaces, Mutations, Subscriptions
module GraphQL::Schema::Member::HasFields
  # Register this field with the class, overriding a previous one if needed.
  #
  # @param field_defn [GraphQL::Schema::Field]
  # @return [void]
  def add_field(field_defn, method_conflict_warning: T.unsafe(nil)); end

  def all_field_definitions; end

  # Add a field to this object or interface with the given definition
  #
  # @return [GraphQL::Schema::Field]
  # @see {GraphQL::Schema::Field#initialize} for method signature
  def field(*args, **kwargs, &block); end

  # @return [Class] The class to initialize when adding fields to this kind of schema member
  def field_class(new_field_class = T.unsafe(nil)); end

  # @return [Hash<String => GraphQL::Schema::Field>] Fields on this object, keyed by name, including inherited fields
  def fields(context = T.unsafe(nil)); end

  def get_field(field_name, context = T.unsafe(nil)); end
  def global_id_field(field_name, **kwargs); end

  # @return [Hash<String => GraphQL::Schema::Field, Array<GraphQL::Schema::Field>>] Fields defined on this class _specifically_, not parent classes
  def own_fields; end

  private

  # @param [GraphQL::Schema::Field]
  # @return [String] A warning to give when this field definition might conflict with a built-in method
  def conflict_field_name_warning(field_defn); end

  # If `type` is an interface, and `self` has a type membership for `type`, then make sure it's visible.
  #
  # @return [Boolean]
  def visible_interface_implementation?(type, context, warden); end
end

# A list of field names that we should advise users to pick a different
# resolve method name.
#
# @api private
GraphQL::Schema::Member::HasFields::CONFLICT_FIELD_NAMES = T.let(T.unsafe(nil), Set)

# A list of GraphQL-Ruby keywords.
#
# @api private
GraphQL::Schema::Member::HasFields::GRAPHQL_RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

# A list of Ruby keywords.
#
# @api private
GraphQL::Schema::Member::HasFields::RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::Member::HasInterfaces
  def implements(*new_interfaces, **options); end
  def interface_type_memberships; end

  # param context [Query::Context] If omitted, skip filtering.
  def interfaces(context = T.unsafe(nil)); end

  def own_interface_type_memberships; end
end

module GraphQL::Schema::Member::HasPath
  # @return [String] A description of this member's place in the GraphQL schema
  def path; end
end

# Set up a type-specific error to make debugging & bug tracker integration better
module GraphQL::Schema::Member::HasUnresolvedTypeError
  private

  def add_unresolved_type_error(child_class); end
end

module GraphQL::Schema::Member::HasValidators
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # Build {GraphQL::Schema::Validator}s based on the given configuration
  # and use them for this schema member
  #
  # @param validation_config [Hash{Symbol => Hash}]
  # @return [void]
  def validates(validation_config); end

  # @return [Array<GraphQL::Schema::Validator>]
  def validators; end
end

module GraphQL::Schema::Member::Instrumentation
  private

  def after_query(_query); end
  def apply_proxy(field); end
  def before_query(query); end
  def instrument(type, field); end
  def list_depth(type, starting_at = T.unsafe(nil)); end

  class << self
    def after_query(_query); end
    def apply_proxy(field); end
    def before_query(query); end
    def instrument(type, field); end
    def list_depth(type, starting_at = T.unsafe(nil)); end
  end
end

class GraphQL::Schema::Member::Instrumentation::ProxiedResolve
  # @return [ProxiedResolve] a new instance of ProxiedResolve
  def initialize(inner_resolve:, list_depth:, inner_return_type:); end

  def call(obj, args, ctx); end

  private

  # @return [Boolean]
  def execution_errors?(result); end

  def proxy_to_depth(inner_obj, depth, ctx); end
end

module GraphQL::Schema::Member::RelayShortcuts
  def connection_type; end
  def connection_type_class(new_connection_type_class = T.unsafe(nil)); end
  def edge_type; end
  def edge_type_class(new_edge_type_class = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::Scoped
  # This is called when a field has `scope: true`.
  # The field's return type class receives this call.
  #
  # By default, it's a no-op. Override it to scope your objects.
  #
  # @param items [Object] Some list-like object (eg, Array, ActiveRecord::Relation)
  # @param context [GraphQL::Query::Context]
  # @return [Object] Another list-like object, scoped to the current context
  def scope_items(items, context); end
end

module GraphQL::Schema::Member::TypeSystemHelpers
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [GraphQL::TypeKinds::TypeKind]
  def kind; end

  # @return [Boolean] true if this is a list type. A non-nullable list is considered a list.
  def list?; end

  # @return [Boolean] true if this is a non-nullable type. A nullable list of non-nullables is considered nullable.
  def non_null?; end

  # @return [Schema::List] Make a list-type representation of this type
  def to_list_type; end

  # @return [Schema::NonNull] Make a non-null-type representation of this type
  def to_non_null_type; end

  def to_type_signature; end
end

module GraphQL::Schema::Member::ValidatesInput
  def coerce_isolated_input(v); end
  def coerce_isolated_result(v); end

  # @return [Boolean]
  def valid_input?(val, ctx); end

  # @return [Boolean]
  def valid_isolated_input?(v); end

  def validate_input(val, ctx); end
end

# Given {steps} and {arguments}, call steps in order, passing `(*arguments, next_step)`.
#
# Steps should call `next_step.call` to continue the chain, or _not_ call it to stop the chain.
class GraphQL::Schema::MiddlewareChain
  extend ::Forwardable

  # @return [MiddlewareChain] a new instance of MiddlewareChain
  def initialize(steps: T.unsafe(nil), final_step: T.unsafe(nil)); end

  def <<(callable); end
  def ==(other); end
  def [](*args, **_arg1, &block); end
  def concat(callables); end
  def delete(*args, **_arg1, &block); end

  # @return [Array<#call(*args)>] Steps in this chain, will be called with arguments and `next_middleware`
  def final_step; end

  def first(*args, **_arg1, &block); end
  def insert(*args, **_arg1, &block); end
  def invoke(arguments); end
  def push(callable); end

  # @return [Array<#call(*args)>] Steps in this chain, will be called with arguments and `next_middleware`
  def steps; end

  private

  def add_middleware(callable); end
  def initialize_copy(other); end
  def invoke_core(index, arguments); end
  def wrap(callable); end
end

# TODO: Remove this code once deprecated middleware becomes unsupported
class GraphQL::Schema::MiddlewareChain::MiddlewareWrapper
  # @return [MiddlewareWrapper] a new instance of MiddlewareWrapper
  def initialize(callable); end

  def call(*args, &next_middleware); end

  # Returns the value of attribute callable.
  def callable; end
end

# This base class accepts configuration for a mutation root field,
# then it can be hooked up to your mutation root object type.
#
# If you want to customize how this class generates types, in your base class,
# override the various `generate_*` methods.
#
# @example Creating a comment
#   # Define the mutation:
#   class Mutations::CreateComment < GraphQL::Schema::Mutation
#   argument :body, String, required: true
#   argument :post_id, ID, required: true
#
#   field :comment, Types::Comment, null: true
#   field :errors, [String], null: false
#
#   def resolve(body:, post_id:)
#   post = Post.find(post_id)
#   comment = post.comments.build(body: body, author: context[:current_user])
#   if comment.save
#   # Successful creation, return the created object with no errors
#   {
#   comment: comment,
#   errors: [],
#   }
#   else
#   # Failed save, return the errors to the client
#   {
#   comment: nil,
#   errors: comment.errors.full_messages
#   }
#   end
#   end
#   end
#
#   # Hook it up to your mutation:
#   class Types::Mutation < GraphQL::Schema::Object
#   field :create_comment, mutation: Mutations::CreateComment
#   end
#
#   # Call it from GraphQL:
#   result = MySchema.execute <<-GRAPHQL
#   mutation {
#   createComment(postId: "1", body: "Nice Post!") {
#   errors
#   comment {
#   body
#   author {
#   login
#   }
#   }
#   }
#   }
#   GRAPHQL
# @see {GraphQL::Schema::RelayClassicMutation} for an extension of this class with some conventions built-in.
class GraphQL::Schema::Mutation < ::GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Resolver::HasPayloadType

  class << self
    # Override this method to handle legacy-style usages of `MyMutation.field`
    def field(*args, **kwargs, &block); end

    # @return [Boolean]
    def visible?(context); end

    private

    def conflict_field_name_warning(field_defn); end

    # Override this to attach self as `mutation`
    def generate_payload_type; end
  end
end

# Represents a non null type in the schema.
# Wraps a {Schema::Member} when it is required.
#
# @see {Schema::Member::TypeSystemHelpers#to_non_null_type}
class GraphQL::Schema::NonNull < ::GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  include ::GraphQL::Schema::Member::ValidatesInput

  def coerce_input(value, ctx); end
  def coerce_result(value, ctx); end

  # This is for implementing introspection
  def description; end

  # This is for introspection, where it's expected the name will be `null`
  def graphql_name; end

  def inspect; end

  # @return [GraphQL::TypeKinds::NON_NULL]
  def kind; end

  # @return [Boolean] True if this type wraps a list type
  def list?; end

  # @return [true]
  def non_null?; end

  def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
  def to_type_signature; end
  def validate_input(value, ctx); end
end

# @api private
module GraphQL::Schema::NullMask
  class << self
    # @api private
    def call(member, ctx); end
  end
end

class GraphQL::Schema::Object < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  # @return [Object] a new instance of Object
  def initialize(object, context); end

  # @return [GraphQL::Query::Context] the context instance for this query
  def context; end

  # @return [GraphQL::Dataloader]
  def dataloader; end

  # @return [Object] the application object this type is wrapping
  def object; end

  # Call this in a field method to return a value that should be returned to the client
  # without any further handling by GraphQL.
  def raw_value(obj); end

  class << self
    # Make a new instance of this type _if_ the auth check passes,
    # otherwise, raise an error.
    #
    # Probably only the framework should call this method.
    #
    # This might return a {GraphQL::Execution::Lazy} if the user-provided `.authorized?`
    # hook returns some lazy value (like a Promise).
    #
    # The reason that the auth check is in this wrapper method instead of {.new} is because
    # of how it might return a Promise. It would be weird if `.new` returned a promise;
    # It would be a headache to try to maintain Promise-y state inside a {Schema::Object}
    # instance. So, hopefully this wrapper method will do the job.
    #
    # @param object [Object] The thing wrapped by this object
    # @param context [GraphQL::Query::Context]
    # @raise [GraphQL::UnauthorizedError] if the user-provided hook returns `false`
    # @return [GraphQL::Schema::Object, GraphQL::Execution::Lazy]
    def authorized_new(object, context); end

    # @return [Hash<String => GraphQL::Schema::Field>] All of this object's fields, indexed by name
    # @see get_field A faster way to find one field by name ({#fields} merges hashes of inherited fields; {#get_field} just looks up one field.)
    def fields(context = T.unsafe(nil)); end

    # Set up a type-specific invalid null error to use when this object's non-null fields wrongly return `nil`.
    # It should help with debugging and bug tracker integrations.
    def inherited(child_class); end

    def kind; end

    # @return [GraphQL::ObjectType]
    def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
  end
end

# Find the members of a union or interface within a given schema.
#
# (Although its members never change, unions are handled this way to simplify execution code.)
#
# Internally, the calculation is cached. It's assumed that schema members _don't_ change after creating the schema!
#
# @example Get an interface's possible types
#   possible_types = GraphQL::Schema::PossibleTypes(MySchema)
#   possible_types.possible_types(MyInterface)
#   # => [MyObjectType, MyOtherObjectType]
class GraphQL::Schema::PossibleTypes
  # @return [PossibleTypes] a new instance of PossibleTypes
  def initialize(schema); end

  def interface_implementers(ctx, type_defn); end
  def possible_types(type_defn, ctx); end
end

# Used to convert your {GraphQL::Schema} to a GraphQL schema string
#
# @example print your schema to standard output (via helper)
#   puts GraphQL::Schema::Printer.print_schema(MySchema)
# @example print your schema to standard output
#   puts GraphQL::Schema::Printer.new(MySchema).print_schema
# @example print a single type to standard output
#   class Types::Query < GraphQL::Schema::Object
#   description "The query root of this schema"
#
#   field :post, Types::Post, null: true
#   end
#
#   class Types::Post < GraphQL::Schema::Object
#   description "A blog post"
#
#   field :id, ID, null: false
#   field :title, String, null: false
#   field :body, String, null: false
#   end
#
#   class MySchema < GraphQL::Schema
#   query(Types::Query)
#   end
#
#   printer = GraphQL::Schema::Printer.new(MySchema)
#   puts printer.print_type(Types::Post)
class GraphQL::Schema::Printer < ::GraphQL::Language::Printer
  # @param schema [GraphQL::Schema]
  # @param context [Hash]
  # @param only [<#call(member, ctx)>]
  # @param except [<#call(member, ctx)>]
  # @param introspection [Boolean] Should include the introspection types in the string?
  # @return [Printer] a new instance of Printer
  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), introspection: T.unsafe(nil)); end

  # Return a GraphQL schema string for the defined types in the schema
  def print_schema; end

  def print_type(type); end

  # Returns the value of attribute schema.
  def schema; end

  # Returns the value of attribute warden.
  def warden; end

  class << self
    # Return the GraphQL schema string for the introspection type system
    def print_introspection_schema; end

    # Return a GraphQL schema string for the defined types in the schema
    #
    # @param schema [GraphQL::Schema]
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    def print_schema(schema, **args); end
  end
end

class GraphQL::Schema::Printer::IntrospectionPrinter < ::GraphQL::Language::Printer
  def print_schema_definition(schema); end
end

# Mutations that extend this base class get some conventions added for free:
#
# - An argument called `clientMutationId` is _always_ added, but it's not passed
#   to the resolve method. The value is re-inserted to the response. (It's for
#   client libraries to manage optimistic updates.)
# - The returned object type always has a field called `clientMutationId` to support that.
# - The mutation accepts one argument called `input`, `argument`s defined in the mutation
#   class are added to that input object, which is generated by the mutation.
#
# These conventions were first specified by Relay Classic, but they come in handy:
#
# - `clientMutationId` supports optimistic updates and cache rollbacks on the client
# - using a single `input:` argument makes it easy to post whole JSON objects to the mutation
#   using one GraphQL variable (`$input`) instead of making a separate variable for each argument.
#
# @see {GraphQL::Schema::Mutation} for an example, it's basically the same.
class GraphQL::Schema::RelayClassicMutation < ::GraphQL::Schema::Mutation
  # Override {GraphQL::Schema::Resolver#resolve_with_support} to
  # delete `client_mutation_id` from the kwargs.
  def resolve_with_support(**inputs); end

  private

  def authorize_arguments(args, values); end

  class << self
    # Also apply this argument to the input type:
    def argument(*args, **kwargs, &block); end

    # Extend {Schema::Mutation.field_options} to add the `input` argument
    def field_options; end

    # The base class for generated input object types
    #
    # @param new_class [Class] The base class to use for generating input object definitions
    # @return [Class] The base class for this mutation's generated input object (default is {GraphQL::Schema::InputObject})
    def input_object_class(new_class = T.unsafe(nil)); end

    # @param new_input_type [Class, nil] If provided, it configures this mutation to accept `new_input_type` instead of generating an input type
    # @return [Class] The generated {Schema::InputObject} class for this mutation's `input`
    def input_type(new_input_type = T.unsafe(nil)); end

    private

    # Generate the input type for the `input:` argument
    # To customize how input objects are generated, override this method
    #
    # @return [Class] a subclass of {.input_object_class}
    def generate_input_type; end
  end
end

# - Store a table of errors & handlers
# - Rescue errors in a middleware chain, then check for a handler
# - If a handler is found, use it & return a {GraphQL::ExecutionError}
# - If no handler is found, re-raise the error
class GraphQL::Schema::RescueMiddleware
  # @return [RescueMiddleware] a new instance of RescueMiddleware
  def initialize; end

  # Implement the requirement for {GraphQL::Schema::MiddlewareChain}
  def call(*args); end

  # Remove the handler for `error_classs`
  #
  # @param error_class [Class] the error class whose handler should be removed
  def remove_handler(*error_classes); end

  # @example Rescue from not-found by telling the user
  #   MySchema.rescue_from(ActiveRecord::RecordNotFound) { "An item could not be found" }
  # @param error_classes [Class] one or more classes of errors to rescue from
  # @yield [err] A handler to return a message for these error instances
  # @yieldparam an [Exception] error that was rescued
  # @yieldreturn [String] message to put in GraphQL response
  def rescue_from(*error_classes, &block); end

  # @return [Hash] `{class => proc}` pairs for handling errors
  def rescue_table; end

  private

  def attempt_rescue(err); end
end

# A class-based container for field configuration and resolution logic. It supports:
#
# - Arguments, via `.argument(...)` helper, which will be applied to the field.
# - Return type, via `.type(..., null: ...)`, which will be applied to the field.
# - Description, via `.description(...)`, which will be applied to the field
# - Resolution, via `#resolve(**args)` method, which will be called to resolve the field.
# - `#object` and `#context` accessors for use during `#resolve`.
#
# Resolvers can be attached with the `resolver:` option in a `field(...)` call.
#
# A resolver's configuration may be overridden with other keywords in the `field(...)` call.
#
# See the {.field_options} to see how a Resolver becomes a set of field configuration options.
#
# @see {GraphQL::Schema::Mutation} for a concrete subclass of `Resolver`.
# @see {GraphQL::Function} `Resolver` is a replacement for `GraphQL::Function`
class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::HasPath

  # @param object [Object] The application object that this field is being resolved on
  # @param context [GraphQL::Query::Context]
  # @param field [GraphQL::Schema::Field]
  # @return [Resolver] a new instance of Resolver
  def initialize(object:, context:, field:); end

  def arguments; end

  # Called after arguments are loaded, but before resolving.
  #
  # Override it to check everything before calling the mutation.
  #
  # @param inputs [Hash] The input arguments
  # @raise [GraphQL::ExecutionError] To add an error to the response
  # @raise [GraphQL::UnauthorizedError] To signal an authorization failure
  # @return [Boolean, early_return_data] If `false`, execution will stop (and `early_return_data` will be returned instead, if present.)
  def authorized?(**inputs); end

  # @return [GraphQL::Query::Context]
  def context; end

  # @return [GraphQL::Dataloader]
  def dataloader; end

  # @return [GraphQL::Schema::Field]
  def field; end

  # @return [Object] The application object this field is being resolved on
  def object; end

  # Called before arguments are prepared.
  # Implement this hook to make checks before doing any work.
  #
  # If it returns a lazy object (like a promise), it will be synced by GraphQL
  # (but the resulting value won't be used).
  #
  # @param args [Hash] The input arguments, if there are any
  # @raise [GraphQL::ExecutionError] To add an error to the response
  # @raise [GraphQL::UnauthorizedError] To signal an authorization failure
  # @return [Boolean, early_return_data] If `false`, execution will stop (and `early_return_data` will be returned instead, if present.)
  def ready?(**args); end

  # Do the work. Everything happens here.
  #
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [Object] An object corresponding to the return type
  def resolve(**args); end

  # This method is _actually_ called by the runtime,
  # it does some preparation and then eventually calls
  # the user-defined `#resolve` method.
  #
  # @api private
  def resolve_with_support(**args); end

  # Called when an object loaded by `loads:` fails the `.authorized?` check for its resolved GraphQL object type.
  #
  # By default, the error is re-raised and passed along to {{Schema.unauthorized_object}}.
  #
  # Any value returned here will be used _instead of_ of the loaded object.
  #
  # @param err [GraphQL::UnauthorizedError]
  def unauthorized_object(err); end

  private

  def authorize_arguments(args, inputs); end
  def get_argument(name, context = T.unsafe(nil)); end
  def load_arguments(args); end

  class << self
    # Add an argument to this field's signature, but
    # also add some preparation hook methods which will be used for this argument
    #
    # @see {GraphQL::Schema::Argument#initialize} for the signature
    def argument(*args, **kwargs, &block); end

    def broadcastable(new_broadcastable); end

    # @return [Boolean, nil]
    def broadcastable?; end

    # Specifies the complexity of the field. Defaults to `1`
    #
    # @return [Integer, Proc]
    def complexity(new_complexity = T.unsafe(nil)); end

    # Registers new extension
    #
    # @param extension [Class] Extension class
    # @param options [Hash] Optional extension options
    def extension(extension, **options); end

    # @api private
    def extensions; end

    # Additional info injected into {#resolve}
    #
    # @see {GraphQL::Schema::Field#extras}
    def extras(new_extras = T.unsafe(nil)); end

    def field_options; end

    # @return [Boolean] `true` if this resolver or a superclass has an assigned `max_page_size`
    def has_max_page_size?; end

    # Get or set the `max_page_size:` which will be configured for fields using this resolver
    # (`nil` means "unlimited max page size".)
    #
    # @param max_page_size [Integer, nil] Set a new value
    # @return [Integer, nil] The `max_page_size` assigned to fields that use this resolver
    def max_page_size(new_max_page_size = T.unsafe(nil)); end

    # If `true` (default), then the return type for this resolver will be nullable.
    # If `false`, then the return type is non-null.
    #
    # @param allow_null [Boolean] Whether or not the response can be null
    # @see #type which sets the return type of this field and accepts a `null:` option
    def null(allow_null = T.unsafe(nil)); end

    # Default `:resolve` set below.
    #
    # @return [Symbol] The method to call on instances of this object to resolve the field
    def resolve_method(new_method = T.unsafe(nil)); end

    # Call this method to get the return type of the field,
    # or use it as a configuration method to assign a return type
    # instead of generating one.
    # TODO unify with {#null}
    #
    # @param new_type [Class, Array<Class>, nil] If a type definition class is provided, it will be used as the return type of the field
    # @param null [true, false] Whether or not the field may return `nil`
    # @return [Class] The type which this field returns.
    def type(new_type = T.unsafe(nil), null: T.unsafe(nil)); end

    # A non-normalized type configuration, without `null` applied
    def type_expr; end

    private

    def own_extensions; end
  end
end

# Adds `field(...)` helper to resolvers so that they can
# generate payload types.
#
# Or, an already-defined one can be attached with `payload_type(...)`.
module GraphQL::Schema::Resolver::HasPayloadType
  def field(*args, **kwargs, &block); end
  def field_class(new_class = T.unsafe(nil)); end

  # An object class to use for deriving return types
  #
  # @param new_class [Class, nil] Defaults to {GraphQL::Schema::Object}
  # @return [Class]
  def object_class(new_class = T.unsafe(nil)); end

  # Call this method to get the derived return type of the mutation,
  # or use it as a configuration method to assign a return type
  # instead of generating one.
  #
  # @param new_payload_type [Class, nil] If a type definition class is provided, it will be used as the return type of the mutation field
  # @return [Class] The object type which this mutation returns.
  def payload_type(new_payload_type = T.unsafe(nil)); end

  # Call this method to get the derived return type of the mutation,
  # or use it as a configuration method to assign a return type
  # instead of generating one.
  #
  # @param new_payload_type [Class, nil] If a type definition class is provided, it will be used as the return type of the mutation field
  # @return [Class] The object type which this mutation returns.
  def type(new_payload_type = T.unsafe(nil)); end

  # Call this method to get the derived return type of the mutation,
  # or use it as a configuration method to assign a return type
  # instead of generating one.
  #
  # @param new_payload_type [Class, nil] If a type definition class is provided, it will be used as the return type of the mutation field
  # @return [Class] The object type which this mutation returns.
  def type_expr(new_payload_type = T.unsafe(nil)); end

  private

  # Build a subclass of {.object_class} based on `self`.
  # This value will be cached as `{.payload_type}`.
  # Override this hook to customize return type generation.
  def generate_payload_type; end
end

GraphQL::Schema::Resolver::HasPayloadType::NO_INTERFACES = T.let(T.unsafe(nil), Array)

class GraphQL::Schema::Scalar < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  class << self
    def coerce_input(val, ctx); end
    def coerce_result(val, ctx); end
    def default_scalar(is_default = T.unsafe(nil)); end

    # @return [Boolean]
    def default_scalar?; end

    def kind; end
    def specified_by_url(new_url = T.unsafe(nil)); end
    def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
    def validate_non_null_input(value, ctx); end
  end
end

# This class can be extended to create fields on your subscription root.
#
# It provides hooks for the different parts of the subscription lifecycle:
#
# - `#authorized?`: called before initial subscription and subsequent updates
# - `#subscribe`: called for the initial subscription
# - `#update`: called for subsequent update
#
# Also, `#unsubscribe` terminates the subscription.
class GraphQL::Schema::Subscription < ::GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Resolver::HasPayloadType
  extend ::GraphQL::Schema::Member::HasFields

  # @return [Subscription] a new instance of Subscription
  def initialize(object:, context:, field:); end

  # If an argument is flagged with `loads:` and no object is found for it,
  # remove this subscription (assuming that the object was deleted in the meantime,
  # or that it became inaccessible).
  def load_application_object_failed(err); end

  # Implement the {Resolve} API
  def resolve(**args); end

  # Wrap the user-defined `#subscribe` hook
  def resolve_subscribe(**args); end

  # Wrap the user-provided `#update` hook
  def resolve_update(**args); end

  def resolve_with_support(**args); end

  # The default implementation returns nothing on subscribe.
  # Override it to return an object or
  # `:no_response` to (explicitly) return nothing.
  def subscribe(args = T.unsafe(nil)); end

  # Call this to halt execution and remove this subscription from the system
  def unsubscribe; end

  # The default implementation returns the root object.
  # Override it to return {NO_UPDATE} if you want to
  # skip updates sometimes. Or override it to return a different object.
  def update(args = T.unsafe(nil)); end

  class << self
    # Overriding Resolver#field_options to include subscription_scope
    def field_options; end

    # Call this method to provide a new subscription_scope; OR
    # call it without an argument to get the subscription_scope
    #
    # @param new_scope [Symbol]
    # @param optional [Boolean] If true, then don't require `scope:` to be provided to updates to this subscription.
    # @return [Symbol]
    def subscription_scope(new_scope = T.unsafe(nil), optional: T.unsafe(nil)); end

    # @return [Boolean]
    def subscription_scope_optional?; end

    # This is called during initial subscription to get a "name" for this subscription.
    # Later, when `.trigger` is called, this will be called again to build another "name".
    # Any subscribers with matching topic will begin the update flow.
    #
    # The default implementation creates a string using the field name, subscription scope, and argument keys and values.
    # In that implementation, only `.trigger` calls with _exact matches_ result in updates to subscribers.
    #
    # To implement a filtered stream-type subscription flow, override this method to return a string with field name and subscription scope.
    # Then, implement {#update} to compare its arguments to the current `object` and return {NO_UPDATE} when an
    # update should be filtered out.
    #
    # @param arguments [Hash<String => Object>] The arguments for this topic, in GraphQL-style (camelized strings)
    # @param field [GraphQL::Schema::Field]
    # @param scope [Object, nil] A value corresponding to `.trigger(... scope:)` (for updates) or the `subscription_scope` found in `context` (for initial subscriptions).
    # @return [String] An identifier corresponding to a stream of updates
    # @see {#update} for how to skip updates when an event comes with a matching topic.
    def topic_for(arguments:, field:, scope:); end
  end
end

GraphQL::Schema::Subscription::NO_UPDATE = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Subscription::READING_SCOPE = T.let(T.unsafe(nil), Object)

# This plugin will stop resolving new fields after `max_seconds` have elapsed.
# After the time has passed, any remaining fields will be `nil`, with errors added
# to the `errors` key. Any already-resolved fields will be in the `data` key, so
# you'll get a partial response.
#
# You can subclass `GraphQL::Schema::Timeout` and override `max_seconds` and/or `handle_timeout`
# to provide custom logic when a timeout error occurs.
#
# Note that this will stop a query _in between_ field resolutions, but
# it doesn't interrupt long-running `resolve` functions. Be sure to use
# timeout options for external connections. For more info, see
# www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/
#
# @example Stop resolving fields after 2 seconds
#   class MySchema < GraphQL::Schema
#   use GraphQL::Schema::Timeout, max_seconds: 2
#   end
# @example Notifying Bugsnag and logging a timeout
#   class MyTimeout < GraphQL::Schema::Timeout
#   def handle_timeout(error, query)
#   Rails.logger.warn("GraphQL Timeout: #{error.message}: #{query.query_string}")
#   Bugsnag.notify(error, {query_string: query.query_string})
#   end
#   end
#
#   class MySchema < GraphQL::Schema
#   use MyTimeout, max_seconds: 2
#   end
class GraphQL::Schema::Timeout
  # @param max_seconds [Numeric] how many seconds the query should be allowed to resolve new fields
  # @return [Timeout] a new instance of Timeout
  def initialize(max_seconds:); end

  # Invoked when a query times out.
  #
  # @param error [GraphQL::Schema::Timeout::TimeoutError]
  # @param query [GraphQL::Error]
  def handle_timeout(error, query); end

  # Called at the start of each query.
  # The default implementation returns the `max_seconds:` value from installing this plugin.
  #
  # @param query [GraphQL::Query] The query that's about to run
  # @return [Integer, false] The number of seconds after which to interrupt query execution and call {#handle_error}, or `false` to bypass the timeout.
  def max_seconds(query); end

  def trace(key, data); end

  class << self
    def use(schema, **options); end
  end
end

# This error is raised when a query exceeds `max_seconds`.
# Since it's a child of {GraphQL::ExecutionError},
# its message will be added to the response's `errors` key.
#
# To raise an error that will stop query resolution, use a custom block
# to take this error and raise a new one which _doesn't_ descend from {GraphQL::ExecutionError},
# such as `RuntimeError`.
class GraphQL::Schema::Timeout::TimeoutError < ::GraphQL::ExecutionError
  # @return [TimeoutError] a new instance of TimeoutError
  def initialize(parent_type, field); end
end

# This middleware will stop resolving new fields after `max_seconds` have elapsed.
# After the time has passed, any remaining fields will be `nil`, with errors added
# to the `errors` key. Any already-resolved fields will be in the `data` key, so
# you'll get a partial response.
#
# You can provide a block which will be called with any timeout errors that occur.
#
# Note that this will stop a query _in between_ field resolutions, but
# it doesn't interrupt long-running `resolve` functions. Be sure to use
# timeout options for external connections. For more info, see
# www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/
#
# @api deprecated
# @example Stop resolving fields after 2 seconds
#   MySchema.middleware << GraphQL::Schema::TimeoutMiddleware.new(max_seconds: 2)
# @example Notifying Bugsnag on a timeout
#   MySchema.middleware << GraphQL::Schema::TimeoutMiddleware(max_seconds: 1.5) do |timeout_error, query|
#   Bugsnag.notify(timeout_error, {query_string: query_ctx.query.query_string})
#   end
# @see Schema::Timeout
class GraphQL::Schema::TimeoutMiddleware
  # @api deprecated
  # @param max_seconds [Numeric] how many seconds the query should be allowed to resolve new fields
  # @return [TimeoutMiddleware] a new instance of TimeoutMiddleware
  def initialize(max_seconds:, context_key: T.unsafe(nil), &block); end

  # @api deprecated
  def call(parent_type, parent_object, field_definition, field_args, query_context); end

  # This is called when a field _would_ be resolved, except that we're over the time limit.
  #
  # @api deprecated
  # @return [GraphQL::Schema::TimeoutMiddleware::TimeoutError] An error whose message will be added to the `errors` key
  def on_timeout(parent_type, parent_object, field_definition, field_args, field_context); end
end

# This error is raised when a query exceeds `max_seconds`.
# Since it's a child of {GraphQL::ExecutionError},
# its message will be added to the response's `errors` key.
#
# To raise an error that will stop query resolution, use a custom block
# to take this error and raise a new one which _doesn't_ descend from {GraphQL::ExecutionError},
# such as `RuntimeError`.
#
# @api deprecated
class GraphQL::Schema::TimeoutMiddleware::TimeoutError < ::GraphQL::ExecutionError
  # @api deprecated
  # @return [TimeoutError] a new instance of TimeoutError
  def initialize(parent_type, field_defn); end
end

# This behaves like {GraphQL::Query} but {#context} returns
# the _field-level_ context, not the query-level context.
# This means you can reliably get the `irep_node` and `path`
# from it after the fact.
#
# @api deprecated
class GraphQL::Schema::TimeoutMiddleware::TimeoutQueryProxy < ::SimpleDelegator
  # @api deprecated
  # @return [TimeoutQueryProxy] a new instance of TimeoutQueryProxy
  def initialize(query, ctx); end

  # @api deprecated
  def context; end
end

# Visit the members of this schema and build up artifacts for runtime.
#
# @api private
class GraphQL::Schema::Traversal
  # @api private
  # @param schema [GraphQL::Schema]
  # @return [Traversal] a new instance of Traversal
  def initialize(schema, introspection: T.unsafe(nil)); end

  # @api private
  # @return [Hash<String => Hash<String => GraphQL::Field>>]
  def instrumented_field_map; end

  # @api private
  # @return [Hash<String => GraphQL::BaseType]] Hash<String => GraphQL::BaseType]
  def type_map; end

  # @api private
  # @return [Hash<String => Array<GraphQL::Field || GraphQL::Argument || GraphQL::Directive>]] Hash<String => Array<GraphQL::Field || GraphQL::Argument || GraphQL::Directive>]
  def type_reference_map; end

  # @api private
  # @return [Hash<String => Array<GraphQL::BaseType>]] Hash<String => Array<GraphQL::BaseType>]
  def union_memberships; end

  private

  # A brute-force appraoch to late binding.
  # Just keep trying the whole list, hoping that they
  # eventually all resolve.
  # This could be replaced with proper dependency tracking.
  #
  # @api private
  def resolve_late_bound_fields; end

  # The late-bound type may be wrapped with list or non-null types.
  # Apply the same wrapping to the resolve type and
  # return the maybe-wrapped type
  #
  # @api private
  def rewrap_resolved_type(late_bound_type, resolved_inner_type); end

  # @api private
  def validate_type(member, context_description); end

  # @api private
  def visit(schema, member, context_description); end

  # @api private
  def visit_field_on_type(schema, type_defn, field_defn, dynamic_field: T.unsafe(nil)); end

  # @api private
  def visit_fields(schema, type_defn); end
end

# @api private
module GraphQL::Schema::TypeExpression
  class << self
    # Fetch a type from a type map by its AST specification.
    # Return `nil` if not found.
    #
    # @api private
    # @param type_owner [#get_type] A thing for looking up types by name
    # @param ast_node [GraphQL::Language::Nodes::AbstractNode]
    # @return [Class, GraphQL::Schema::NonNull, GraphQL::Schema:List]
    def build_type(type_owner, ast_node); end

    private

    # @api private
    def wrap_type(type, wrapper_method); end
  end
end

# This class joins an object type to an abstract type (interface or union) of which
# it is a member.
class GraphQL::Schema::TypeMembership
  # Called when an object is hooked up to an abstract type, such as {Schema::Union.possible_types}
  # or {Schema::Object.implements} (for interfaces).
  #
  # @param abstract_type [Class<GraphQL::Schema::Union>, Module<GraphQL::Schema::Interface>]
  # @param object_type [Class<GraphQL::Schema::Object>]
  # @param options [Hash] Any options passed to `.possible_types` or `.implements`
  # @return [TypeMembership] a new instance of TypeMembership
  def initialize(abstract_type, object_type, **options); end

  # @return [Class<GraphQL::Schema::Union>, Module<GraphQL::Schema::Interface>]
  def abstract_type; end

  def graphql_name; end
  def inspect; end

  # @return [Class<GraphQL::Schema::Object>]
  def object_type; end

  # @return [Class<GraphQL::Schema::Object>]
  def object_type=(_arg0); end

  def path; end
  def type_class; end

  # @return [Boolean] if false, {#object_type} will be treated as _not_ a member of {#abstract_type}
  def visible?(ctx); end
end

class GraphQL::Schema::Union < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL

  class << self
    def all_possible_types; end

    # Update a type membership whose `.object_type` is a string or late-bound type
    # so that the type membership's `.object_type` is the given `object_type`.
    # (This is used for updating the union after the schema as lazily loaded the union member.)
    #
    # @api private
    def assign_type_membership_object_type(object_type); end

    # @private
    def inherited(child_class); end

    def kind; end
    def possible_types(*types, context: T.unsafe(nil), **options); end
    def to_graphql(silence_deprecation_warning: T.unsafe(nil)); end
    def type_membership_class(membership_class = T.unsafe(nil)); end
    def type_memberships; end

    private

    def assert_valid_union_member(type_defn); end
  end
end

module GraphQL::Schema::UniqueWithinType
  private

  # @param node_id [String] A unique ID generated by {.encode}
  # @return [Array<(String, String)>] The type name & value passed to {.encode}
  def decode(node_id, separator: T.unsafe(nil)); end

  # @param type_name [String]
  # @param object_value [Any]
  # @return [String] a unique, opaque ID generated as a function of the two inputs
  def encode(type_name, object_value, separator: T.unsafe(nil)); end

  class << self
    # @param node_id [String] A unique ID generated by {.encode}
    # @return [Array<(String, String)>] The type name & value passed to {.encode}
    def decode(node_id, separator: T.unsafe(nil)); end

    # Returns the value of attribute default_id_separator.
    def default_id_separator; end

    # Sets the attribute default_id_separator
    #
    # @param value the value to set the attribute default_id_separator to.
    def default_id_separator=(_arg0); end

    # @param type_name [String]
    # @param object_value [Any]
    # @return [String] a unique, opaque ID generated as a function of the two inputs
    def encode(type_name, object_value, separator: T.unsafe(nil)); end
  end
end

class GraphQL::Schema::UnresolvedLateBoundTypeError < ::GraphQL::Error
  # @return [UnresolvedLateBoundTypeError] a new instance of UnresolvedLateBoundTypeError
  def initialize(type:); end

  # Returns the value of attribute type.
  def type; end
end

# This module provides a function for validating GraphQL types.
#
# Its {RULES} contain objects that respond to `#call(type)`. Rules are
# looked up for given types (by class ancestry), then applied to
# the object until an error is returned.
#
# Remove this in GraphQL-Ruby 2.0 when schema instances are removed.
class GraphQL::Schema::Validation
  class << self
    # Lookup the rules for `object` based on its class,
    # Then returns an error message or `nil`
    #
    # @param object [Object] something to be validated
    # @return [String, Nil] error message, if there was one
    def validate(object); end
  end
end

# A mapping of `{Class => [Proc, Proc...]}` pairs.
# To validate an instance, find entries where `object.is_a?(key)` is true.
# Then apply each rule from the matching values.
GraphQL::Schema::Validation::RULES = T.let(T.unsafe(nil), Hash)

module GraphQL::Schema::Validation::Rules
  class << self
    def assert_named_items_are_valid(item_name, get_items_proc); end

    # @param property_name [Symbol] The method to validate
    # @param allowed_classes [Class] Classes which the return value may be an instance of
    # @return [Proc] A proc which will validate the input by calling `property_name` and asserting it is an instance of one of `allowed_classes`
    def assert_property(property_name, *allowed_classes); end

    # @param property_name [Symbol] The method whose return value will be validated
    # @param list_member_class [Class] The class which each member of the returned array should be an instance of
    # @return [Proc] A proc to validate the input by calling `property_name` and asserting that the return is an Array of `list_member_class` instances
    def assert_property_list_of(property_name, list_member_class); end

    # @param property_name [Symbol] The method whose return value will be validated
    # @param from_class [Class] The class for keys in the return value
    # @param to_class [Class] The class for values in the return value
    # @return [Proc] A proc to validate that validates the input by calling `property_name` and asserting that the return value is a Hash of `{from_class => to_class}` pairs
    def assert_property_mapping(property_name, from_class, to_class); end

    def count_at_least(item_name, minimum_count, get_items_proc); end
  end
end

GraphQL::Schema::Validation::Rules::ARGUMENTS_ARE_STRING_TO_ARGUMENT = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::ARGUMENTS_ARE_VALID = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::DEFAULT_VALUE_IS_VALID_FOR_TYPE = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::DEPRECATED_ARGUMENTS_ARE_OPTIONAL = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::DESCRIPTION_IS_STRING_OR_NIL = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::FIELDS_ARE_VALID = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::HAS_AT_LEAST_ONE_ARGUMENT = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::HAS_AT_LEAST_ONE_FIELD = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::HAS_ONE_OR_MORE_POSSIBLE_TYPES = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::INTERFACES_ARE_IMPLEMENTED = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::NAME_IS_STRING = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::RESERVED_NAME = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::RESERVED_TYPE_NAME = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::SCHEMA_CAN_FETCH_IDS = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::SCHEMA_CAN_GENERATE_IDS = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::SCHEMA_CAN_RESOLVE_TYPES = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::SCHEMA_INSTRUMENTERS_ARE_VALID = T.let(T.unsafe(nil), Proc)
GraphQL::Schema::Validation::Rules::TYPE_IS_VALID_INPUT_TYPE = T.let(T.unsafe(nil), Proc)

class GraphQL::Schema::Validator
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # @param validated [GraphQL::Schema::Argument, GraphQL::Schema::Field, GraphQL::Schema::Resolver, Class<GraphQL::Schema::InputObject>] The argument or argument owner this validator is attached to
  # @param allow_blank [Boolean] if `true`, then objects that respond to `.blank?` and return true for `.blank?` will skip this validation
  # @param allow_null [Boolean] if `true`, then incoming `null`s will skip this validation
  # @return [Validator] a new instance of Validator
  def initialize(validated:, allow_blank: T.unsafe(nil), allow_null: T.unsafe(nil)); end

  # This is like `String#%`, but it supports the case that only some of `string`'s
  # values are present in `substitutions`
  def partial_format(string, substitutions); end

  # @return [Boolean] `true` if `value` is `nil` and this validator has `allow_null: true` or if value is `.blank?` and this validator has `allow_blank: true`
  def permitted_empty_value?(value); end

  # @param object [Object] The application object that this argument's field is being resolved for
  # @param context [GraphQL::Query::Context]
  # @param value [Object] The client-provided value for this argument (after parsing and coercing by the input type)
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [nil, Array<String>, String] Error message or messages to add
  def validate(object, context, value); end

  # The thing being validated
  #
  # @return [GraphQL::Schema::Argument, GraphQL::Schema::Field, GraphQL::Schema::Resolver, Class<GraphQL::Schema::InputObject>]
  def validated; end

  class << self
    # Returns the value of attribute all_validators.
    def all_validators; end

    # Sets the attribute all_validators
    #
    # @param value the value to set the attribute all_validators to.
    def all_validators=(_arg0); end

    # @param schema_member [GraphQL::Schema::Field, GraphQL::Schema::Argument, Class<GraphQL::Schema::InputObject>]
    # @param validates_hash [Hash{Symbol => Hash}, Hash{Class => Hash} nil] A configuration passed as `validates:`
    # @return [Array<Validator>]
    def from_config(schema_member, validates_hash); end

    # Add `validator_class` to be initialized when `validates:` is given `name`.
    # (It's initialized with whatever options are given by the key `name`).
    #
    # @param name [Symbol]
    # @param validator_class [Class]
    # @return [void]
    def install(name, validator_class); end

    # Remove whatever validator class is {.install}ed at `name`, if there is one
    #
    # @param name [Symbol]
    # @return [void]
    def uninstall(name); end

    # @param validators [Array<Validator>]
    # @param object [Object]
    # @param context [Query::Context]
    # @param value [Object]
    # @return [void]
    def validate!(validators, object, context, value, as: T.unsafe(nil)); end
  end
end

# Use this to specifically reject values that respond to `.blank?` and respond truthy for that method.
#
# @example Require a non-empty string for an argument
#   argument :name, String, required: true, validate: { allow_blank: false }
class GraphQL::Schema::Validator::AllowBlankValidator < ::GraphQL::Schema::Validator
  # @return [AllowBlankValidator] a new instance of AllowBlankValidator
  def initialize(allow_blank_positional, allow_blank: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to specifically reject or permit `nil` values (given as `null` from GraphQL).
#
# @example require a non-null value for an argument if it is provided
#   argument :name, String, required: false, validates: { allow_null: false }
class GraphQL::Schema::Validator::AllowNullValidator < ::GraphQL::Schema::Validator
  # @return [AllowNullValidator] a new instance of AllowNullValidator
  def initialize(allow_null_positional, allow_null: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

GraphQL::Schema::Validator::AllowNullValidator::MESSAGE = T.let(T.unsafe(nil), String)

# Use this to specifically reject values from an argument.
#
# @example disallow certain values
#
#   argument :favorite_non_prime, Integer, required: true,
#   validates: { exclusion: { in: [2, 3, 5, 7, ... ]} }
class GraphQL::Schema::Validator::ExclusionValidator < ::GraphQL::Schema::Validator
  # @param message [String]
  # @param in [Array] The values to reject
  # @return [ExclusionValidator] a new instance of ExclusionValidator
  def initialize(in:, message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to assert that string values match (or don't match) the given RegExp.
#
# @example requiring input to match a pattern
#
#   argument :handle, String, required: true,
#   validates: { format: { with: /\A[a-z0-9_]+\Z/ } }
# @example reject inputs that match a pattern
#
#   argument :word_that_doesnt_begin_with_a_vowel, String, required: true,
#   validates: { format: { without: /\A[aeiou]/ } }
#
#   # It's pretty hard to come up with a legitimate use case for `without:`
class GraphQL::Schema::Validator::FormatValidator < ::GraphQL::Schema::Validator
  # @param with [RegExp, nil]
  # @param without [Regexp, nil]
  # @param message [String]
  # @return [FormatValidator] a new instance of FormatValidator
  def initialize(with: T.unsafe(nil), without: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# You can use this to allow certain values for an argument.
#
# Usually, a {GraphQL::Schema::Enum} is better for this, because it's self-documenting.
#
# @example only allow certain values for an argument
#
#   argument :favorite_prime, Integer, required: true,
#   validates: { inclusion: { in: [2, 3, 5, 7, 11, ... ] } }
class GraphQL::Schema::Validator::InclusionValidator < ::GraphQL::Schema::Validator
  # @param message [String]
  # @param in [Array] The values to allow
  # @return [InclusionValidator] a new instance of InclusionValidator
  def initialize(in:, message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to enforce a `.length` restriction on incoming values. It works for both Strings and Lists.
#
# @example Allow no more than 10 IDs
#
#   argument :ids, [ID], required: true, validates: { length: { maximum: 10 } }
# @example Require three selections
#
#   argument :ice_cream_preferences, [ICE_CREAM_FLAVOR], required: true, validates: { length: { is: 3 } }
class GraphQL::Schema::Validator::LengthValidator < ::GraphQL::Schema::Validator
  # @param maximum [Integer]
  # @param too_long [String] Used when `maximum` is exceeded or value is greater than `within`
  # @param minimum [Integer]
  # @param too_short [String] Used with value is less than `minimum` or less than `within`
  # @param is [Integer] Exact length requirement
  # @param wrong_length [String] Used when value doesn't match `is`
  # @param within [Range] An allowed range (becomes `minimum:` and `maximum:` under the hood)
  # @param message [String]
  # @return [LengthValidator] a new instance of LengthValidator
  def initialize(maximum: T.unsafe(nil), too_long: T.unsafe(nil), minimum: T.unsafe(nil), too_short: T.unsafe(nil), is: T.unsafe(nil), within: T.unsafe(nil), wrong_length: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to assert numerical comparisons hold true for inputs.
#
# @example Require a number between 0 and 1
#
#   argument :batting_average, Float, required: true, validates: { numericality: { within: 0..1 } }
# @example Require the number 42
#
#   argument :the_answer, Integer, required: true, validates: { numericality: { equal_to: 42 } }
# @example Require a real number
#
#   argument :items_count, Integer, required: true, validates: { numericality: { greater_than_or_equal_to: 0 } }
class GraphQL::Schema::Validator::NumericalityValidator < ::GraphQL::Schema::Validator
  # @param greater_than [Integer]
  # @param greater_than_or_equal_to [Integer]
  # @param less_than [Integer]
  # @param less_than_or_equal_to [Integer]
  # @param equal_to [Integer]
  # @param other_than [Integer]
  # @param odd [Boolean]
  # @param even [Boolean]
  # @param within [Range]
  # @param message [String] used for all validation failures
  # @return [NumericalityValidator] a new instance of NumericalityValidator
  def initialize(greater_than: T.unsafe(nil), greater_than_or_equal_to: T.unsafe(nil), less_than: T.unsafe(nil), less_than_or_equal_to: T.unsafe(nil), equal_to: T.unsafe(nil), other_than: T.unsafe(nil), odd: T.unsafe(nil), even: T.unsafe(nil), within: T.unsafe(nil), message: T.unsafe(nil), null_message: T.unsafe(nil), **default_options); end

  def validate(object, context, value); end
end

# Use this validator to require _one_ of the named arguments to be present.
# Or, use Arrays of symbols to name a valid _set_ of arguments.
#
# (This is for specifying mutually exclusive sets of arguments.)
#
# @example Require exactly one of these arguments
#
#   field :update_amount, IngredientAmount, null: false do
#   argument :ingredient_id, ID, required: true
#   argument :cups, Integer, required: false
#   argument :tablespoons, Integer, required: false
#   argument :teaspoons, Integer, required: false
#   validates required: { one_of: [:cups, :tablespoons, :teaspoons] }
#   end
# @example Require one of these _sets_ of arguments
#
#   field :find_object, Node, null: true do
#   argument :node_id, ID, required: false
#   argument :object_type, String, required: false
#   argument :object_id, Integer, required: false
#   # either a global `node_id` or an `object_type`/`object_id` pair is required:
#   validates required: { one_of: [:node_id, [:object_type, :object_id]] }
#   end
# @example require _some_ value for an argument, even if it's null
#   field :update_settings, AccountSettings do
#   # `required: :nullable` means this argument must be given, but may be `null`
#   argument :age, Integer, required: :nullable
#   end
class GraphQL::Schema::Validator::RequiredValidator < ::GraphQL::Schema::Validator
  # @param one_of [Symbol, Array<Symbol>] An argument, or a list of arguments, that represents a valid set of inputs for this field
  # @param message [String]
  # @return [RequiredValidator] a new instance of RequiredValidator
  def initialize(one_of: T.unsafe(nil), argument: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

class GraphQL::Schema::Validator::ValidationFailedError < ::GraphQL::ExecutionError
  # @return [ValidationFailedError] a new instance of ValidationFailedError
  def initialize(errors:); end

  # Returns the value of attribute errors.
  def errors; end
end

# Restrict access to a {GraphQL::Schema} with a user-defined filter.
#
# When validating and executing a query, all access to schema members
# should go through a warden. If you access the schema directly,
# you may show a client something that it shouldn't be allowed to see.
#
# @api private
# @example Hidding private fields
#   private_members = -> (member, ctx) { member.metadata[:private] }
#   result = Schema.execute(query_string, except: private_members)
# @example Custom filter implementation
#   # It must respond to `#call(member)`.
#   class MissingRequiredFlags
#   def initialize(user)
#   @user = user
#   end
#
#   # Return `false` if any required flags are missing
#   def call(member, ctx)
#   member.metadata[:required_flags].any? do |flag|
#   !@user.has_flag?(flag)
#   end
#   end
#   end
#
#   # Then, use the custom filter in query:
#   missing_required_flags = MissingRequiredFlags.new(current_user)
#
#   # This query can only access members which match the user's flags
#   result = Schema.execute(query_string, except: missing_required_flags)
class GraphQL::Schema::Warden
  # @api private
  # @param filter [<#call(member)>] Objects are hidden when `.call(member, ctx)` returns true
  # @param context [GraphQL::Query::Context]
  # @param schema [GraphQL::Schema]
  # @return [Warden] a new instance of Warden
  def initialize(filter, context:, schema:); end

  # @api private
  # @param argument_owner [GraphQL::Field, GraphQL::InputObjectType]
  # @return [Array<GraphQL::Argument>] Visible arguments on `argument_owner`
  def arguments(argument_owner); end

  # @api private
  def directives; end

  # @api private
  # @return [Array<GraphQL::EnumType::EnumValue>] Visible members of `enum_defn`
  def enum_values(enum_defn); end

  # @api private
  # @param type_defn [GraphQL::ObjectType, GraphQL::InterfaceType]
  # @return [Array<GraphQL::Field>] Fields on `type_defn`
  def fields(type_defn); end

  # @api private
  # @return [GraphQL::Argument, nil] The argument named `argument_name` on `parent_type`, if it exists and is visible
  def get_argument(parent_type, argument_name); end

  # @api private
  # @return [GraphQL::Field, nil] The field named `field_name` on `parent_type`, if it exists
  def get_field(parent_type, field_name); end

  # @api private
  # @return [GraphQL::BaseType, nil] The type named `type_name`, if it exists (else `nil`)
  def get_type(type_name); end

  # @api private
  # @return [Array<GraphQL::InterfaceType>] Visible interfaces implemented by `obj_type`
  def interfaces(obj_type); end

  # @api private
  # @return [Array<GraphQL::BaseType>] The types which may be member of `type_defn`
  def possible_types(type_defn); end

  # @api private
  # @return [Boolean] Boolean True if the type is visible and reachable in the schema
  def reachable_type?(type_name); end

  # @api private
  # @return [Array<GraphQL::BaseType>] Visible and reachable types in the schema
  def reachable_types; end

  # @api private
  def root_type_for_operation(op_name); end

  # @api private
  # @return [Hash<String, GraphQL::BaseType>] Visible types in the schema
  def types; end

  # @api private
  # @return [Boolean]
  def visible_argument?(arg_defn, _ctx = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def visible_enum_value?(enum_value, _ctx = T.unsafe(nil)); end

  # @api private
  # @param owner [Class, Module] If provided, confirm that field has the given owner.
  # @return [Boolean]
  def visible_field?(field_defn, _ctx = T.unsafe(nil), owner = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def visible_type?(type_defn, _ctx = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def visible_type_membership?(type_membership, _ctx = T.unsafe(nil)); end

  private

  # If this field was inherited from an interface, and the field on that interface is _hidden_,
  # then treat this inherited field as hidden.
  # (If it _wasn't_ inherited, then don't hide it for this reason.)
  #
  # @api private
  # @return [Boolean]
  def field_on_visible_interface?(field_defn, type_defn); end

  # @api private
  # @return [Boolean]
  def orphan_type?(type_defn); end

  # @api private
  def reachable_type_set; end

  # @api private
  def read_through; end

  # @api private
  # @return [Boolean]
  def referenced?(type_defn); end

  # @api private
  # @return [Boolean]
  def root_type?(type_defn); end

  # We need this to tell whether a field was inherited by an interface
  # even when that interface is hidden from `#interfaces`
  #
  # @api private
  def unfiltered_interfaces(type_defn); end

  # @api private
  def union_memberships(obj_type); end

  # @api private
  # @return [Boolean]
  def visible?(member); end

  # @api private
  # @return [Boolean]
  def visible_abstract_type?(type_defn); end

  # @api private
  # @return [Boolean]
  def visible_and_reachable_type?(type_defn); end

  # @api private
  # @return [Boolean]
  def visible_possible_types?(type_defn); end

  class << self
    # @api private
    def from_context(context); end

    # @api private
    # @param visibility_method [Symbol] a Warden method to call for this entry
    # @param entry [Object, Array<Object>] One or more definitions for a given name in a GraphQL Schema
    # @param context [GraphQL::Query::Context]
    # @param warden [Warden]
    # @return [Object] `entry` or one of `entry`'s items if exactly one of them is visible for this context
    # @return [nil] If neither `entry` nor any of `entry`'s items are visible for this context
    def visible_entry?(visibility_method, entry, context, warden = T.unsafe(nil)); end
  end
end

# @api private
GraphQL::Schema::Warden::NO_REFERENCES = T.let(T.unsafe(nil), Array)

# This is used when a caller provides a Hash for context.
# We want to call the schema's hooks, but we don't have a full-blown warden.
# The `context` arguments to these methods exist purely to simplify the code that
# calls methods on this object, so it will have everything it needs.
#
# @api private
class GraphQL::Schema::Warden::PassThruWarden
  class << self
    # @api private
    # @return [Boolean]
    def visible_argument?(arg, ctx); end

    # @api private
    # @return [Boolean]
    def visible_enum_value?(ev, ctx); end

    # @api private
    # @return [Boolean]
    def visible_field?(field, ctx); end

    # @api private
    # @return [Boolean]
    def visible_type?(type, ctx); end

    # @api private
    # @return [Boolean]
    def visible_type_membership?(tm, ctx); end
  end
end

class GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::TypeSystemHelpers

  # @return [Wrapper] a new instance of Wrapper
  def initialize(of_type); end

  def ==(other); end

  # @return [Class, Module] The inner type of this wrapping type, the type of which one or more objects may be present.
  def of_type; end

  # @raise [GraphQL::RequiredImplementationMissingError]
  def to_graphql; end

  def unwrap; end
end

module GraphQL::StaticValidation; end

# Default rules for {GraphQL::StaticValidation::Validator}
#
# Order is important here. Some validators return {GraphQL::Language::Visitor::SKIP}
# which stops the visit on that node. That way it doesn't try to find fields on types that
# don't exist, etc.
GraphQL::StaticValidation::ALL_RULES = T.let(T.unsafe(nil), Array)

module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  def on_argument(node, parent); end
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError < ::GraphQL::StaticValidation::Error
  # @return [ArgumentLiteralsAreCompatibleError] a new instance of ArgumentLiteralsAreCompatibleError
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil), argument_name: T.unsafe(nil), extensions: T.unsafe(nil), coerce_extensions: T.unsafe(nil), argument: T.unsafe(nil), value: T.unsafe(nil)); end

  # Returns the value of attribute argument.
  def argument; end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute value.
  def value; end
end

module GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def on_directive(node, parent); end
  def on_field(node, parent); end
  def validate_arguments(node); end
end

class GraphQL::StaticValidation::ArgumentNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  # @return [ArgumentNamesAreUniqueError] a new instance of ArgumentNamesAreUniqueError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::ArgumentsAreDefined
  def on_argument(node, parent); end

  private

  def node_type(parent); end
  def parent_definition(parent); end

  # TODO smell: these methods are added to all visitors, since they're included in a module.
  def parent_name(parent, type_defn); end
end

class GraphQL::StaticValidation::ArgumentsAreDefinedError < ::GraphQL::StaticValidation::Error
  # @return [ArgumentsAreDefinedError] a new instance of ArgumentsAreDefinedError
  def initialize(message, name:, type:, argument_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute parent.
  def parent; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

class GraphQL::StaticValidation::BaseVisitor < ::GraphQL::Language::Visitor
  # @return [BaseVisitor] a new instance of BaseVisitor
  def initialize(document, context); end

  # Returns the value of attribute context.
  def context; end

  # @return [Array<GraphQL::ObjectType>] Types whose scope we've entered
  def object_types; end

  # @return [Array<String>] The nesting of the current position in the AST
  def path; end

  # This will be overwritten by {InternalRepresentation::Rewrite} if it's included
  def rewrite_document; end

  private

  def add_error(error, path: T.unsafe(nil)); end

  class << self
    # Build a class to visit the AST and perform validation,
    # or use a pre-built class if rules is `ALL_RULES` or empty.
    #
    # @param rules [Array<Module, Class>]
    # @param rewrite [Boolean] if `false`, don't include rewrite
    # @return [Class] A class for validating `rules` during visitation
    def including_rules(rules, rewrite: T.unsafe(nil)); end
  end
end

module GraphQL::StaticValidation::BaseVisitor::ContextMethods
  # @return [GraphQL::Argument, nil] The most-recently-entered GraphQL::Argument, if currently inside one
  def argument_definition; end

  # @return [GraphQL::Directive, nil] The most-recently-entered GraphQL::Directive, if currently inside one
  def directive_definition; end

  # @return [GraphQL::Field, nil] The most-recently-entered GraphQL::Field, if currently inside one
  def field_definition; end

  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_operation_definition(node, parent); end

  # @return [GraphQL::BaseType] The type which the current type came from
  def parent_type_definition; end

  # @return [GraphQL::BaseType] The current object type
  def type_definition; end

  private

  # @yield [node]
  def on_fragment_with_type(node); end

  def push_type(t); end
end

class GraphQL::StaticValidation::DefaultVisitor < ::GraphQL::StaticValidation::BaseVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::InputObjectNamesAreUnique
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::QueryRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

# Track fragment dependencies for operations
# and expose the fragment definitions which
# are used by a given operation
module GraphQL::StaticValidation::DefinitionDependencies
  def initialize(*_arg0); end

  # Returns the value of attribute dependencies.
  def dependencies; end

  # A map of operation definitions to an array of that operation's dependencies
  #
  # @return [DependencyMap]
  def dependency_map(&block); end

  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_operation_definition(node, prev_node); end

  private

  # Return a hash of { node => [node, node ... ]} pairs
  # Keys are top-level definitions
  # Values are arrays of flattened dependencies
  def resolve_dependencies; end
end

# Map definition AST nodes to the definition AST nodes they depend on.
# Expose circular dependencies.
class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
  # @return [DependencyMap] a new instance of DependencyMap
  def initialize; end

  # @return [Array<GraphQL::Language::Nodes::AbstractNode>] dependencies for `definition_node`
  def [](definition_node); end

  # @return [Array<GraphQL::Language::Nodes::FragmentDefinition>]
  def cyclical_definitions; end

  # @return [Hash<Node, Array<GraphQL::Language::Nodes::FragmentSpread>>]
  def unmet_dependencies; end

  # @return [Array<GraphQL::Language::Nodes::FragmentDefinition>]
  def unused_dependencies; end
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  extend ::Forwardable

  # @return [NodeWithPath] a new instance of NodeWithPath
  def initialize(node, path); end

  def eql?(*args, **_arg1, &block); end
  def hash(*args, **_arg1, &block); end
  def name(*args, **_arg1, &block); end

  # Returns the value of attribute node.
  def node; end

  # Returns the value of attribute path.
  def path; end
end

module GraphQL::StaticValidation::DirectivesAreDefined
  def initialize(*_arg0); end

  def on_directive(node, parent); end
end

class GraphQL::StaticValidation::DirectivesAreDefinedError < ::GraphQL::StaticValidation::Error
  # @return [DirectivesAreDefinedError] a new instance of DirectivesAreDefinedError
  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute directive_name.
  def directive_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language

  def on_directive(node, parent); end

  private

  def assert_includes_location(directive_defn, directive_ast, required_location); end
  def validate_location(ast_directive, ast_parent, directives); end
end

GraphQL::StaticValidation::DirectivesAreInValidLocations::LOCATION_MESSAGE_NAMES = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::DirectivesAreInValidLocations::SIMPLE_LOCATIONS = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::DirectivesAreInValidLocations::SIMPLE_LOCATION_NODES = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::DirectivesAreInValidLocationsError < ::GraphQL::StaticValidation::Error
  # @return [DirectivesAreInValidLocationsError] a new instance of DirectivesAreInValidLocationsError
  def initialize(message, target:, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute target_name.
  def target_name; end

  # A hash representation of this Message
  def to_h; end
end

# Generates GraphQL-compliant validation message.
class GraphQL::StaticValidation::Error
  # @return [Error] a new instance of Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute message.
  def message; end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # A hash representation of this Message
  def to_h; end

  private

  def locations; end

  # Returns the value of attribute nodes.
  def nodes; end
end

# Convenience for validators
module GraphQL::StaticValidation::Error::ErrorHelper
  # Error `error_message` is located at `node`
  def error(error_message, nodes, context: T.unsafe(nil), path: T.unsafe(nil), extensions: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::FieldsAreDefinedOnType
  def on_field(node, parent); end
end

class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError < ::GraphQL::StaticValidation::Error
  # @return [FieldsAreDefinedOnTypeError] a new instance of FieldsAreDefinedOnTypeError
  def initialize(message, type:, field:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute field_name.
  def field_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

# Scalars _can't_ have selections
# Objects _must_ have selections
module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def on_field(node, parent); end
  def on_operation_definition(node, _parent); end

  private

  def validate_field_selections(ast_node, resolved_type); end
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError < ::GraphQL::StaticValidation::Error
  # @return [FieldsHaveAppropriateSelectionsError] a new instance of FieldsHaveAppropriateSelectionsError
  def initialize(message, node_name:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute node_name.
  def node_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FieldsWillMerge
  def initialize(*_arg0); end

  def on_field(node, _parent); end
  def on_operation_definition(node, _parent); end

  private

  def arg_conflicts; end
  def compared_fragments_key(frag1, frag2, exclusive); end
  def conflicts_within_selection_set(node, parent_type); end
  def field_conflicts; end
  def fields_and_fragments_from_selection(node, owner_type:, parents:); end
  def find_conflict(response_key, field1, field2, mutually_exclusive: T.unsafe(nil)); end
  def find_conflicts_between(response_keys, response_keys2, mutually_exclusive:); end
  def find_conflicts_between_fields_and_fragment(fragment_spread, fields, mutually_exclusive:); end
  def find_conflicts_between_fragments(fragment_spread1, fragment_spread2, mutually_exclusive:); end
  def find_conflicts_between_sub_selection_sets(field1, field2, mutually_exclusive:); end
  def find_conflicts_within(response_keys); end
  def find_fields_and_fragments(selections, owner_type:, parents:, fields:, fragment_spreads:); end

  # Given two list of parents, find out if they are mutually exclusive
  # In this context, `parents` represends the "self scope" of the field,
  # what types may be found at this point in the query.
  #
  # @return [Boolean]
  def mutually_exclusive?(parents1, parents2); end

  # @return [Boolean]
  def same_arguments?(field1, field2); end

  def serialize_arg(arg_value); end
  def serialize_field_args(field); end
  def setting_errors; end
end

class GraphQL::StaticValidation::FieldsWillMerge::Field < ::Struct
  # Returns the value of attribute definition
  #
  # @return [Object] the current value of definition
  def definition; end

  # Sets the attribute definition
  #
  # @param value [Object] the value to set the attribute definition to.
  # @return [Object] the newly set value
  def definition=(_); end

  # Returns the value of attribute node
  #
  # @return [Object] the current value of node
  def node; end

  # Sets the attribute node
  #
  # @param value [Object] the value to set the attribute node to.
  # @return [Object] the newly set value
  def node=(_); end

  # Returns the value of attribute owner_type
  #
  # @return [Object] the current value of owner_type
  def owner_type; end

  # Sets the attribute owner_type
  #
  # @param value [Object] the value to set the attribute owner_type to.
  # @return [Object] the newly set value
  def owner_type=(_); end

  # Returns the value of attribute parents
  #
  # @return [Object] the current value of parents
  def parents; end

  # Sets the attribute parents
  #
  # @param value [Object] the value to set the attribute parents to.
  # @return [Object] the newly set value
  def parents=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute parents
  #
  # @return [Object] the current value of parents
  def parents; end

  # Sets the attribute parents
  #
  # @param value [Object] the value to set the attribute parents to.
  # @return [Object] the newly set value
  def parents=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Validates that a selection set is valid if all fields (including spreading any
# fragments) either correspond to distinct response names or can be merged
# without ambiguity.
#
# Original Algorithm: https://github.com/graphql/graphql-js/blob/master/src/validation/rules/OverlappingFieldsCanBeMerged.js
GraphQL::StaticValidation::FieldsWillMerge::NO_ARGS = T.let(T.unsafe(nil), Hash)

GraphQL::StaticValidation::FieldsWillMerge::NO_SELECTIONS = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::FieldsWillMergeError < ::GraphQL::StaticValidation::Error
  # @return [FieldsWillMergeError] a new instance of FieldsWillMergeError
  def initialize(kind:, field_name:); end

  def add_conflict(node, conflict_str); end
  def code; end
  def conflicts; end

  # Returns the value of attribute field_name.
  def field_name; end

  # Returns the value of attribute kind.
  def kind; end

  def message; end
  def path; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentNamesAreUnique
  def initialize(*_arg0); end

  def on_document(_n, _p); end
  def on_fragment_definition(node, parent); end
end

class GraphQL::StaticValidation::FragmentNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  # @return [FragmentNamesAreUniqueError] a new instance of FragmentNamesAreUniqueError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentSpreadsArePossible
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end

  private

  def validate_fragment_in_scope(parent_type, child_type, node, context, path); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
  # @return [FragmentSpread] a new instance of FragmentSpread
  def initialize(node:, parent_type:, path:); end

  # Returns the value of attribute node.
  def node; end

  # Returns the value of attribute parent_type.
  def parent_type; end

  # Returns the value of attribute path.
  def path; end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossibleError < ::GraphQL::StaticValidation::Error
  # @return [FragmentSpreadsArePossibleError] a new instance of FragmentSpreadsArePossibleError
  def initialize(message, type:, fragment_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # Returns the value of attribute parent_name.
  def parent_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentTypesExist
  def on_fragment_definition(node, _parent); end
  def on_inline_fragment(node, _parent); end

  private

  def validate_type_exists(fragment_node); end
end

class GraphQL::StaticValidation::FragmentTypesExistError < ::GraphQL::StaticValidation::Error
  # @return [FragmentTypesExistError] a new instance of FragmentTypesExistError
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentsAreFinite
  def on_document(_n, _p); end
end

class GraphQL::StaticValidation::FragmentsAreFiniteError < ::GraphQL::StaticValidation::Error
  # @return [FragmentsAreFiniteError] a new instance of FragmentsAreFiniteError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentsAreNamed
  def on_fragment_definition(node, _parent); end
end

class GraphQL::StaticValidation::FragmentsAreNamedError < ::GraphQL::StaticValidation::Error
  # @return [FragmentsAreNamedError] a new instance of FragmentsAreNamedError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  def on_fragment_definition(node, parent); end
  def on_inline_fragment(node, parent); end

  private

  def validate_type_is_composite(node); end
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError < ::GraphQL::StaticValidation::Error
  # @return [FragmentsAreOnCompositeTypesError] a new instance of FragmentsAreOnCompositeTypesError
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentsAreUsed
  def on_document(node, parent); end
end

class GraphQL::StaticValidation::FragmentsAreUsedError < ::GraphQL::StaticValidation::Error
  # @return [FragmentsAreUsedError] a new instance of FragmentsAreUsedError
  def initialize(message, fragment:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::InputObjectNamesAreUnique
  def on_input_object(node, parent); end

  private

  def validate_input_fields(node); end
end

class GraphQL::StaticValidation::InputObjectNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  # @return [InputObjectNamesAreUniqueError] a new instance of InputObjectNamesAreUniqueError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

class GraphQL::StaticValidation::InterpreterVisitor < ::GraphQL::StaticValidation::BaseVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::InputObjectNamesAreUnique
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::QueryRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

# Test whether `ast_value` is a valid input for `type`
class GraphQL::StaticValidation::LiteralValidator
  # @return [LiteralValidator] a new instance of LiteralValidator
  def initialize(context:); end

  def validate(ast_value, type); end

  private

  # The GraphQL grammar supports variables embedded within scalars but graphql.js
  # doesn't support it so we won't either for simplicity
  #
  # @return [Boolean]
  def constant_scalar?(ast_value); end

  def ensure_array(value); end

  # When `error_bubbling` is false, we want to bail on the first failure that we find.
  # Use `throw` to escape the current call stack, returning the invalid response.
  def maybe_raise_if_invalid(ast_value); end

  def merge_results(results_list); end
  def present_input_field_values_are_valid(type, ast_node); end
  def recursively_validate(ast_value, type); end
  def required_input_fields_are_present(type, ast_node); end
end

module GraphQL::StaticValidation::MutationRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::MutationRootExistsError < ::GraphQL::StaticValidation::Error
  # @return [MutationRootExistsError] a new instance of MutationRootExistsError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def initialize(*_arg0); end

  def on_directive_definition(node, parent); end
  def on_document(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_invalid_node(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
end

class GraphQL::StaticValidation::NoDefinitionsArePresentError < ::GraphQL::StaticValidation::Error
  # @return [NoDefinitionsArePresentError] a new instance of NoDefinitionsArePresentError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

class GraphQL::StaticValidation::NoValidateVisitor < ::GraphQL::StaticValidation::BaseVisitor
  include ::GraphQL::Language
  include ::GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

module GraphQL::StaticValidation::OperationNamesAreValid
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_operation_definition(node, parent); end
end

class GraphQL::StaticValidation::OperationNamesAreValidError < ::GraphQL::StaticValidation::Error
  # @return [OperationNamesAreValidError] a new instance of OperationNamesAreValidError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute operation_name.
  def operation_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::QueryRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::QueryRootExistsError < ::GraphQL::StaticValidation::Error
  # @return [QueryRootExistsError] a new instance of QueryRootExistsError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::RequiredArgumentsArePresent
  def on_directive(node, _parent); end
  def on_field(node, _parent); end

  private

  def assert_required_args(ast_node, defn); end
end

class GraphQL::StaticValidation::RequiredArgumentsArePresentError < ::GraphQL::StaticValidation::Error
  # @return [RequiredArgumentsArePresentError] a new instance of RequiredArgumentsArePresentError
  def initialize(message, class_name:, name:, arguments:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute arguments.
  def arguments; end

  # Returns the value of attribute class_name.
  def class_name; end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  def on_input_object(node, parent); end

  private

  def get_parent_type(context, parent); end
  def validate_input_object(ast_node, context, parent); end
end

class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError < ::GraphQL::StaticValidation::Error
  # @return [RequiredInputObjectAttributesArePresentError] a new instance of RequiredInputObjectAttributesArePresentError
  def initialize(message, path:, nodes:, argument_type:, argument_name:, input_object_type:); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  # Returns the value of attribute argument_type.
  def argument_type; end

  def code; end

  # Returns the value of attribute input_object_type.
  def input_object_type; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::SubscriptionRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::SubscriptionRootExistsError < ::GraphQL::StaticValidation::Error
  # @return [SubscriptionRootExistsError] a new instance of SubscriptionRootExistsError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

# - Ride along with `GraphQL::Language::Visitor`
# - Track type info, expose it to validators
class GraphQL::StaticValidation::TypeStack
  # @param schema [GraphQL::Schema] the schema whose types to use when climbing this document
  # @param visitor [GraphQL::Language::Visitor] a visitor to follow & watch the types
  # @return [TypeStack] a new instance of TypeStack
  def initialize(schema, visitor); end

  # @return [Array<GraphQL::Node::Argument>] arguments which have been entered
  def argument_definitions; end

  # Directives are pushed on, then popped off while traversing the tree
  #
  # @return [Array<GraphQL::Node::Directive>] directives which have been entered
  def directive_definitions; end

  # When it enters a field, it's pushed on this stack (useful for nested fields, args).
  # When it exits, it's popped off.
  #
  # @return [Array<GraphQL::Field>] fields which have been entered
  def field_definitions; end

  # When it enters an object (starting with query or mutation root), it's pushed on this stack.
  # When it exits, it's popped off.
  #
  # @return [Array<GraphQL::ObjectType, GraphQL::Union, GraphQL::Interface>]
  def object_types; end

  # @return [Array<String>] fields which have been entered (by their AST name)
  def path; end

  # @return [GraphQL::Schema] the schema whose types are present in this document
  def schema; end
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
  private

  def pop(stack, node); end

  # Push `argument_defn` onto the stack.
  # It's possible that `argument_defn` will be nil.
  # Push it anyways so `pop` has something to pop.
  def push(stack, node); end

  class << self
    def pop(stack, node); end

    # Push `argument_defn` onto the stack.
    # It's possible that `argument_defn` will be nil.
    # Push it anyways so `pop` has something to pop.
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
  # @return [EnterWithStrategy] a new instance of EnterWithStrategy
  def initialize(stack, strategy); end

  def call(node, parent); end
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy

  private

  def push_path_member(stack, node); end

  class << self
    def push_path_member(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def pop(stack, node); end
  def push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy

  private

  def push_path_member(stack, node); end

  class << self
    def push_path_member(stack, node); end
  end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
  # @return [LeaveWithStrategy] a new instance of LeaveWithStrategy
  def initialize(stack, strategy); end

  def call(node, parent); end
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

GraphQL::StaticValidation::TypeStack::PUSH_STRATEGIES = T.let(T.unsafe(nil), Hash)

# These are jumping-off points for infering types down the tree
GraphQL::StaticValidation::TypeStack::TYPE_INFERRENCE_ROOTS = T.let(T.unsafe(nil), Array)

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_union_type_definition(node, parent); end

  private

  def validate_directive_location(node); end
end

GraphQL::StaticValidation::UniqueDirectivesPerLocation::DIRECTIVE_NODE_HOOKS = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::UniqueDirectivesPerLocationError < ::GraphQL::StaticValidation::Error
  # @return [UniqueDirectivesPerLocationError] a new instance of UniqueDirectivesPerLocationError
  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute directive_name.
  def directive_name; end

  # A hash representation of this Message
  def to_h; end
end

# The validation context gets passed to each validator.
#
# It exposes a {GraphQL::Language::Visitor} where validators may add hooks. ({Language::Visitor#visit} is called in {Validator#validate})
#
# It provides access to the schema & fragments which validators may read from.
#
# It holds a list of errors which each validator may add to.
#
# It also provides limited access to the {TypeStack} instance,
# which tracks state as you climb in and out of different fields.
class GraphQL::StaticValidation::ValidationContext
  extend ::Forwardable

  # @return [ValidationContext] a new instance of ValidationContext
  def initialize(query, visitor_class, max_errors); end

  def argument_definition(*args, **_arg1, &block); end
  def dependencies(*args, **_arg1, &block); end
  def directive_definition(*args, **_arg1, &block); end
  def document(*args, **_arg1, &block); end

  # Returns the value of attribute errors.
  def errors; end

  def field_definition(*args, **_arg1, &block); end
  def fragments(*args, **_arg1, &block); end

  # Returns the value of attribute max_errors.
  def max_errors; end

  def object_types(*args, **_arg1, &block); end
  def on_dependency_resolve(&handler); end

  # Returns the value of attribute on_dependency_resolve_handlers.
  def on_dependency_resolve_handlers; end

  def operations(*args, **_arg1, &block); end
  def parent_type_definition(*args, **_arg1, &block); end
  def path(*args, **_arg1, &block); end

  # Returns the value of attribute query.
  def query; end

  def schema(*args, **_arg1, &block); end
  def schema_directives; end

  # @return [Boolean]
  def too_many_errors?; end

  def type_definition(*args, **_arg1, &block); end
  def validate_literal(ast_value, type); end

  # Returns the value of attribute visitor.
  def visitor; end

  def warden(*args, **_arg1, &block); end
end

class GraphQL::StaticValidation::ValidationTimeoutError < ::GraphQL::StaticValidation::Error
  # @return [ValidationTimeoutError] a new instance of ValidationTimeoutError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

# Initialized with a {GraphQL::Schema}, then it can validate {GraphQL::Language::Nodes::Documents}s based on that schema.
#
# By default, it's used by {GraphQL::Query}
#
# @example Validate a query
#   validator = GraphQL::StaticValidation::Validator.new(schema: MySchema)
#   query = GraphQL::Query.new(MySchema, query_string)
#   errors = validator.validate(query)[:errors]
class GraphQL::StaticValidation::Validator
  # @param schema [GraphQL::Schema]
  # @param rules [Array<#validate(context)>] a list of rules to use when validating
  # @return [Validator] a new instance of Validator
  def initialize(schema:, rules: T.unsafe(nil)); end

  # Invoked when static validation times out.
  #
  # @param query [GraphQL::Query]
  # @param context [GraphQL::StaticValidation::ValidationContext]
  def handle_timeout(query, context); end

  # Validate `query` against the schema. Returns an array of message hashes.
  #
  # @param query [GraphQL::Query]
  # @param validate [Boolean]
  # @param timeout [Float] Number of seconds to wait before aborting validation. Any positive number may be used, including Floats to specify fractional seconds.
  # @param max_errors [Integer] Maximum number of errors before aborting validation. Any positive number will limit the number of errors. Defaults to nil for no limit.
  # @return [Array<Hash>]
  def validate(query, validate: T.unsafe(nil), timeout: T.unsafe(nil), max_errors: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  def on_variable_definition(node, parent); end
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError < ::GraphQL::StaticValidation::Error
  # @return [VariableDefaultValuesAreCorrectlyTypedError] a new instance of VariableDefaultValuesAreCorrectlyTypedError
  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end

  # Returns the value of attribute violation.
  def violation; end
end

GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError::VIOLATIONS = T.let(T.unsafe(nil), Hash)

module GraphQL::StaticValidation::VariableNamesAreUnique
  def on_operation_definition(node, parent); end
end

class GraphQL::StaticValidation::VariableNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  # @return [VariableNamesAreUniqueError] a new instance of VariableNamesAreUniqueError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

module GraphQL::StaticValidation::VariableUsagesAreAllowed
  def initialize(*_arg0); end

  def on_argument(node, parent); end
  def on_operation_definition(node, parent); end

  private

  def create_error(error_message, var_type, ast_var, arg_defn, arg_node); end

  # @return [Integer] Returns the max depth of `array`, or `0` if it isn't an array at all
  def depth_of_array(array); end

  def list_dimension(type); end
  def non_null_levels_match(arg_type, var_type); end
  def validate_usage(argument_owner, arg_node, ast_var); end
  def wrap_var_type_with_depth_of_arg(var_type, arg_node); end
end

class GraphQL::StaticValidation::VariableUsagesAreAllowedError < ::GraphQL::StaticValidation::Error
  # @return [VariableUsagesAreAllowedError] a new instance of VariableUsagesAreAllowedError
  def initialize(message, type:, name:, argument:, error:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # Returns the value of attribute error_message.
  def error_message; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

module GraphQL::StaticValidation::VariablesAreInputTypes
  def on_variable_definition(node, parent); end

  private

  def get_type_name(ast_type); end
end

class GraphQL::StaticValidation::VariablesAreInputTypesError < ::GraphQL::StaticValidation::Error
  # @return [VariablesAreInputTypesError] a new instance of VariablesAreInputTypesError
  def initialize(message, type:, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

# The problem is
#   - Variable $usage must be determined at the OperationDefinition level
#   - You can't tell how fragments use variables until you visit FragmentDefinitions (which may be at the end of the document)
#
#  So, this validator includes some crazy logic to follow fragment spreads recursively, while avoiding infinite loops.
#
# `graphql-js` solves this problem by:
#   - re-visiting the AST for each validator
#   - allowing validators to say `followSpreads: true`
module GraphQL::StaticValidation::VariablesAreUsedAndDefined
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end

  # For FragmentSpreads:
  #  - find the context on the stack
  #  - mark the context as containing this spread
  def on_fragment_spread(node, parent); end

  def on_operation_definition(node, parent); end

  # For VariableIdentifiers:
  #  - mark the variable as used
  #  - assign its AST node
  def on_variable_identifier(node, parent); end

  private

  # Determine all the error messages,
  # Then push messages into the validation context
  def create_errors(node_variables); end

  # Follow spreads in `node`, looking them up from `spreads_for_context` and finding their match in `fragment_definitions`.
  # Use those fragments to update {VariableUsage}s in `parent_variables`.
  # Avoid infinite loops by skipping anything in `visited_fragments`.
  def follow_spreads(node, parent_variables, spreads_for_context, fragment_definitions, visited_fragments); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  #
  # @param value the value to set the attribute ast_node to.
  def ast_node=(_arg0); end

  # @return [Boolean]
  def declared?; end

  # Returns the value of attribute declared_by.
  def declared_by; end

  # Sets the attribute declared_by
  #
  # @param value the value to set the attribute declared_by to.
  def declared_by=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # @return [Boolean]
  def used?; end

  # Returns the value of attribute used_by.
  def used_by; end

  # Sets the attribute used_by
  #
  # @param value the value to set the attribute used_by to.
  def used_by=(_arg0); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError < ::GraphQL::StaticValidation::Error
  # @return [VariablesAreUsedAndDefinedError] a new instance of VariablesAreUsedAndDefinedError
  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute variable_name.
  def variable_name; end

  # Returns the value of attribute violation.
  def violation; end
end

GraphQL::StaticValidation::VariablesAreUsedAndDefinedError::VIOLATIONS = T.let(T.unsafe(nil), Hash)

class GraphQL::StringEncodingError < ::GraphQL::RuntimeTypeError
  # @return [StringEncodingError] a new instance of StringEncodingError
  def initialize(str, context:); end

  # Returns the value of attribute field.
  def field; end

  # Returns the value of attribute path.
  def path; end

  # Returns the value of attribute string.
  def string; end
end

class GraphQL::Subscriptions
  # @param schema [Class] the GraphQL schema this manager belongs to
  # @return [Subscriptions] a new instance of Subscriptions
  def initialize(schema:, broadcast: T.unsafe(nil), default_broadcastable: T.unsafe(nil), **rest); end

  # @return [Boolean] if true, then a query like this one would be broadcasted
  def broadcastable?(query_str, **query_options); end

  # @return [String] A new unique identifier for a subscription
  def build_id; end

  # @return [Boolean] Used when fields don't have `broadcastable:` explicitly set
  def default_broadcastable; end

  # A subscription was terminated server-side.
  # Clean up the database.
  #
  # @param subscription_id [String]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return void.
  def delete_subscription(subscription_id); end

  # A subscription query was re-evaluated, returning `result`.
  # The result should be send to `subscription_id`.
  #
  # @param subscription_id [String]
  # @param result [Hash]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [void]
  def deliver(subscription_id, result); end

  # Run the update query for this subscription and deliver it
  #
  # @return [void]
  # @see {#execute_update}
  # @see {#deliver}
  def execute(subscription_id, event, object); end

  # Event `event` occurred on `object`,
  # Update all subscribers.
  #
  # @param event [Subscriptions::Event]
  # @param object [Object]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [void]
  def execute_all(event, object); end

  # `event` was triggered on `object`, and `subscription_id` was subscribed,
  # so it should be updated.
  #
  # Load `subscription_id`'s GraphQL data, re-evaluate the query and return the result.
  #
  # @param subscription_id [String]
  # @param event [GraphQL::Subscriptions::Event] The event which was triggered
  # @param object [Object] The value for the subscription field
  # @return [GraphQL::Query::Result]
  def execute_update(subscription_id, event, object); end

  # Convert a user-provided event name or argument
  # to the equivalent in GraphQL.
  #
  # By default, it converts the identifier to camelcase.
  # Override this in a subclass to change the transformation.
  #
  # @param event_or_arg_name [String, Symbol]
  # @return [String]
  def normalize_name(event_or_arg_name); end

  # The system wants to send an update to this subscription.
  # Read its data and return it.
  #
  # @param subscription_id [String]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [Hash] Containing required keys
  def read_subscription(subscription_id); end

  # Fetch subscriptions matching this field + arguments pair
  # And pass them off to the queue.
  #
  # @param event_name [String]
  # @param args [Hash<String, Symbol => Object]] rgs [Hash<String, Symbol => Object]
  # @param object [Object]
  # @param scope [Symbol, String]
  # @return [void]
  def trigger(event_name, args, object, scope: T.unsafe(nil)); end

  # `query` was executed and found subscriptions to `events`.
  # Update the database to reflect this new state.
  #
  # @param query [GraphQL::Query]
  # @param events [Array<GraphQL::Subscriptions::Event>]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [void]
  def write_subscription(query, events); end

  private

  # Recursively normalize `args` as belonging to `arg_owner`:
  # - convert symbols to strings,
  # - if needed, camelize the string (using {#normalize_name})
  #
  # @param arg_owner [GraphQL::Field, GraphQL::BaseType]
  # @param args [Hash, Array, Any] some GraphQL input value to coerce as `arg_owner`
  # @return [Any] normalized arguments value
  def normalize_arguments(event_name, arg_owner, args, context); end

  class << self
    # @see {Subscriptions#initialize} for options, concrete implementations may add options.
    def use(defn, options = T.unsafe(nil)); end
  end
end

# A subscriptions implementation that sends data
# as ActionCable broadcastings.
#
# Some things to keep in mind:
#
# - No queueing system; ActiveJob should be added
# - Take care to reload context when re-delivering the subscription. (see {Query#subscription_update?})
# - Avoid the async ActionCable adapter and use the redis or PostgreSQL adapters instead. Otherwise calling #trigger won't work from background jobs or the Rails console.
#
# @example Adding ActionCableSubscriptions to your schema
#   class MySchema < GraphQL::Schema
#   # ...
#   use GraphQL::Subscriptions::ActionCableSubscriptions
#   end
# @example Implementing a channel for GraphQL Subscriptions
#   class GraphqlChannel < ApplicationCable::Channel
#   def subscribed
#   @subscription_ids = []
#   end
#
#   def execute(data)
#   query = data["query"]
#   variables = ensure_hash(data["variables"])
#   operation_name = data["operationName"]
#   context = {
#   # Re-implement whatever context methods you need
#   # in this channel or ApplicationCable::Channel
#   # current_user: current_user,
#   # Make sure the channel is in the context
#   channel: self,
#   }
#
#   result = MySchema.execute(
#   query: query,
#   context: context,
#   variables: variables,
#   operation_name: operation_name
#   )
#
#   payload = {
#   result: result.to_h,
#   more: result.subscription?,
#   }
#
#   # Track the subscription here so we can remove it
#   # on unsubscribe.
#   if result.context[:subscription_id]
#   @subscription_ids << result.context[:subscription_id]
#   end
#
#   transmit(payload)
#   end
#
#   def unsubscribed
#   @subscription_ids.each { |sid|
#   MySchema.subscriptions.delete_subscription(sid)
#   }
#   end
#
#   private
#
#   def ensure_hash(ambiguous_param)
#   case ambiguous_param
#   when String
#   if ambiguous_param.present?
#   ensure_hash(JSON.parse(ambiguous_param))
#   else
#   {}
#   end
#   when Hash, ActionController::Parameters
#   ambiguous_param
#   when nil
#   {}
#   else
#   raise ArgumentError, "Unexpected parameter: #{ambiguous_param}"
#   end
#   end
#   end
class GraphQL::Subscriptions::ActionCableSubscriptions < ::GraphQL::Subscriptions
  # @param serializer [<#dump(obj), #load(string)] Used for serializing messages before handing them to `.broadcast(msg)`] erializer [<#dump(obj), #load(string)] Used for serializing messages before handing them to `.broadcast(msg)`
  # @param namespace [string] Used to namespace events and subscriptions (default: '')
  # @return [ActionCableSubscriptions] a new instance of ActionCableSubscriptions
  def initialize(serializer: T.unsafe(nil), namespace: T.unsafe(nil), action_cable: T.unsafe(nil), action_cable_coder: T.unsafe(nil), **rest); end

  # The channel was closed, forget about it.
  def delete_subscription(subscription_id); end

  # This subscription was re-evaluated.
  # Send it to the specific stream where this client was waiting.
  def deliver(subscription_id, result); end

  # An event was triggered; Push the data over ActionCable.
  # Subscribers will re-evaluate locally.
  def execute_all(event, object); end

  # This is called to turn an ActionCable-broadcasted string (JSON)
  # into a query-ready application object.
  #
  # @param message [String] n ActionCable-broadcasted string (JSON)
  # @param context [GraphQL::Query::Context] the context of the first event for a given subscription fingerprint
  def load_action_cable_message(message, context); end

  # Return the query from "storage" (in memory)
  def read_subscription(subscription_id); end

  # Every subscribing channel is listening here, but only one of them takes any action.
  # This is so we can reuse payloads when possible, and make one payload to send to
  # all subscribers.
  #
  # But the problem is, any channel could close at any time, so each channel has to
  # be ready to take over the primary position.
  #
  # To make sure there's always one-and-only-one channel building payloads,
  # let the listener belonging to the first event on the list be
  # the one to build and publish payloads.
  def setup_stream(channel, initial_event); end

  # A query was run where these events were subscribed to.
  # Store them in memory in _this_ ActionCable frontend.
  # It will receive notifications when events come in
  # and re-evaluate the query locally.
  def write_subscription(query, events); end

  private

  def stream_event_name(event); end
  def stream_subscription_name(subscription_id); end
end

GraphQL::Subscriptions::ActionCableSubscriptions::EVENT_PREFIX = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::ActionCableSubscriptions::SUBSCRIPTION_PREFIX = T.let(T.unsafe(nil), String)

# Detect whether the current operation:
# - Is a subscription operation
# - Is completely broadcastable
#
# Assign the result to `context.namespace(:subscriptions)[:subscription_broadcastable]`
#
# @api private
# @see Subscriptions#broadcastable? for a public API
class GraphQL::Subscriptions::BroadcastAnalyzer < ::GraphQL::Analysis::AST::Analyzer
  # @api private
  # @return [BroadcastAnalyzer] a new instance of BroadcastAnalyzer
  def initialize(subject); end

  # Only analyze subscription operations
  #
  # @api private
  # @return [Boolean]
  def analyze?; end

  # @api private
  def on_enter_field(node, parent, visitor); end

  # Assign the result to context.
  # (This method is allowed to return an error, but we don't need to)
  #
  # @api private
  # @return [void]
  def result; end

  private

  # Modify `@subscription_broadcastable` based on `field_defn`'s configuration (and/or the default value)
  #
  # @api private
  def apply_broadcastable(field_defn); end
end

class GraphQL::Subscriptions::DefaultSubscriptionResolveExtension < ::GraphQL::Subscriptions::SubscriptionRoot::Extension
  def resolve(context:, object:, arguments:); end
end

# This thing can be:
# - Subscribed to by `subscription { ... }`
# - Triggered by `MySchema.subscriber.trigger(name, arguments, obj)`
class GraphQL::Subscriptions::Event
  # @return [Event] a new instance of Event
  def initialize(name:, arguments:, field: T.unsafe(nil), context: T.unsafe(nil), scope: T.unsafe(nil)); end

  # @return [GraphQL::Query::Arguments]
  def arguments; end

  # @return [GraphQL::Query::Context]
  def context; end

  # @return [String] a logical identifier for this event. (Stable when the query is broadcastable.)
  def fingerprint; end

  # @return [String] Corresponds to the Subscription root field name
  def name; end

  # @return [String] An opaque string which identifies this event, derived from `name` and `arguments`
  def topic; end

  class << self
    # @return [String] an identifier for this unit of subscription
    def serialize(_name, arguments, field, scope:, context: T.unsafe(nil)); end

    private

    # @raise [ArgumentError]
    def deep_sort_array_hashes(array_to_inspect); end

    # This method does not support cyclic references in the Hash,
    # nor does it support Hashes whose keys are not sortable
    # with respect to their peers ( cases where a <=> b might throw an error )
    #
    # @raise [ArgumentError]
    def deep_sort_hash_keys(hash_to_sort); end

    def get_arg_definition(arg_owner, arg_name, context); end
    def stringify_args(arg_owner, args, context); end
  end
end

# Wrap the root fields of the subscription type with special logic for:
# - Registering the subscription during the first execution
# - Evaluating the triggered portion(s) of the subscription during later execution
class GraphQL::Subscriptions::Instrumentation
  # @return [Instrumentation] a new instance of Instrumentation
  def initialize(schema:); end

  # After checking the root fields, pass the gathered events to the store
  def after_query(query); end

  # If needed, prepare to gather events which this query subscribes to
  def before_query(query); end

  def instrument(type, field); end
end

class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
  # @return [SubscriptionRegistrationResolve] a new instance of SubscriptionRegistrationResolve
  def initialize(inner_proc); end

  # Wrap the proc with subscription registration logic
  def call(obj, args, ctx); end
end

# Raised when either:
# - the triggered `event_name` doesn't match a field in the schema; or
# - one or more arguments don't match the field arguments
class GraphQL::Subscriptions::InvalidTriggerError < ::GraphQL::Error; end

# Serialization helpers for passing subscription data around.
#
# @api private
module GraphQL::Subscriptions::Serialize
  private

  # @api private
  # @param obj [Object] Some subscription-related data to dump
  # @return [String] The stringified object
  def dump(obj); end

  # This is for turning objects into subscription scopes.
  # It's a one-way transformation, can't reload this :'(
  #
  # @api private
  # @param obj [Object]
  # @return [String]
  def dump_recursive(obj); end

  # @api private
  # @param str [String] A serialized object from {.dump}
  # @return [Object] An object equivalent to the one passed to {.dump}
  def load(str); end

  class << self
    # @api private
    # @param obj [Object] Some subscription-related data to dump
    # @return [String] The stringified object
    def dump(obj); end

    # This is for turning objects into subscription scopes.
    # It's a one-way transformation, can't reload this :'(
    #
    # @api private
    # @param obj [Object]
    # @return [String]
    def dump_recursive(obj); end

    # @api private
    # @param str [String] A serialized object from {.dump}
    # @return [Object] An object equivalent to the one passed to {.dump}
    def load(str); end

    private

    # @api private
    # @param obj [Object] Some subscription-related data to dump
    # @return [Object] The object that converted Global::Identification
    def dump_value(obj); end

    # @api private
    # @param value [Object] A parsed JSON object
    # @return [Object] An object that load Global::Identification recursive
    def load_value(value); end
  end
end

# @api private
GraphQL::Subscriptions::Serialize::GLOBALID_KEY = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Subscriptions::Serialize::OPEN_STRUCT_KEY = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Subscriptions::Serialize::SYMBOL_KEY = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Subscriptions::Serialize::SYMBOL_KEYS_KEY = T.let(T.unsafe(nil), String)

# eg '2020-01-01 23:59:59.123456789+05:00'
#
# @api private
GraphQL::Subscriptions::Serialize::TIMESTAMP_FORMAT = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Subscriptions::Serialize::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# @api private
# @deprecated This module is no longer needed.
module GraphQL::Subscriptions::SubscriptionRoot
  # @api private
  def field(*args, extensions: T.unsafe(nil), **rest, &block); end

  class << self
    # @api private
    # @private
    def extended(child_cls); end
  end
end

# @api private
class GraphQL::Subscriptions::SubscriptionRoot::Extension < ::GraphQL::Schema::FieldExtension
  # @api private
  def after_resolve(value:, context:, object:, arguments:, **rest); end

  private

  # @api private
  def arguments_without_field_extras(arguments:); end
end

# This is for maintaining backwards compatibility:
# if a subscription field is created without a `subscription:` resolver class,
# then implement the method with the previous default behavior.
#
# @api private
module GraphQL::Subscriptions::SubscriptionRoot::InstanceMethods
  # @api private
  def skip_subscription_root(*_arg0); end
end

# Raised when either:
# - An initial subscription didn't have a value for `context[subscription_scope]`
# - Or, an update didn't pass `.trigger(..., scope:)`
# When raised, the initial subscription or update fails completely.
class GraphQL::Subscriptions::SubscriptionScopeMissingError < ::GraphQL::Error; end

# Library entry point for performance metric reporting.
#
# Events:
#
# Key | Metadata
# ----|---------
# lex | `{ query_string: String }`
# parse | `{ query_string: String }`
# validate | `{ query: GraphQL::Query, validate: Boolean }`
# analyze_multiplex |  `{ multiplex: GraphQL::Execution::Multiplex }`
# analyze_query | `{ query: GraphQL::Query }`
# execute_multiplex | `{ multiplex: GraphQL::Execution::Multiplex }`
# execute_query | `{ query: GraphQL::Query }`
# execute_query_lazy | `{ query: GraphQL::Query?, multiplex: GraphQL::Execution::Multiplex? }`
# execute_field | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
# execute_field_lazy | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
# authorized | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# authorized_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# resolve_type | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# resolve_type_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
#
# Note that `execute_field` and `execute_field_lazy` receive different data in different settings:
#
# - When using {GraphQL::Execution::Interpreter}, they receive `{field:, path:, query:}`
# - Otherwise, they receive `{context: ...}`
#
# @example Sending custom events
#   query.trace("my_custom_event", { ... }) do
#   # do stuff ...
#   end
# @example Adding a tracer to a schema
#   class MySchema < GraphQL::Schema
#   tracer MyTracer # <= responds to .trace(key, data, &block)
#   end
# @example Adding a tracer to a single query
#   MySchema.execute(query_str, context: { backtrace: true })
module GraphQL::Tracing; end

# This implementation forwards events to ActiveSupport::Notifications
# with a `graphql` suffix.
#
# @see KEYS for event names
module GraphQL::Tracing::ActiveSupportNotificationsTracing
  class << self
    def trace(key, metadata, &blk); end
  end
end

# A cache of frequently-used keys to avoid needless string allocations
GraphQL::Tracing::ActiveSupportNotificationsTracing::KEYS = T.let(T.unsafe(nil), Hash)

GraphQL::Tracing::ActiveSupportNotificationsTracing::NOTIFICATIONS_ENGINE = T.let(T.unsafe(nil), GraphQL::Tracing::NotificationsTracing)

# This class uses the AppopticsAPM SDK from the appoptics_apm gem to create
# traces for GraphQL.
#
# There are 4 configurations available. They can be set in the
# appoptics_apm config file or in code. Please see:
# {https://docs.appoptics.com/kb/apm_tracing/ruby/configure}
#
#     AppOpticsAPM::Config[:graphql][:enabled] = true|false
#     AppOpticsAPM::Config[:graphql][:transaction_name]  = true|false
#     AppOpticsAPM::Config[:graphql][:sanitize_query] = true|false
#     AppOpticsAPM::Config[:graphql][:remove_comments] = true|false
class GraphQL::Tracing::AppOpticsTracing < ::GraphQL::Tracing::PlatformTracing
  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, _key, data); end

  private

  def gql_config; end
  def graphql_context(context, layer); end
  def graphql_multiplex(data); end
  def graphql_query(query); end
  def graphql_query_string(query_string); end
  def metadata(data, layer); end
  def multiplex_transaction_name(names); end
  def remove_comments(query); end
  def sanitize(query); end
  def span_name(key); end
  def transaction_name(query); end

  class << self
    # During auto-instrumentation this version of AppOpticsTracing is compared
    # with the version provided in the appoptics_apm gem, so that the newer
    # version of the class can be used
    def version; end
  end
end

# These GraphQL events will show up as 'graphql.execute' spans
GraphQL::Tracing::AppOpticsTracing::EXEC_KEYS = T.let(T.unsafe(nil), Array)

# These GraphQL events will show up as 'graphql.prep' spans
GraphQL::Tracing::AppOpticsTracing::PREP_KEYS = T.let(T.unsafe(nil), Array)

class GraphQL::Tracing::AppsignalTracing < ::GraphQL::Tracing::PlatformTracing
  # @param set_action_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
  #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
  #   It can also be specified per-query with `context[:set_appsignal_action_name]`.
  # @return [AppsignalTracing] a new instance of AppsignalTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::DataDogTracing < ::GraphQL::Tracing::PlatformTracing
  # @return [Boolean]
  def analytics_available?; end

  # @return [Boolean]
  def analytics_enabled?; end

  def analytics_sample_rate; end
  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
  def service_name; end
  def tracer; end
end

class GraphQL::Tracing::NewRelicTracing < ::GraphQL::Tracing::PlatformTracing
  # @param set_transaction_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
  #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
  #   It can also be specified per-query with `context[:set_new_relic_transaction_name]`.
  # @return [NewRelicTracing] a new instance of NewRelicTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

# This implementation forwards events to a notification handler (i.e.
# ActiveSupport::Notifications or Dry::Monitor::Notifications)
# with a `graphql` suffix.
#
# @see KEYS for event names
class GraphQL::Tracing::NotificationsTracing
  # Initialize a new NotificationsTracing instance
  #
  # @param notifications_engine [Object] The notifications engine to use
  # @return [NotificationsTracing] a new instance of NotificationsTracing
  def initialize(notifications_engine); end

  # Sends a GraphQL tracing event to the notification handler
  #
  # . notifications_engine = Dry::Monitor::Notifications.new(:graphql)
  # . tracer = GraphQL::Tracing::NotificationsTracing.new(notifications_engine)
  # . tracer.trace("lex") { ... }
  #
  # @param key [string] The key for the event
  # @param metadata [Hash] The metadata for the event
  # @yield The block to execute for the event
  def trace(key, metadata, &blk); end
end

# A cache of frequently-used keys to avoid needless string allocations
GraphQL::Tracing::NotificationsTracing::KEYS = T.let(T.unsafe(nil), Hash)

GraphQL::Tracing::NotificationsTracing::MAX_KEYS_SIZE = T.let(T.unsafe(nil), Integer)

module GraphQL::Tracing::NullTracer
  private

  def trace(k, v); end

  class << self
    def trace(k, v); end
  end
end

# Each platform provides:
# - `.platform_keys`
# - `#platform_trace`
# - `#platform_field_key(type, field)`
#
# @api private
class GraphQL::Tracing::PlatformTracing
  # @api private
  # @return [PlatformTracing] a new instance of PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  # @api private
  def instrument(type, field); end

  # @api private
  def trace(key, data); end

  # @api private
  def trace_field(type, field); end

  private

  # Different kind of schema objects have different kinds of keys:
  #
  # - Object types: `.authorized`
  # - Union/Interface types: `.resolve_type`
  # - Fields: execution
  #
  # So, they can all share one cache.
  #
  # If the key isn't present, the given block is called and the result is cached for `key`.
  #
  # @api private
  # @return [String]
  def cached_platform_key(ctx, key); end

  # @api private
  def fallback_transaction_name(context); end

  # @api private
  def options; end

  # Get the transaction name based on the operation type and name if possible, or fall back to a user provided
  # one. Useful for anonymous queries.
  #
  # @api private
  def transaction_name(query); end

  class << self
    # @api private
    def platform_keys; end

    # @api private
    def platform_keys=(_arg0); end

    # @api private
    def use(schema_defn, options = T.unsafe(nil)); end
  end
end

class GraphQL::Tracing::PrometheusTracing < ::GraphQL::Tracing::PlatformTracing
  # @return [PrometheusTracing] a new instance of PrometheusTracing
  def initialize(opts = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data, &block); end

  private

  def instrument_execution(platform_key, key, data, &block); end
  def observe(platform_key, key, duration); end
end

GraphQL::Tracing::PrometheusTracing::DEFAULT_COLLECTOR_TYPE = T.let(T.unsafe(nil), String)
GraphQL::Tracing::PrometheusTracing::DEFAULT_WHITELIST = T.let(T.unsafe(nil), Array)

class GraphQL::Tracing::ScoutTracing < ::GraphQL::Tracing::PlatformTracing
  # @param set_transaction_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
  #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
  #   It can also be specified per-query with `context[:set_scout_transaction_name]`.
  # @return [ScoutTracing] a new instance of ScoutTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

GraphQL::Tracing::ScoutTracing::INSTRUMENT_OPTS = T.let(T.unsafe(nil), Hash)

class GraphQL::Tracing::SkylightTracing < ::GraphQL::Tracing::PlatformTracing
  # @param set_endpoint_name [Boolean] If true, the GraphQL operation name will be used as the endpoint name.
  #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
  #   It can also be specified per-query with `context[:set_skylight_endpoint_name]`.
  # @return [SkylightTracing] a new instance of SkylightTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::StatsdTracing < ::GraphQL::Tracing::PlatformTracing
  # @param statsd [Object] A statsd client
  # @return [StatsdTracing] a new instance of StatsdTracing
  def initialize(statsd:, **rest); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

# Objects may include traceable to gain a `.trace(...)` method.
# The object must have a `@tracers` ivar of type `Array<<#trace(k, d, &b)>>`.
#
# @api private
module GraphQL::Tracing::Traceable
  # @api private
  # @param key [String] The name of the event in GraphQL internals
  # @param metadata [Hash] Event-related metadata (can be anything)
  # @return [Object] Must return the value of the block
  def trace(key, metadata, &block); end

  private

  # If there's a tracer at `idx`, call it and then increment `idx`.
  # Otherwise, yield.
  #
  # @api private
  # @param idx [Integer] Which tracer to call
  # @param key [String] The current event name
  # @param metadata [Object] The current event object
  # @return Whatever the block returns
  def call_tracers(idx, key, metadata, &block); end
end

# Type kinds are the basic categories which a type may belong to (`Object`, `Scalar`, `Union`...)
module GraphQL::TypeKinds; end

GraphQL::TypeKinds::ENUM = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::INPUT_OBJECT = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::INTERFACE = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::LIST = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::NON_NULL = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::OBJECT = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::SCALAR = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::TYPE_KINDS = T.let(T.unsafe(nil), Array)

# These objects are singletons, eg `GraphQL::TypeKinds::UNION`, `GraphQL::TypeKinds::SCALAR`.
class GraphQL::TypeKinds::TypeKind
  # @return [TypeKind] a new instance of TypeKind
  def initialize(name, abstract: T.unsafe(nil), fields: T.unsafe(nil), wraps: T.unsafe(nil), input: T.unsafe(nil), description: T.unsafe(nil)); end

  # Is this TypeKind abstract?
  #
  # @return [Boolean]
  def abstract?; end

  # Is this TypeKind composed of many values?
  #
  # @return [Boolean]
  def composite?; end

  # Returns the value of attribute description.
  def description; end

  # @return [Boolean]
  def enum?; end

  # Does this TypeKind have queryable fields?
  #
  # @return [Boolean]
  def fields?; end

  # Is this TypeKind a valid query input?
  #
  # @return [Boolean]
  def input?; end

  # @return [Boolean]
  def input_object?; end

  # @return [Boolean]
  def interface?; end

  # @return [Boolean]
  def list?; end

  # Returns the value of attribute name.
  def name; end

  # @return [Boolean]
  def non_null?; end

  # @return [Boolean]
  def object?; end

  # Does this TypeKind have multiple possible implementors?
  #
  # @deprecated Use `abstract?` instead of `resolves?`.
  # @return [Boolean]
  def resolves?; end

  # @return [Boolean]
  def scalar?; end

  def to_s; end

  # @return [Boolean]
  def union?; end

  # Does this TypeKind modify another type?
  #
  # @return [Boolean]
  def wraps?; end
end

GraphQL::TypeKinds::UNION = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
module GraphQL::Types; end

class GraphQL::Types::BigInt < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
    def parse_int(value); end
  end
end

class GraphQL::Types::Boolean < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::Float < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::ID < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

# This scalar takes `Date`s and transmits them as strings,
# using ISO 8601 format.
#
# Use it for fields or arguments as follows:
#
#     field :published_at, GraphQL::Types::ISO8601Date, null: false
#
#     argument :deliver_at, GraphQL::Types::ISO8601Date, null: false
#
# Alternatively, use this built-in scalar as inspiration for your
# own Date type.
class GraphQL::Types::ISO8601Date < ::GraphQL::Schema::Scalar
  class << self
    # @param str_value [String, Date, DateTime, Time]
    # @return [Date]
    def coerce_input(value, ctx); end

    # @param value [Date, Time, DateTime, String]
    # @return [String]
    def coerce_result(value, _ctx); end
  end
end

# This scalar takes `Time`s and transmits them as strings,
# using ISO 8601 format.
#
# Use it for fields or arguments as follows:
#
#     field :created_at, GraphQL::Types::ISO8601DateTime, null: false
#
#     argument :deliver_at, GraphQL::Types::ISO8601DateTime, null: false
#
# Alternatively, use this built-in scalar as inspiration for your
# own DateTime type.
class GraphQL::Types::ISO8601DateTime < ::GraphQL::Schema::Scalar
  class << self
    # @param str_value [String]
    # @return [Time]
    def coerce_input(str_value, _ctx); end

    # @param value [Time, Date, DateTime, String]
    # @return [String]
    def coerce_result(value, _ctx); end

    # @return [Integer]
    def time_precision; end

    # @param value [Integer]
    def time_precision=(value); end
  end
end

# It's not compatible with Rails' default,
# i.e. ActiveSupport::JSON::Encoder.time_precision (3 by default)
GraphQL::Types::ISO8601DateTime::DEFAULT_TIME_PRECISION = T.let(T.unsafe(nil), Integer)

# @see {Types::BigInt} for handling integers outside 32-bit range.
class GraphQL::Types::Int < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, ctx); end
    def coerce_result(value, ctx); end
  end
end

GraphQL::Types::Int::MAX = T.let(T.unsafe(nil), Integer)
GraphQL::Types::Int::MIN = T.let(T.unsafe(nil), Integer)

# An untyped JSON scalar that maps to Ruby hashes, arrays, strings, integers, floats, booleans and nils.
# This should be used judiciously because it subverts the GraphQL type system.
#
# Use it for fields or arguments as follows:
#
#     field :template_parameters, GraphQL::Types::JSON, null: false
#
#     argument :template_parameters, GraphQL::Types::JSON, null: false
class GraphQL::Types::JSON < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _context); end
    def coerce_result(value, _context); end
  end
end

# This module contains some types and fields that could support Relay conventions in GraphQL.
#
# You can use these classes out of the box if you want, but if you want to use your _own_
# GraphQL extensions along with the features in this code, you could also
# open up the source files and copy the relevant methods and configuration into
# your own classes.
#
# For example, the provided object types extend {Types::Relay::BaseObject},
# but you might want to:
#
# 1. Migrate the extensions from {Types::Relay::BaseObject} into _your app's_ base object
# 2. Copy {Relay::BaseConnection}, {Relay::BaseEdge}, etc into _your app_, and
#   change them to extend _your_ base object.
#
# Similarly, `BaseField`'s extensions could be migrated to your app
# and `Node` could be implemented to mix in your base interface module.
module GraphQL::Types::Relay
  class << self
    # Don't use this directly, instead, use one of these:
    #
    # @example Adding this field directly
    #   include GraphQL::Types::Relay::HasNodesField
    # @example Implementing a similar field in your own Query root
    #
    #   field :nodes, [GraphQL::Types::Relay::Node, null: true], null: false,
    #   description: Fetches a list of objects given a list of IDs." do
    #   argument :ids, [ID], required: true
    #   end
    #
    #   def nodes(ids:)
    #   ids.map do |id|
    #   context.schema.object_from_id(context, id)
    #   end
    #   end
    def const_missing(const_name); end
  end
end

# Use this to implement Relay connections, or take it as inspiration
# for Relay classes in your own app.
#
# You may wish to copy this code into your own base class,
# so you can extend your own `BaseObject` instead of `GraphQL::Schema::Object`.
#
# @example Implementation a connection and edge
#   # Given some object in your app ...
#   class Types::Post < BaseObject
#   end
#
#   # Make a couple of base classes:
#   class Types::BaseEdge < GraphQL::Types::Relay::BaseEdge; end
#   class Types::BaseConnection < GraphQL::Types::Relay::BaseConnection; end
#
#   # Then extend them for the object in your app
#   class Types::PostEdge < Types::BaseEdge
#   node_type(Types::Post)
#   end
#   class Types::PostConnection < Types::BaseConnection
#   edge_type(Types::PostEdge)
#   edges_nullable(true)
#   edge_nullable(true)
#   node_nullable(true)
#   has_nodes_field(true)
#   end
# @see Relay::BaseEdge for edge types
class GraphQL::Types::Relay::BaseConnection < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::ConnectionBehaviors
  extend ::GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  extend ::GraphQL::Types::Relay::DefaultRelay
end

class GraphQL::Types::Relay::BaseConnection::InvalidNullError < ::GraphQL::InvalidNullError; end

# A class-based definition for Relay edges.
#
# Use this as a parent class in your app, or use it as inspiration for your
# own base `Edge` class.
#
# For example, you may want to extend your own `BaseObject` instead of the
# built-in `GraphQL::Schema::Object`.
#
# @example Making a UserEdge type
#   # Make a base class for your app
#   class Types::BaseEdge < GraphQL::Types::Relay::BaseEdge
#   end
#
#   # Then extend your own base class
#   class Types::UserEdge < Types::BaseEdge
#   node_type(Types::User)
#   end
# @see {Relay::BaseConnection} for connection types
class GraphQL::Types::Relay::BaseEdge < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::EdgeBehaviors
  extend ::GraphQL::Types::Relay::EdgeBehaviors::ClassMethods
end

class GraphQL::Types::Relay::BaseEdge::InvalidNullError < ::GraphQL::InvalidNullError; end

module GraphQL::Types::Relay::ConnectionBehaviors
  extend ::Forwardable

  mixes_in_class_methods ::GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  def cursor_from_node(*args, **_arg1, &block); end
  def edges; end

  # By default this calls through to the ConnectionWrapper's edge nodes method,
  # but sometimes you need to override it to support the `nodes` field
  def nodes; end

  def parent(*args, **_arg1, &block); end

  class << self
    def add_page_info_field(obj_type); end

    # @private
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  # @return [Boolean]
  def accessible?(ctx); end

  # @return [Boolean]
  def authorized?(obj, ctx); end

  # @return [Class]
  def edge_class; end

  # Set the default `edge_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `edge_nullable(false)` in your base class to make non-null `edge` fields.
  def edge_nullable(new_value = T.unsafe(nil)); end

  # Configure this connection to return `edges` and `nodes` based on `edge_type_class`.
  #
  # This method will use the inputs to create:
  # - `edges` field
  # - `nodes` field
  # - description
  #
  # It's called when you subclass this base connection, trying to use the
  # class name to set defaults. You can call it again in the class definition
  # to override the default (or provide a value, if the default lookup failed).
  #
  # @param field_options [Hash] Any extra keyword arguments to pass to the `field :edges, ...` and `field :nodes, ...` configurations
  def edge_type(edge_type_class, edge_class: T.unsafe(nil), node_type: T.unsafe(nil), nodes_field: T.unsafe(nil), node_nullable: T.unsafe(nil), edges_nullable: T.unsafe(nil), edge_nullable: T.unsafe(nil), field_options: T.unsafe(nil)); end

  # Set the default `edges_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `edges_nullable(false)` in your base class to make non-null `edges` fields.
  def edges_nullable(new_value = T.unsafe(nil)); end

  # Set the default `nodes_field` for this class and its child classes. (Defaults to `true`.)
  # Use `nodes_field(false)` in your base class to prevent adding of a nodes field.
  def has_nodes_field(new_value = T.unsafe(nil)); end

  # Set the default `node_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `node_nullable(false)` in your base class to make non-null `node` and `nodes` fields.
  def node_nullable(new_value = T.unsafe(nil)); end

  # @return [Class]
  def node_type; end

  # Add the shortcut `nodes` field to this connection and its subclasses
  def nodes_field(node_nullable: T.unsafe(nil), field_options: T.unsafe(nil)); end

  # Filter this list according to the way its node type would scope them
  def scope_items(items, context); end

  # @return [Boolean]
  def visible?(ctx); end

  private

  def define_nodes_field(nullable, field_options: T.unsafe(nil)); end
end

module GraphQL::Types::Relay::DefaultRelay
  def default_relay(new_value); end

  # @return [Boolean]
  def default_relay?; end

  def to_graphql; end

  class << self
    # @private
    def extended(child_class); end
  end
end

# Don't use this field directly, instead, use one of these approaches:
#
# @example Adding this field directly
#   include GraphQL::Types::Relay::HasNodeField
# @example Implementing a similar field in your own Query root
#
#   field :node, GraphQL::Types::Relay::Node, null: true,
#   description: "Fetches an object given its ID" do
#   argument :id, ID, required: true
#   end
#
#   def node(id:)
#   context.schema.object_from_id(id, context)
#   end
GraphQL::Types::Relay::DeprecatedNodeField = T.let(T.unsafe(nil), GraphQL::Schema::Field)

GraphQL::Types::Relay::DeprecatedNodesField = T.let(T.unsafe(nil), GraphQL::Schema::Field)

module GraphQL::Types::Relay::EdgeBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::EdgeBehaviors::ClassMethods

  class << self
    # @private
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::EdgeBehaviors::ClassMethods
  # @return [Boolean]
  def accessible?(ctx); end

  # @return [Boolean]
  def authorized?(obj, ctx); end

  # Set the default `node_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `node_nullable(false)` in your base class to make non-null `node` field.
  def node_nullable(new_value = T.unsafe(nil)); end

  # Get or set the Object type that this edge wraps.
  #
  # @param node_type [Class] A `Schema::Object` subclass
  # @param null [Boolean]
  # @param field_options [Hash] Any extra arguments to pass to the `field :node` configuration
  def node_type(node_type = T.unsafe(nil), null: T.unsafe(nil), field_options: T.unsafe(nil)); end

  # @return [Boolean]
  def visible?(ctx); end
end

# Include this module to your root Query type to get a Relay-compliant `node(id: ID!): Node` field that uses the schema's `object_from_id` hook.
module GraphQL::Types::Relay::HasNodeField
  class << self
    def field_block; end
    def field_options; end

    # @private
    def included(child_class); end
  end
end

# Include this module to your root Query type to get a Relay-style `nodes(id: ID!): [Node]` field that uses the schema's `object_from_id` hook.
module GraphQL::Types::Relay::HasNodesField
  class << self
    def field_block; end
    def field_options; end

    # @private
    def included(child_class); end
  end
end

# This can be used for Relay's `Node` interface,
# or you can take it as inspiration for your own implementation
# of the `Node` interface.
module GraphQL::Types::Relay::Node
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Types::Relay::NodeBehaviors
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::HasDirectives
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition::DeprecatedToGraphQL
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::Node::DefinitionMethods
  extend ::GraphQL::Types::Relay::DefaultRelay
end

module GraphQL::Types::Relay::Node::DefinitionMethods; end
class GraphQL::Types::Relay::Node::UnresolvedTypeError < ::GraphQL::UnresolvedTypeError; end

module GraphQL::Types::Relay::NodeBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  class << self
    # @private
    def included(child_module); end
  end
end

# The return type of a connection's `pageInfo` field
class GraphQL::Types::Relay::PageInfo < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::PageInfoBehaviors
  extend ::GraphQL::Types::Relay::DefaultRelay
end

class GraphQL::Types::Relay::PageInfo::InvalidNullError < ::GraphQL::InvalidNullError; end

module GraphQL::Types::Relay::PageInfoBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  class << self
    # @private
    def included(child_class); end
  end
end

class GraphQL::Types::String < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, ctx); end
  end
end

# When an `authorized?` hook returns false, this error is used to communicate the failure.
# It's passed to {Schema.unauthorized_object}.
#
# Alternatively, custom code in `authorized?` may raise this error. It will be routed the same way.
class GraphQL::UnauthorizedError < ::GraphQL::Error
  # @return [UnauthorizedError] a new instance of UnauthorizedError
  def initialize(message = T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil)); end

  # @return [GraphQL::Query::Context] the context for the current query
  def context; end

  # @return [GraphQL::Query::Context] the context for the current query
  def context=(_arg0); end

  # @return [Object] the application object that failed the authorization check
  def object; end

  # @return [Class] the GraphQL object type whose `.authorized?` method was called (and returned false)
  def type; end
end

class GraphQL::UnauthorizedFieldError < ::GraphQL::UnauthorizedError
  # @return [UnauthorizedFieldError] a new instance of UnauthorizedFieldError
  def initialize(message = T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil), field: T.unsafe(nil)); end

  # @return [Field] the field that failed the authorization check
  def field; end

  # @return [Field] the field that failed the authorization check
  def field=(_arg0); end
end

# @api deprecated
class GraphQL::UnionType < ::GraphQL::BaseType
  extend ::GraphQL::Define::InstanceDefinable::DeprecatedDefine

  # @api deprecated
  # @return [UnionType] a new instance of UnionType
  def initialize; end

  # @api deprecated
  def add_possible_types(types, **options); end

  # Get a possible type of this {UnionType} by type name
  #
  # @api deprecated
  # @param type_name [String]
  # @param ctx [GraphQL::Query::Context] The context for the current query
  # @return [GraphQL::ObjectType, nil] The type named `type_name` if it exists and is a member of this {UnionType}, (else `nil`)
  def get_possible_type(type_name, ctx); end

  # @api deprecated
  # @return [Boolean] True if `child_type_defn` is a member of this {UnionType}
  def include?(child_type_defn, ctx = T.unsafe(nil)); end

  # @api deprecated
  def kind; end

  # Check if a type is a possible type of this {UnionType}
  #
  # @api deprecated
  # @param type [String, GraphQL::BaseType] Name of the type or a type definition
  # @param ctx [GraphQL::Query::Context] The context for the current query
  # @return [Boolean] True if the `type` exists and is a member of this {UnionType}, (else `nil`)
  def possible_type?(type, ctx); end

  # @api deprecated
  # @return [Array<GraphQL::ObjectType>] Types which may be found in this union
  def possible_types(ctx = T.unsafe(nil)); end

  # @api deprecated
  def possible_types=(types); end

  # @api deprecated
  def resolve_type(value, ctx); end

  # @api deprecated
  def resolve_type=(new_resolve_type_proc); end

  # @api deprecated
  def resolve_type_proc; end

  # @api deprecated
  def resolve_type_proc=(_arg0); end

  # @api deprecated
  def type_membership_class; end

  # @api deprecated
  def type_membership_class=(_arg0); end

  # @api deprecated
  def type_memberships; end

  # @api deprecated
  def type_memberships=(type_memberships); end

  private

  # @api deprecated
  def initialize_copy(other); end

  # @api deprecated
  def possible_types_for_context(ctx); end
end

# Rubocop was unhappy about the syntax when this was a proc literal
#
# @api deprecated
class GraphQL::UnionType::AcceptPossibleTypesDefinition
  class << self
    # @api deprecated
    def call(target, possible_types, options = T.unsafe(nil)); end
  end
end

# Error raised when the value provided for a field
# can't be resolved to one of the possible types for the field.
class GraphQL::UnresolvedTypeError < ::GraphQL::RuntimeTypeError
  # @return [UnresolvedTypeError] a new instance of UnresolvedTypeError
  def initialize(value, field, parent_type, resolved_type, possible_types); end

  # @return [GraphQL::Field] The field whose value couldn't be resolved (`field.type` is type which couldn't be resolved)
  def field; end

  # @return [GraphQL::BaseType] The owner of `field`
  def parent_type; end

  # @return [Array<GraphQL::BaseType>] The allowed options for resolving `value` to `field.type`
  def possible_types; end

  # @return [Object] The return of {Schema#resolve_type} for `value`
  def resolved_type; end

  # @return [Object] The runtime value which couldn't be successfully resolved with `resolve_type`
  def value; end
end

GraphQL::VERSION = T.let(T.unsafe(nil), String)
