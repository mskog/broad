# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mustermann` gem.
# Please instead update this file by running `bin/tapioca gem mustermann`.

# Namespace and main entry point for the Mustermann library.
#
# Under normal circumstances the only external API entry point you should be using is {Mustermann.new}.
module Mustermann
  class << self
    # Maps a type to its factory.
    #
    # @example
    #   Mustermann[:sinatra] # => Mustermann::Sinatra
    # @param name [Symbol] a pattern type identifier
    # @raise [ArgumentError] if the type is not supported
    # @return [Class, #new] pattern factory
    def [](name); end

    def extend_object(object); end

    # Creates a new pattern based on input.
    #
    # * From {Mustermann::Pattern}: returns given pattern.
    # * From String: creates a pattern from the string, depending on type option (defaults to {Mustermann::Sinatra})
    # * From Regexp: creates a {Mustermann::Regular} pattern.
    # * From Symbol: creates a {Mustermann::Sinatra} pattern with a single named capture named after the input.
    # * From an Array or multiple inputs: creates a new pattern from each element, combines them to a {Mustermann::Composite}.
    # * From anything else: Will try to call to_pattern on it or raise a TypeError.
    #
    # Note that if the input is a {Mustermann::Pattern}, Regexp or Symbol, the type option is ignored and if to_pattern is
    # called on the object, the type will be handed on but might be ignored by the input object.
    #
    # If you want to enforce the pattern type, you should create them via their expected class.
    #
    # @example creating patterns
    #   require 'mustermann'
    #
    #   Mustermann.new("/:name")                    # => #<Mustermann::Sinatra:"/example">
    #   Mustermann.new("/{name}", type: :template)  # => #<Mustermann::Template:"/{name}">
    #   Mustermann.new(/.*/)                        # => #<Mustermann::Regular:".*">
    #   Mustermann.new(:name, capture: :word)       # => #<Mustermann::Sinatra:":name">
    #   Mustermann.new("/", "/*.jpg", type: :shell) # => #<Mustermann::Composite:(shell:"/" | shell:"/*.jpg")>
    # @example using custom #to_pattern
    #   require 'mustermann'
    #
    #   class MyObject
    #   def to_pattern(**options)
    #   Mustermann.new("/:name", **options)
    #   end
    #   end
    #
    #   Mustermann.new(MyObject.new, type: :rails) # => #<Mustermann::Rails:"/:name">
    # @example enforcing type
    #   require 'mustermann/sinatra'
    #
    #   Mustermann::Sinatra.new("/:name")
    # @param input [String, Pattern, Regexp, Symbol, #to_pattern, Array<String, Pattern, Regexp, Symbol, #to_pattern>] The representation of the pattern
    # @param options [Hash] The options hash
    # @raise [TypeError] if the passed object cannot be converted to a pattern
    # @raise [ArgumentError] if the type is not supported
    # @raise [ArgumentError] if some option is not supported
    # @raise [Mustermann::Error] if the pattern can't be generated from the string
    # @return [Mustermann::Pattern] pattern corresponding to string.
    # @see file:README.md#Types_and_Options "Types and Options" in the README
    def new(*input, type: T.unsafe(nil), operator: T.unsafe(nil), **options); end

    def normalized_type(type); end
    def register(name, type); end

    # @return [LoadError, nil]
    def try_require(path); end
  end
end

# @see Mustermann::AST::Pattern
module Mustermann::AST; end

# Make sure #start and #stop is set on every node and within its parents #start and #stop.
class Mustermann::AST::Boundaries < ::Mustermann::AST::Translator
  # Checks that a node is within the given boundaries.
  def set_boundaries(node, start, stop); end

  class << self
    # @return [Mustermann::AST::Node] the ast passed as first argument
    def set_boundaries(ast, string: T.unsafe(nil), start: T.unsafe(nil), stop: T.unsafe(nil)); end
  end
end

class Mustermann::AST::Boundaries::NodeTranslator < ::Mustermann::AST::Translator::NodeTranslator
  class << self
    def translator; end
  end
end

# Regexp compilation logic.
class Mustermann::AST::Compiler < ::Mustermann::AST::Translator
  # Compiles an AST to a regular expression.
  #
  # @param ast [Mustermann::AST::Node] the tree
  # @return [Regexp] corresponding regular expression.
  def compile(ast, except: T.unsafe(nil), **options); end

  # @return [String] Regular expression for matching the given character in all representations
  def encoded(char, uri_decode: T.unsafe(nil), space_matches_plus: T.unsafe(nil), **options); end

  def error_class; end

  class << self
    # Compiles an AST to a regular expression.
    #
    # @param ast [Mustermann::AST::Node] the tree
    # @return [Regexp] corresponding regular expression.
    def compile(ast, **options); end
  end
end

# Capture compilation is complex. :(
class Mustermann::AST::Compiler::Capture < ::Mustermann::AST::Compiler::NodeTranslator
  # @return [String] regexp without the named capture
  def pattern(capture: T.unsafe(nil), **options); end

  def translate(**options); end

  private

  def default(**options); end
  def from_array(array, **options); end
  def from_hash(hash, **options); end
  def from_nil(**options); end
  def from_string(string, **options); end
  def from_symbol(symbol, **options); end
  def qualified(string, greedy: T.unsafe(nil), **options); end
  def with_lookahead(string, lookahead: T.unsafe(nil), **options); end
end

class Mustermann::AST::Compiler::NodeTranslator < ::Mustermann::AST::Translator::NodeTranslator
  class << self
    def translator; end
  end
end

class Mustermann::AST::Compiler::Splat < ::Mustermann::AST::Compiler::Capture
  # splats are always non-greedy
  def pattern(**options); end
end

class Mustermann::AST::Compiler::Variable < ::Mustermann::AST::Compiler::Capture
  def default(allow_reserved: T.unsafe(nil), **options); end
  def parametric(string); end
  def pattern(parametric: T.unsafe(nil), separator: T.unsafe(nil), **options); end
  def qualified(string, **options); end
  def register_param(parametric: T.unsafe(nil), split_params: T.unsafe(nil), separator: T.unsafe(nil), **options); end
  def translate(**options); end
end

# Looks at an AST, remembers the important bits of information to do an
# ultra fast expansion.
class Mustermann::AST::Expander < ::Mustermann::AST::Translator
  # add a tree for expansion
  def add(ast); end

  # Creates the product of two of our secret internal data structures.
  def add_to(list, result); end

  def error_class; end

  # helper method for raising an error for unexpandable values
  #
  # @raise [error_class]
  def error_for(values); end

  # @see Mustermann::AST::Translator#expand
  def escape(string, *args, **_arg2); end

  # @see Mustermann::Pattern#expand
  def expand(values); end

  # @return [Boolean]
  # @see Mustermann::Pattern#expandable?
  def expandable?(values); end

  # @see Mustermann::Expander#with_rest
  def expandable_keys(keys); end

  # helper method for captures
  def for_capture(node, **options); end

  # all the known keys
  def keys; end

  # maps sorted key list to sprintf patterns and filters
  def mappings; end

  # Turns a sprintf pattern into our secret internal data structure.
  def pattern(string = T.unsafe(nil), *keys, **filters); end

  # helper method for getting a capture's pattern.
  def pattern_for(node, **options); end
end

class Mustermann::AST::Expander::NodeTranslator < ::Mustermann::AST::Translator::NodeTranslator
  class << self
    def translator; end
  end
end

class Mustermann::AST::Node
  # @return [Node] a new instance of Node
  def initialize(payload = T.unsafe(nil), **options); end

  # Loop through all nodes that don't have child nodes.
  #
  # @yield [_self]
  # @yieldparam _self [Mustermann::AST::Node] the object that the method was called on
  def each_leaf(&block); end

  # @return [Boolean]
  def is_a?(type); end

  # @return [Integer] length of the substring
  def length; end

  # @return [Integer] minimum size for a node
  def min_size; end

  # Double dispatch helper for reading from the buffer into the payload.
  def parse; end

  # Returns the value of attribute payload.
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  def payload=(_arg0); end

  # Returns the value of attribute start.
  def start; end

  # Sets the attribute start
  #
  # @param value the value to set the attribute start to.
  def start=(_arg0); end

  # Returns the value of attribute stop.
  def stop; end

  # Sets the attribute stop
  #
  # @param value the value to set the attribute stop to.
  def stop=(_arg0); end

  # Turns a class name into a node identifier.
  def type; end

  class << self
    # @param name [Symbol] of the node
    # @return [Class] factory for the node
    def [](name); end

    # @param name [Symbol] of the node
    # @return [String] qualified name of factory for the node
    def constant_name(name); end

    # Helper for creating a new instance and calling #parse on it.
    #
    # @return [Mustermann::AST::Node]
    def parse(*args, &block); end

    # Turns a class name into a node identifier.
    def type; end
  end
end

class Mustermann::AST::Node::Capture < ::Mustermann::AST::Node
  # @see Mustermann::AST::Compiler::Capture#default
  def constraint; end

  # @see Mustermann::AST::Compiler::Capture#default
  def constraint=(_arg0); end

  # @see Mustermann::AST::Pattern#map_param
  def convert; end

  # @see Mustermann::AST::Pattern#map_param
  def convert=(_arg0); end

  def name; end

  # @see Mustermann::AST::Node#parse
  def parse; end

  # @see Mustermann::AST::Compiler::Capture#qualified
  def qualifier; end

  # @see Mustermann::AST::Compiler::Capture#qualified
  def qualifier=(_arg0); end
end

class Mustermann::AST::Node::Char < ::Mustermann::AST::Node
  # @return [Integer] minimum size for a node
  def min_size; end
end

class Mustermann::AST::Node::Composition < ::Mustermann::AST::Node
  # @return [Composition] a new instance of Composition
  def initialize(payload = T.unsafe(nil), **options); end
end

# AST node for template expressions.
class Mustermann::AST::Node::Expression < ::Mustermann::AST::Node
  # Returns the value of attribute operator.
  def operator; end

  # Sets the attribute operator
  #
  # @param value the value to set the attribute operator to.
  def operator=(_arg0); end
end

class Mustermann::AST::Node::Group < ::Mustermann::AST::Node::Composition; end

class Mustermann::AST::Node::NamedSplat < ::Mustermann::AST::Node::Splat
  # @see Mustermann::AST::Node::Capture#name
  def name; end
end

class Mustermann::AST::Node::Optional < ::Mustermann::AST::Node; end
class Mustermann::AST::Node::Or < ::Mustermann::AST::Node; end

class Mustermann::AST::Node::Root < ::Mustermann::AST::Node
  # Returns the value of attribute pattern.
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  def pattern=(_arg0); end

  class << self
    # Will trigger transform.
    #
    # @see Mustermann::AST::Node.parse
    def parse(string, &block); end
  end
end

class Mustermann::AST::Node::Separator < ::Mustermann::AST::Node
  # @return [Integer] minimum size for a node
  def min_size; end
end

class Mustermann::AST::Node::Splat < ::Mustermann::AST::Node::Capture
  # @see Mustermann::AST::Node::Capture#name
  def name; end
end

class Mustermann::AST::Node::Union < ::Mustermann::AST::Node::Composition; end

# AST node for template variables.
class Mustermann::AST::Node::Variable < ::Mustermann::AST::Node::Capture
  # Returns the value of attribute explode.
  def explode; end

  # Sets the attribute explode
  #
  # @param value the value to set the attribute explode to.
  def explode=(_arg0); end

  # Returns the value of attribute prefix.
  def prefix; end

  # Sets the attribute prefix
  #
  # @param value the value to set the attribute prefix to.
  def prefix=(_arg0); end
end

class Mustermann::AST::Node::WithLookAhead < ::Mustermann::AST::Node
  # @return [WithLookAhead] a new instance of WithLookAhead
  def initialize(payload, at_end, **options); end

  # Returns the value of attribute at_end.
  def at_end; end

  # Sets the attribute at_end
  #
  # @param value the value to set the attribute at_end to.
  def at_end=(_arg0); end

  # Returns the value of attribute head.
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  def head=(_arg0); end
end

# Scans an AST for param converters.
#
# @see Mustermann::AST::Pattern#to_templates
class Mustermann::AST::ParamScanner < ::Mustermann::AST::Translator
  class << self
    def scan_params(ast); end
  end
end

class Mustermann::AST::ParamScanner::NodeTranslator < ::Mustermann::AST::Translator::NodeTranslator
  class << self
    def translator; end
  end
end

# Simple, StringScanner based parser.
class Mustermann::AST::Parser
  extend ::Forwardable

  # @return [Parser] a new instance of Parser
  def initialize(pattern: T.unsafe(nil), **options); end

  # Returns the value of attribute buffer.
  def buffer; end

  # Create a node for a character we don't have an explicit rule for.
  #
  # @param char [String] the character
  # @return [Mustermann::AST::Node] the node
  def default_node(char); end

  def eos?(*args, **_arg1, &block); end

  # Asserts a regular expression matches what's next on the buffer.
  # Will return corresponding MatchData if regexp includes named captures.
  #
  # @param regexp [Regexp] expected to match
  # @raise [Mustermann::ParseError] if expectation wasn't met
  # @return [String, MatchData] the match
  def expect(regexp, char: T.unsafe(nil), **options); end

  def getch(*args, **_arg1, &block); end

  # sets start on node to start if it's not set to a lower value.
  # sets stop on node to stop if it's not set to a higher value.
  #
  # @return [Mustermann::AST::Node] the node passed as third argument
  def min_size(start, stop, node); end

  # @example
  #   node(:char, 'x').compile =~ 'x' # => true
  # @param type [Symbol] node type
  # @return [Mustermann::AST::Node]
  def node(type, *args, **_arg2, &block); end

  # @param string [String] to be parsed
  # @return [Mustermann::AST::Node] parse tree for string
  def parse(string); end

  # Returns the value of attribute pattern.
  def pattern; end

  def pos(*args, **_arg1, &block); end

  # Reads the next element from the buffer.
  #
  # @return [Mustermann::AST::Node] next element
  def read; end

  # Reads an argument string of the format arg1,args2,key:value
  def read_args(key_separator, close, separator: T.unsafe(nil), symbol_keys: T.unsafe(nil), **options); end

  # Allows to read a string inside brackets. It does not expect the string
  # to start with an opening bracket.
  #
  # @example
  #   buffer.string = "fo<o>>ba<r>"
  #   read_brackets(?<, ?>) # => "fo<o>"
  #   buffer.rest # => "ba<r>"
  def read_brackets(open, close, char: T.unsafe(nil), escape: T.unsafe(nil), quote: T.unsafe(nil), **options); end

  # Read a string until a terminating character, ignoring escaped versions of said character.
  def read_escaped(close, escape: T.unsafe(nil), **options); end

  # Reads a separated list with the ability to quote, escape and add spaces.
  def read_list(*close, separator: T.unsafe(nil), escape: T.unsafe(nil), quotes: T.unsafe(nil), ignore: T.unsafe(nil), **options); end

  # Checks for a potential suffix on the buffer.
  #
  # @param element [Mustermann::AST::Node] node without suffix
  # @return [Mustermann::AST::Node] node with suffix
  def read_suffix(element); end

  # Wrapper around {StringScanner#scan} that turns strings into escaped
  # regular expressions and returns a MatchData if the regexp has any
  # named captures.
  #
  # @param regexp [Regexp, String]
  # @return [String, MatchData, nil]
  # @see StringScanner#scan
  def scan(regexp); end

  # Returns the value of attribute string.
  def string; end

  # Helper for raising an exception for an unexpected character.
  # Will read character from buffer if buffer is passed in.
  #
  # @param char [String, nil] the unexpected character
  # @raise [Mustermann::ParseError, Exception]
  def unexpected(char = T.unsafe(nil), exception: T.unsafe(nil)); end

  class << self
    # Defines another grammar rule for first character.
    #
    # @see Mustermann::Rails
    # @see Mustermann::Sinatra
    # @see Mustermann::Template
    def on(*chars, &block); end

    # @param string [String] to be parsed
    # @return [Mustermann::AST::Node] parse tree for string
    def parse(string, **options); end

    # Defines another grammar rule for a suffix.
    #
    # @see Mustermann::Sinatra
    def suffix(pattern = T.unsafe(nil), after: T.unsafe(nil), &block); end
  end
end

# Superclass for pattern styles that parse an AST from the string pattern.
#
# @abstract
class Mustermann::AST::Pattern < ::Mustermann::RegexpBased
  extend ::SingleForwardable

  def boundaries(*args, **_arg1, &block); end
  def compiler(*args, **_arg1, &block); end

  # All AST-based pattern implementations support expanding.
  #
  # @example Expanding a pattern
  #   pattern = Mustermann.new('/:name(.:ext)?')
  #   pattern.expand(name: 'hello')             # => "/hello"
  #   pattern.expand(name: 'hello', ext: 'png') # => "/hello.png"
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :expand
  #   pattern.expand(name: "foo")
  #   else
  #   warn "does not support expanding"
  #   end
  # @param behavior [Symbol] What to do with additional key/value pairs not present in the values hash.
  #   Possible options: :raise, :ignore, :append.
  # @param values [Hash{Symbol: #to_s, Array<#to_s>}] Values to use for expansion.
  # @raise [NotImplementedError] raised if expand is not supported.
  # @raise [Mustermann::ExpandError] raised if a value is missing or unknown
  # @return [String] expanded string
  # @see Mustermann::Pattern#expand
  # @see Mustermann::Expander
  def expand(behavior = T.unsafe(nil), values = T.unsafe(nil)); end

  # @see Mustermann::Pattern#map_param
  def map_param(key, value); end

  def param_scanner(*args, **_arg1, &block); end
  def parser(*args, **_arg1, &block); end
  def template_generator(*args, **_arg1, &block); end

  # Internal AST representation of pattern.
  def to_ast; end

  # All AST-based pattern implementations support generating templates.
  #
  # @example generating templates
  #   Mustermann.new("/:name").to_templates                   # => ["/{name}"]
  #   Mustermann.new("/:foo(@:bar)?/*baz").to_templates       # => ["/{foo}@{bar}/{+baz}", "/{foo}/{+baz}"]
  #   Mustermann.new("/{name}", type: :template).to_templates # => ["/{name}"]
  # @example generating templates from composite patterns
  #   pattern  = Mustermann.new('/:name')
  #   pattern |= Mustermann.new('/{name}', type: :template)
  #   pattern |= Mustermann.new('/example/*nested')
  #   pattern.to_templates # => ["/{name}", "/example/{+nested}"]
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :to_templates
  #   pattern.to_templates
  #   else
  #   warn "does not support template generation"
  #   end
  # @return [Array<String>] list of URI templates
  # @see Mustermann::Pattern#to_templates
  def to_templates; end

  def transformer(*args, **_arg1, &block); end
  def validation(*args, **_arg1, &block); end

  private

  def compile(**options); end
  def generate_templates(*args, **_arg1, &block); end
  def param_converters; end
  def parse(*args, **_arg1, &block); end
  def scan_params(*args, **_arg1, &block); end
  def set_boundaries(*args, **_arg1, &block); end
  def transform(*args, **_arg1, &block); end
  def validate(*args, **_arg1, &block); end

  class << self
    # @api private
    # @return [#set_boundaries] translator making sure start and stop is set on all nodes
    def boundaries; end

    # @api private
    # @return [#compile] compiler object for pattern
    def compiler; end

    def on(*args, **_arg1, &block); end

    # @api private
    # @return [#scan_params] param scanner for pattern
    def param_scanner; end

    # @api private
    # @return [#parse] parser object for pattern
    def parser; end

    def suffix(*args, **_arg1, &block); end

    # @api private
    # @return [#generate_templates] generates URI templates for pattern
    def template_generator; end

    # @api private
    # @return [#transform] transformer object for pattern
    def transformer; end

    # @api private
    # @return [#validate] validation object for pattern
    def validation; end
  end
end

# Turns an AST into an Array of URI templates representing the AST.
#
# @see Mustermann::AST::Pattern#to_templates
class Mustermann::AST::TemplateGenerator < ::Mustermann::AST::Translator
  class << self
    def generate_templates(ast); end
  end
end

class Mustermann::AST::TemplateGenerator::NodeTranslator < ::Mustermann::AST::Translator::NodeTranslator
  class << self
    def translator; end
  end
end

# Takes a tree, turns it into an even better tree.
class Mustermann::AST::Transformer < ::Mustermann::AST::Translator
  class << self
    # Transforms a tree.
    #
    # @note might mutate handed in tree instead of creating a new one
    # @param tree [Mustermann::AST::Node] to be transformed
    # @return [Mustermann::AST::Node] transformed tree
    def transform(tree); end
  end
end

# Inserts with_look_ahead nodes wherever appropriate
class Mustermann::AST::Transformer::ArrayTransform < ::Mustermann::AST::Transformer::NodeTranslator
  # turn look ahead buffer into look ahead node
  def create_lookahead(elements, *args); end

  # can the current element deal with a look-ahead?
  #
  # @return [Boolean]
  def expect_lookahead?(element); end

  # helper method for deciding where to put an element for now
  def list_for(element); end

  # can the given element be used in a look-ahead?
  #
  # @return [Boolean]
  def lookahead?(element, in_lookahead = T.unsafe(nil)); end

  # buffer for potential look ahead
  def lookahead_buffer; end

  # does the list of elements look look-ahead-ish to you?
  #
  # @return [Boolean]
  def lookahead_payload?(payload, in_lookahead); end

  # the new array
  def payload; end

  # handle a single element from the array
  def track(element); end

  # transform the array
  def translate; end
end

# URI expression transformations depending on operator
class Mustermann::AST::Transformer::ExpressionTransform < ::Mustermann::AST::Transformer::NodeTranslator
  # Sets operator and inserts separators in between variables.
  def translate; end
end

Mustermann::AST::Transformer::ExpressionTransform::OPERATORS = T.let(T.unsafe(nil), Hash)

class Mustermann::AST::Transformer::ExpressionTransform::Operator < ::Struct
  def allow_reserved; end
  def allow_reserved=(_); end
  def parametric; end
  def parametric=(_); end
  def prefix; end
  def prefix=(_); end
  def separator; end
  def separator=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# turn a group containing or nodes into a union
class Mustermann::AST::Transformer::GroupTransformer < ::Mustermann::AST::Transformer::NodeTranslator
  def group(elements); end
  def split_payload; end
  def translate; end
  def union; end
end

class Mustermann::AST::Transformer::NodeTranslator < ::Mustermann::AST::Translator::NodeTranslator
  class << self
    def translator; end
  end
end

# inject a union node right inside the root node if it contains or nodes
class Mustermann::AST::Transformer::RootTransformer < ::Mustermann::AST::Transformer::GroupTransformer
  def union; end
end

# Implements translator pattern
#
# @abstract
class Mustermann::AST::Translator
  # @param node [Mustermann::AST::Node, Object] to translate
  # @raise [error_class]
  # @return decorator encapsulating translation
  def decorator_for(node); end

  def error_class; end

  # @return [String] escaped character
  def escape(char, parser: T.unsafe(nil), escape: T.unsafe(nil), also_escape: T.unsafe(nil)); end

  # Start the translation dance for a (sub)tree.
  def translate(node, *args, **_arg2, &block); end

  class << self
    # Enables quick creation of a translator object.
    #
    # @example
    #   require 'mustermann'
    #   require 'mustermann/ast/translator'
    #
    #   translator = Mustermann::AST::Translator.create do
    #   translate(:node)  { [type, *t(payload)].flatten.compact }
    #   translate(Array)  { map { |e| t(e) } }
    #   translate(Object) { }
    #   end
    #
    #   ast = Mustermann.new('/:name').to_ast
    #   translator.translate(ast) # => [:root, :separator, :capture]
    def create(&block); end

    # maps types to translations
    def dispatch_table; end

    # some magic sauce so {NodeTranslator}s know whom to talk to for {#register}
    def inherited(subclass); end

    # DSL-ish method for specifying the exception class to use.
    def raises(error); end

    # DSL method for defining single method translations.
    def translate(*types, &block); end
  end
end

# Encapsulates a single node translation
class Mustermann::AST::Translator::NodeTranslator
  # @param node [Mustermann::AST::Node, Object]
  # @param translator [Mustermann::AST::Translator]
  # @return [NodeTranslator] a new instance of NodeTranslator
  def initialize(node, translator); end

  def node; end

  # shorthand for translating a nested object
  def t(*args, **_arg1, &block); end

  # Returns the value of attribute translator.
  def translator; end

  class << self
    # @param types [Array<Symbol, Class>] list of types to register for.
    def register(*types); end
  end
end

# Checks the AST for certain validations, like correct capture names.
#
# Internally a poor man's visitor (abusing translator to not have to implement a visitor).
class Mustermann::AST::Validation < ::Mustermann::AST::Translator
  # @raise [Mustermann::CompileError] if name is not acceptable
  def check_name(name, forbidden: T.unsafe(nil)); end

  # @return [Array<String>] list of capture names in tree
  def names; end

  class << self
    # Runs validations.
    #
    # @param ast [Mustermann::AST::Node] to be validated
    # @raise [Mustermann::AST::CompileError] if validation fails
    # @return [Mustermann::AST::Node] the validated ast
    def validate(ast); end
  end
end

class Mustermann::AST::Validation::NodeTranslator < ::Mustermann::AST::Translator::NodeTranslator
  class << self
    def translator; end
  end
end

# Class for defining and running simple Hash transformations.
#
# @example
#   caster = Mustermann::Caster.new
#   caster.register(:foo) { |value| { bar: value.upcase } }
#   caster.cast(foo: "hello", baz: "world") # => { bar: "HELLO", baz: "world" }
# @see Mustermann::Expander#cast
class Mustermann::Caster
  # @param types [Array<Symbol, Regexp, #cast, #===>] identifier for cast type (some need block)
  # @return [Caster] a new instance of Caster
  def initialize(*types, &block); end

  # Transforms a Hash.
  #
  # @param hash [Hash] pre-transform Hash
  # @return [Hash] post-transform Hash
  def cast(hash); end

  # @param type [Symbol, Regexp, #cast, #===] identifier for cast type (some need block)
  # @return [#cast] specific cast operation
  def caster_for(type, &block); end

  # @param types [Array<Symbol, Regexp, #cast, #===>] identifier for cast type (some need block)
  def register(*types, &block); end
end

# Class for block based casts that are triggered for every key/value pair.
class Mustermann::Caster::Any
  # @return [Any] a new instance of Any
  def initialize(&block); end

  # @see Mustermann::Caster#cast
  def cast(key, value); end
end

# Class for block based casts that are triggered for key/value pairs with a matching key.
class Mustermann::Caster::Key < ::Mustermann::Caster::Any
  # @param type [#===] used for matching keys
  # @return [Key] a new instance of Key
  def initialize(type, &block); end

  # @see Mustermann::Caster#cast
  def cast(key, value); end
end

# Class for block based casts that are triggered for key/value pairs with a matching value.
class Mustermann::Caster::Value < ::Mustermann::Caster::Any
  # @param type [#===] used for matching values
  # @return [Value] a new instance of Value
  def initialize(type, &block); end

  # @see Mustermann::Caster#cast
  def cast(key, value); end
end

# Raised if anything goes wrong while compiling a {Pattern}.
class Mustermann::CompileError < ::Mustermann::Error; end

# Class for pattern objects composed of multiple patterns using binary logic.
#
# @see Mustermann::Pattern#&
# @see Mustermann::Pattern#|
# @see Mustermann::Pattern#^
class Mustermann::Composite < ::Mustermann::Pattern
  # @return [Composite] a new instance of Composite
  def initialize(patterns, operator: T.unsafe(nil), **options); end

  # @see Mustermann::Pattern#==
  def ==(pattern); end

  # @see Mustermann::Pattern#===
  def ===(string); end

  # @return [Boolean]
  # @see Mustermann::Pattern#eql?
  def eql?(pattern); end

  # Expanding is supported by almost all patterns (notable exceptions are {Mustermann::Shell},
  # {Mustermann::Regular} and {Mustermann::Simple}).
  #
  # Union {Mustermann::Composite} patterns (with the | operator) support expanding if all
  # patterns they are composed of also support it.
  #
  # @example Expanding a pattern
  #   pattern = Mustermann.new('/:name(.:ext)?')
  #   pattern.expand(name: 'hello')             # => "/hello"
  #   pattern.expand(name: 'hello', ext: 'png') # => "/hello.png"
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :expand
  #   pattern.expand(name: "foo")
  #   else
  #   warn "does not support expanding"
  #   end
  # @note This method is only implemented by certain subclasses.
  # @param behavior [Symbol] What to do with additional key/value pairs not present in the values hash.
  #   Possible options: :raise, :ignore, :append.
  # @param values [Hash{Symbol: #to_s, Array<#to_s>}] Values to use for expansion.
  # @raise [NotImplementedError] raised if expand is not supported.
  # @raise [Mustermann::ExpandError] raised if a value is missing or unknown
  # @return [String] expanded string
  # @see Mustermann::Expander
  def expand(behavior = T.unsafe(nil), values = T.unsafe(nil)); end

  # @see Mustermann::Pattern#hash
  def hash; end

  def inspect; end

  # @see Mustermann::Pattern#match
  def match(string); end

  # Returns the value of attribute operator.
  def operator; end

  # @see Mustermann::Pattern#params
  def params(string); end

  # Returns the value of attribute patterns.
  def patterns; end

  # @return [Boolean]
  def respond_to_special?(method); end

  def simple_inspect; end

  # @return [String] the string representation of the pattern
  def to_s; end

  # Generates a list of URI template strings representing the pattern.
  #
  # Note that this transformation is lossy and the strings matching these
  # templates might not match the pattern (and vice versa).
  #
  # This comes in quite handy since URI templates are not made for pattern matching.
  # That way you can easily use a more precise template syntax and have it automatically
  # generate hypermedia links for you.
  #
  # Template generation is supported by almost all patterns (notable exceptions are
  # {Mustermann::Shell}, {Mustermann::Regular} and {Mustermann::Simple}).
  # Union {Mustermann::Composite} patterns (with the | operator) support template generation
  # if all patterns they are composed of also support it.
  #
  # @example generating templates
  #   Mustermann.new("/:name").to_templates                   # => ["/{name}"]
  #   Mustermann.new("/:foo(@:bar)?/*baz").to_templates       # => ["/{foo}@{bar}/{+baz}", "/{foo}/{+baz}"]
  #   Mustermann.new("/{name}", type: :template).to_templates # => ["/{name}"]
  # @example generating templates from composite patterns
  #   pattern  = Mustermann.new('/:name')
  #   pattern |= Mustermann.new('/{name}', type: :template)
  #   pattern |= Mustermann.new('/example/*nested')
  #   pattern.to_templates # => ["/{name}", "/example/{+nested}"]
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :to_templates
  #   pattern.to_templates
  #   else
  #   warn "does not support template generation"
  #   end
  # @note This method is only implemented by certain subclasses.
  # @return [Array<String>] list of URI templates
  def to_templates; end

  private

  def patterns_from(pattern, **options); end
  def with_matching(string, method); end

  class << self
    # @return [Mustermann::Pattern] a new composite pattern
    def new(*patterns, **options); end

    # @return [Boolean]
    # @see Mustermann::Pattern.supported?
    def supported?(option, type: T.unsafe(nil), **options); end
  end
end

# Class for pattern objects that are a concatenation of other patterns.
#
# @see Mustermann::Pattern#+
class Mustermann::Concat < ::Mustermann::Composite
  # Should not be used directly.
  #
  # @return [Concat] a new instance of Concat
  def initialize(*_arg0, **_arg1); end

  # @see Mustermann::Pattern#===
  def ===(string); end

  # Expanding is supported by almost all patterns (notable exceptions are {Mustermann::Shell},
  # {Mustermann::Regular} and {Mustermann::Simple}).
  #
  # Union {Mustermann::Composite} patterns (with the | operator) support expanding if all
  # patterns they are composed of also support it.
  #
  # @example Expanding a pattern
  #   pattern = Mustermann.new('/:name(.:ext)?')
  #   pattern.expand(name: 'hello')             # => "/hello"
  #   pattern.expand(name: 'hello', ext: 'png') # => "/hello.png"
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :expand
  #   pattern.expand(name: "foo")
  #   else
  #   warn "does not support expanding"
  #   end
  # @note This method is only implemented by certain subclasses.
  # @param behavior [Symbol] What to do with additional key/value pairs not present in the values hash.
  #   Possible options: :raise, :ignore, :append.
  # @param values [Hash{Symbol: #to_s, Array<#to_s>}] Values to use for expansion.
  # @raise [NotImplementedError] raised if expand is not supported.
  # @raise [Mustermann::ExpandError] raised if a value is missing or unknown
  # @return [String] expanded string
  # @see Mustermann::Expander
  def expand(behavior = T.unsafe(nil), values = T.unsafe(nil)); end

  # @see Mustermann::Pattern#match
  def match(string); end

  # @return [Symbol] always :+
  # @see Mustermann::Composite#operator
  def operator; end

  # @see Mustermann::Pattern#params
  def params(string); end

  # @see Mustermann::Pattern#peek_match
  def peek_match(string); end

  # @see Mustermann::Pattern#peek_params
  def peek_params(string); end

  # @see Mustermann::Pattern#peek_size
  def peek_size(string); end

  # @return [Boolean]
  def respond_to_special?(method); end

  # Generates a list of URI template strings representing the pattern.
  #
  # Note that this transformation is lossy and the strings matching these
  # templates might not match the pattern (and vice versa).
  #
  # This comes in quite handy since URI templates are not made for pattern matching.
  # That way you can easily use a more precise template syntax and have it automatically
  # generate hypermedia links for you.
  #
  # Template generation is supported by almost all patterns (notable exceptions are
  # {Mustermann::Shell}, {Mustermann::Regular} and {Mustermann::Simple}).
  # Union {Mustermann::Composite} patterns (with the | operator) support template generation
  # if all patterns they are composed of also support it.
  #
  # @example generating templates
  #   Mustermann.new("/:name").to_templates                   # => ["/{name}"]
  #   Mustermann.new("/:foo(@:bar)?/*baz").to_templates       # => ["/{foo}@{bar}/{+baz}", "/{foo}/{+baz}"]
  #   Mustermann.new("/{name}", type: :template).to_templates # => ["/{name}"]
  # @example generating templates from composite patterns
  #   pattern  = Mustermann.new('/:name')
  #   pattern |= Mustermann.new('/{name}', type: :template)
  #   pattern |= Mustermann.new('/example/*nested')
  #   pattern.to_templates # => ["/{name}", "/example/{+nested}"]
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :to_templates
  #   pattern.to_templates
  #   else
  #   warn "does not support template generation"
  #   end
  # @note This method is only implemented by certain subclasses.
  # @return [Array<String>] list of URI templates
  def to_templates; end

  private

  # generates one big AST from all patterns
  # will not check if patterns support AST generation
  def combined_ast; end

  # used to generate results for various methods by scanning through an input string
  def pump(string, inject_with: T.unsafe(nil), initial: T.unsafe(nil), with_size: T.unsafe(nil)); end
end

# Mixin for patterns to support native concatenation.
module Mustermann::Concat::Native
  # @see Mustermann::Pattern#+
  def +(other); end

  def look_ahead(other); end

  private

  def native_concat(other); end

  # @return [Boolean]
  def native_concat?(other); end
end

# Type to use if no type is given.
#
# @api private
Mustermann::DEFAULT_TYPE = T.let(T.unsafe(nil), Symbol)

# A simple wrapper around ObjectSpace::WeakMap that allows matching keys by equality rather than identity.
# Used for caching. Note that `fetch` is not guaranteed to return the object, even if it has not been
# garbage collected yet, especially when used concurrently. Therefore, the block passed to `fetch` has to
# be idempotent.
#
# @example
#   class ExpensiveComputation
#   @map = Mustermann::EqualityMap.new
#
#   def self.new(*args)
#   @map.fetch(args) { super }
#   end
#   end
# @see #fetch
class Mustermann::EqualityMap
  # @return [EqualityMap] a new instance of EqualityMap
  def initialize; end

  # @param key [#hash] for caching
  # @return value stored in map or result of block
  # @yield block that will be called to populate entry if missing (has to be idempotent)
  def fetch(key); end

  # Returns the value of attribute map.
  def map; end

  private

  # Finalizer proc needs to be generated in different scope so it doesn't keep a reference to the object.
  #
  # @param hash [Integer] for key
  # @return [Proc] finalizer callback
  def finalizer(hash); end

  # @param key [#hash] for identifying the object
  # @param object [Object] to be stored
  # @return [Object] same as the second parameter
  def track(key, object); end

  class << self
    def new; end
  end
end

# Raised if anything goes wrong while generating a {Pattern}.
class Mustermann::Error < ::StandardError; end

# Raised if anything goes wrong while expanding a {Pattern}.
class Mustermann::ExpandError < ::Mustermann::Error; end

# Allows fine-grained control over pattern expansion.
#
# @example
#   expander = Mustermann::Expander.new(additional_values: :append)
#   expander << "/users/:user_id"
#   expander << "/pages/:page_id"
#
#   expander.expand(page_id: 58, format: :html5) # => "/pages/58?format=html5"
class Mustermann::Expander
  # @param patterns [Array<#to_str, Mustermann::Pattern>] list of patterns to expand, see {#add}.
  # @param additional_values [Symbol] behavior when encountering additional values, see {#expand}.
  # @param options [Hash] used when creating/expanding patterns, see {Mustermann.new}.
  # @return [Expander] a new instance of Expander
  def initialize(*patterns, additional_values: T.unsafe(nil), **options, &block); end

  # Add patterns to expand.
  #
  # @example
  #   expander = Mustermann::Expander.new
  #   expander.add("/:a.jpg", "/:b.png")
  #   expander.expand(a: "pony") # => "/pony.jpg"
  # @param patterns [Array<#to_str, Mustermann::Pattern>] list of to add for expansion, Strings will be compiled to patterns.
  # @return [Mustermann::Expander] the expander
  def <<(*patterns); end

  # @see Object#==
  def ==(other); end

  # Add patterns to expand.
  #
  # @example
  #   expander = Mustermann::Expander.new
  #   expander.add("/:a.jpg", "/:b.png")
  #   expander.expand(a: "pony") # => "/pony.jpg"
  # @param patterns [Array<#to_str, Mustermann::Pattern>] list of to add for expansion, Strings will be compiled to patterns.
  # @return [Mustermann::Expander] the expander
  def add(*patterns); end

  # Returns the value of attribute additional_values.
  def additional_values; end

  # Register a block as simple hash transformation that runs before expanding the pattern.
  #
  # @overload cast
  # @overload cast
  # @overload cast
  # @return [Mustermann::Expander] the expander
  def cast(*types, &block); end

  # @return [Boolean]
  # @see Object#eql?
  def eql?(other); end

  # @example Expanding a pattern
  #   pattern = Mustermann::Expander.new('/:name', '/:name.:ext')
  #   pattern.expand(name: 'hello')             # => "/hello"
  #   pattern.expand(name: 'hello', ext: 'png') # => "/hello.png"
  # @example Handling additional values
  #   pattern = Mustermann::Expander.new('/:name', '/:name.:ext')
  #   pattern.expand(:ignore, name: 'hello', ext: 'png', scale: '2x') # => "/hello.png"
  #   pattern.expand(:append, name: 'hello', ext: 'png', scale: '2x') # => "/hello.png?scale=2x"
  #   pattern.expand(:raise,  name: 'hello', ext: 'png', scale: '2x') # raises Mustermann::ExpandError
  # @example Setting additional values behavior for the expander object
  #   pattern = Mustermann::Expander.new('/:name', '/:name.:ext', additional_values: :append)
  #   pattern.expand(name: 'hello', ext: 'png', scale: '2x') # => "/hello.png?scale=2x"
  # @param behavior [Symbol] What to do with additional key/value pairs not present in the values hash.
  #   Possible options: :raise, :ignore, :append.
  # @param values [Hash{Symbol: #to_s, Array<#to_s>}] Values to use for expansion.
  # @raise [NotImplementedError] raised if expand is not supported.
  # @raise [Mustermann::ExpandError] raised if a value is missing or unknown
  # @return [String] expanded string
  def expand(behavior = T.unsafe(nil), values = T.unsafe(nil)); end

  # @return [Boolean]
  def expandable?(values); end

  # @see Object#hash
  def hash; end

  # Returns the value of attribute patterns.
  def patterns; end

  private

  def append(uri, values); end

  # Returns the value of attribute caster.
  def caster; end

  def map_values(values); end
  def slice(hash, keys); end
  def split_values(values); end

  # @yield [expand(:raise, slice(values, expandable)), slice(values, non_expandable)]
  def with_rest(values); end
end

# Matches strings that are identical to the pattern.
#
# @example
#   Mustermann.new('/:foo', type: :identity) === '/bar' # => false
# @see Mustermann::Pattern
# @see file:README.md#identity Syntax description in the README
class Mustermann::Identity < ::Mustermann::Pattern
  include ::Mustermann::Concat::Native

  # @param string [String] The string to match against
  # @return [Boolean] Whether or not the pattern matches the given string
  # @see http://ruby-doc.org/core-2.0/Regexp.html#method-i-3D-3D-3D Regexp#===
  def ===(string); end

  # Identity patterns support expanding.
  #
  # This implementation does not use {Mustermann::Expander} internally to save memory and
  # compilation time.
  #
  # @example Expanding a pattern
  #   pattern = Mustermann.new('/:name(.:ext)?')
  #   pattern.expand(name: 'hello')             # => "/hello"
  #   pattern.expand(name: 'hello', ext: 'png') # => "/hello.png"
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :expand
  #   pattern.expand(name: "foo")
  #   else
  #   warn "does not support expanding"
  #   end
  # @param behavior [Symbol] What to do with additional key/value pairs not present in the values hash.
  #   Possible options: :raise, :ignore, :append.
  # @param values [Hash{Symbol: #to_s, Array<#to_s>}] Values to use for expansion.
  # @raise [ExpandError]
  # @raise [NotImplementedError] raised if expand is not supported.
  # @raise [Mustermann::ExpandError] raised if a value is missing or unknown
  # @return [String] expanded string
  # @see Mustermann::Pattern#expand
  # @see Mustermann::Expander
  def expand(behavior = T.unsafe(nil), values = T.unsafe(nil)); end

  # @param string [String] The string to match against
  # @return [Integer, nil] the number of characters that match
  def peek_size(string); end

  # Generates an AST so it's compatible with {Mustermann::AST::Pattern}.
  # Not used internally by {Mustermann::Identity}.
  def to_ast; end

  # URI templates support generating templates (the logic is quite complex, though).
  #
  # @example generating templates
  #   Mustermann.new("/:name").to_templates                   # => ["/{name}"]
  #   Mustermann.new("/:foo(@:bar)?/*baz").to_templates       # => ["/{foo}@{bar}/{+baz}", "/{foo}/{+baz}"]
  #   Mustermann.new("/{name}", type: :template).to_templates # => ["/{name}"]
  # @example generating templates from composite patterns
  #   pattern  = Mustermann.new('/:name')
  #   pattern |= Mustermann.new('/{name}', type: :template)
  #   pattern |= Mustermann.new('/example/*nested')
  #   pattern.to_templates # => ["/{name}", "/example/{+nested}"]
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :to_templates
  #   pattern.to_templates
  #   else
  #   warn "does not support template generation"
  #   end
  # @return [Array<String>] list of URI templates
  # @see Mustermann::Pattern#to_templates
  def to_templates; end
end

# Raised if anything goes wrong while parsing a {Pattern}.
class Mustermann::ParseError < ::Mustermann::Error; end

# Superclass for all pattern implementations.
#
# @abstract
class Mustermann::Pattern
  include ::Mustermann

  # @overload initialize
  # @param string [String] the string representation of the pattern
  # @param options [Hash] options for fine-tuning the pattern behavior
  # @raise [Mustermann::Error] if the pattern can't be generated from the string
  # @return [Pattern] a new instance of Pattern
  # @see file:README.md#Types_and_Options "Types and Options" in the README
  # @see Mustermann.new
  def initialize(string, uri_decode: T.unsafe(nil), **options); end

  # @overload |
  # @overload &
  # @overload ^
  # @param other [Mustermann::Pattern, String] the other pattern
  # @return [Mustermann::Pattern] a composite pattern
  def &(other); end

  # Creates a concatenated pattern by combingin self with the other pattern supplied.
  # Patterns of different types can be mixed. The availability of `to_templates` and
  # `expand` depends on the patterns being concatenated.
  #
  # String input is treated as identity pattern.
  #
  # @example
  #   require 'mustermann'
  #   prefix = Mustermann.new("/:prefix")
  #   about  = prefix + "/about"
  #   about.params("/main/about") # => {"prefix" => "main"}
  # @param other [Mustermann::Pattern, String] pattern to be appended
  # @return [Mustermann::Pattern] concatenated pattern
  def +(other); end

  # Two patterns are considered equal if they are of the same type, have the same pattern string
  # and the same options.
  #
  # @return [true, false]
  def ==(other); end

  # @note Needs to be overridden by subclass.
  # @param string [String] The string to match against
  # @raise [NotImplementedError]
  # @return [Boolean] Whether or not the pattern matches the given string
  # @see http://ruby-doc.org/core-2.0/Regexp.html#method-i-3D-3D-3D Regexp#===
  def ===(string); end

  # @param string [String] The string to match against
  # @return [Integer, nil] nil if pattern does not match the string, zero if it does.
  # @see http://ruby-doc.org/core-2.0/Regexp.html#method-i-3D-7E Regexp#=~
  def =~(string); end

  # @overload |
  # @overload &
  # @overload ^
  # @param other [Mustermann::Pattern, String] the other pattern
  # @return [Mustermann::Pattern] a composite pattern
  def ^(other); end

  # @return [Boolean]
  def always_array?(key); end

  # Two patterns are considered equal if they are of the same type, have the same pattern string
  # and the same options.
  #
  # @return [true, false]
  def eql?(other); end

  # Expanding is supported by almost all patterns (notable exceptions are {Mustermann::Shell},
  # {Mustermann::Regular} and {Mustermann::Simple}).
  #
  # Union {Mustermann::Composite} patterns (with the | operator) support expanding if all
  # patterns they are composed of also support it.
  #
  # @example Expanding a pattern
  #   pattern = Mustermann.new('/:name(.:ext)?')
  #   pattern.expand(name: 'hello')             # => "/hello"
  #   pattern.expand(name: 'hello', ext: 'png') # => "/hello.png"
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :expand
  #   pattern.expand(name: "foo")
  #   else
  #   warn "does not support expanding"
  #   end
  # @note This method is only implemented by certain subclasses.
  # @param behavior [Symbol] What to do with additional key/value pairs not present in the values hash.
  #   Possible options: :raise, :ignore, :append.
  # @param values [Hash{Symbol: #to_s, Array<#to_s>}] Values to use for expansion.
  # @raise [NotImplementedError] raised if expand is not supported.
  # @raise [Mustermann::ExpandError] raised if a value is missing or unknown
  # @return [String] expanded string
  # @see Mustermann::Expander
  def expand(behavior = T.unsafe(nil), values = T.unsafe(nil)); end

  # Used by Ruby internally for hashing.
  #
  # @return [Integer] same has value for patterns that are equal
  def hash; end

  def inspect; end

  # @param string [String] The string to match against
  # @return [MatchData, Mustermann::SimpleMatch, nil] MatchData or similar object if the pattern matches.
  # @see http://ruby-doc.org/core-2.0/Regexp.html#method-i-match Regexp#match
  # @see http://ruby-doc.org/core-2.0/MatchData.html MatchData
  # @see Mustermann::SimpleMatch
  def match(string); end

  # @return [Hash{String: Array<Integer>}] capture names mapped to capture index.
  # @see http://ruby-doc.org/core-2.0/Regexp.html#method-i-named_captures Regexp#named_captures
  def named_captures; end

  # @return [Array<String>] capture names.
  # @see http://ruby-doc.org/core-2.0/Regexp.html#method-i-names Regexp#names
  def names; end

  # options hash passed to new (with unsupported options removed)
  def options; end

  # @param string [String] the string to match against
  # @return [Hash{String: String, Array<String>}, nil] Sinatra style params if pattern matches.
  def params(string = T.unsafe(nil), captures: T.unsafe(nil), offset: T.unsafe(nil)); end

  # Tries to match the pattern against the beginning of the string (as opposed to the full string).
  # Will return the substring if it matches.
  #
  # @example
  #   pattern = Mustermann.new('/:name')
  #   pattern.peek("/Frank/Sinatra") # => "/Frank"
  # @param string [String] The string to match against
  # @return [String, nil] matched subsctring
  def peek(string); end

  # Tries to match the pattern against the beginning of the string (as opposed to the full string).
  # Will return a MatchData or similar instance for the matched substring.
  #
  # @example
  #   pattern = Mustermann.new('/:name')
  #   pattern.peek("/Frank/Sinatra") # => #<MatchData "/Frank" name:"Frank">
  # @param string [String] The string to match against
  # @return [MatchData, Mustermann::SimpleMatch, nil] MatchData or similar object if the pattern matches.
  # @see #peek_params
  def peek_match(string); end

  # Tries to match the pattern against the beginning of the string (as opposed to the full string).
  # Will return a two element Array with the params parsed from the substring as first entry and the length of
  # the substring as second.
  #
  # @example
  #   pattern   = Mustermann.new('/:name')
  #   params, _ = pattern.peek_params("/Frank/Sinatra")
  #
  #   puts "Hello, #{params['name']}!" # Hello, Frank!
  # @param string [String] The string to match against
  # @return [Array<Hash, Integer>, nil] Array with params hash and length of substing if matched, nil otherwise
  def peek_params(string); end

  # Tries to match the pattern against the beginning of the string (as opposed to the full string).
  # Will return the count of the matching characters if it matches.
  #
  # @example
  #   pattern = Mustermann.new('/:name')
  #   pattern.size("/Frank/Sinatra") # => 6
  # @param string [String] The string to match against
  # @return [Integer, nil] the number of characters that match
  def peek_size(string); end

  # @return [Boolean]
  # @see Object#respond_to?
  def respond_to?(method, *args); end

  def simple_inspect; end

  # @example
  #   pattern = Mustermann.new('/:a/:b')
  #   strings = ["foo/bar", "/foo/bar", "/foo/bar/"]
  #   strings.detect(&pattern) # => "/foo/bar"
  # @return [Proc] proc wrapping {#===}
  def to_proc; end

  # @return [String] the string representation of the pattern
  def to_s; end

  # Generates a list of URI template strings representing the pattern.
  #
  # Note that this transformation is lossy and the strings matching these
  # templates might not match the pattern (and vice versa).
  #
  # This comes in quite handy since URI templates are not made for pattern matching.
  # That way you can easily use a more precise template syntax and have it automatically
  # generate hypermedia links for you.
  #
  # Template generation is supported by almost all patterns (notable exceptions are
  # {Mustermann::Shell}, {Mustermann::Regular} and {Mustermann::Simple}).
  # Union {Mustermann::Composite} patterns (with the | operator) support template generation
  # if all patterns they are composed of also support it.
  #
  # @example generating templates
  #   Mustermann.new("/:name").to_templates                   # => ["/{name}"]
  #   Mustermann.new("/:foo(@:bar)?/*baz").to_templates       # => ["/{foo}@{bar}/{+baz}", "/{foo}/{+baz}"]
  #   Mustermann.new("/{name}", type: :template).to_templates # => ["/{name}"]
  # @example generating templates from composite patterns
  #   pattern  = Mustermann.new('/:name')
  #   pattern |= Mustermann.new('/{name}', type: :template)
  #   pattern |= Mustermann.new('/example/*nested')
  #   pattern.to_templates # => ["/{name}", "/example/{+nested}"]
  # @example Checking if a pattern supports expanding
  #   if pattern.respond_to? :to_templates
  #   pattern.to_templates
  #   else
  #   warn "does not support template generation"
  #   end
  # @note This method is only implemented by certain subclasses.
  # @raise [NotImplementedError]
  # @return [Array<String>] list of URI templates
  def to_templates; end

  # Returns the value of attribute uri_decode.
  def uri_decode; end

  # @overload |
  # @overload &
  # @overload ^
  # @param other [Mustermann::Pattern, String] the other pattern
  # @return [Mustermann::Pattern] a composite pattern
  def |(other); end

  private

  def map_param(key, value); end

  # @return [Boolean]
  # @see #respond_to?
  def respond_to_special?(method); end

  def unescape(string, decode = T.unsafe(nil)); end

  class << self
    # @overload new
    # @param string [String] the string representation of the pattern
    # @param options [Hash] options for fine-tuning the pattern behavior
    # @raise [ArgumentError] if some option is not supported
    # @raise [Mustermann::Error] if the pattern can't be generated from the string
    # @return [Mustermann::Pattern] a new instance of Mustermann::Pattern
    # @see #initialize
    def new(string, ignore_unknown_options: T.unsafe(nil), **options); end

    # Registers the pattern with Mustermann.
    #
    # @see Mustermann.register
    def register(*names); end

    # @param option [Symbol] The option to check.
    # @return [Boolean] Whether or not option is supported.
    def supported?(option, **options); end

    # List of supported options.
    #
    # @overload supported_options
    # @overload supported_options
    def supported_options(*list); end
  end
end

Mustermann::Pattern::ALWAYS_ARRAY = T.let(T.unsafe(nil), Array)

# Superclass for patterns that internally compile to a regular expression.
#
# @abstract
# @see Mustermann::Pattern
class Mustermann::RegexpBased < ::Mustermann::Pattern
  extend ::Forwardable

  # @param string [String] the string representation of the pattern
  # @param options [Hash] options for fine-tuning the pattern behavior
  # @return [Pattern] a new instance of Pattern
  # @see file:README.md#Types_and_Options "Types and Options" in the README
  # @see Mustermann.new
  def initialize(string, **options); end

  def ===(*args, **_arg1, &block); end
  def =~(*args, **_arg1, &block); end
  def match(*args, **_arg1, &block); end
  def named_captures(*args, **_arg1, &block); end
  def names(*args, **_arg1, &block); end

  # @param string [String] The string to match against
  # @return [MatchData, Mustermann::SimpleMatch, nil] MatchData or similar object if the pattern matches.
  # @see #peek_params
  def peek_match(string); end

  # @param string [String] The string to match against
  # @return [Integer, nil] the number of characters that match
  def peek_size(string); end

  # @return [Regexp] regular expression equivalent to the pattern.
  def regexp; end

  # @return [Regexp] regular expression equivalent to the pattern.
  def to_regexp; end

  private

  # @raise [NotImplementedError]
  def compile(**options); end
end

# Regexp pattern implementation.
#
# @example
#   Mustermann.new('/.*', type: :regexp) === '/bar' # => true
# @see Mustermann::Pattern
# @see file:README.md#simple Syntax description in the README
class Mustermann::Regular < ::Mustermann::RegexpBased
  include ::Mustermann::Concat::Native

  # @param string [String] the string representation of the pattern
  # @param options [Hash] options for fine-tuning the pattern behavior
  # @return [Pattern] a new instance of Pattern
  # @see file:README.md#Types_and_Options "Types and Options" in the README
  # @see Mustermann.new
  def initialize(string, check_anchors: T.unsafe(nil), **options); end

  private

  # @raise [CompileError]
  def check_anchors(scanner); end

  def compile(**options); end

  # @return [Boolean]
  def extended_regexp?(string); end
end

# Fakes MatchData for patterns that do not support capturing.
#
# @see http://ruby-doc.org/core-2.0/MatchData.html MatchData
class Mustermann::SimpleMatch
  # @api private
  # @return [SimpleMatch] a new instance of SimpleMatch
  def initialize(string = T.unsafe(nil), names: T.unsafe(nil), captures: T.unsafe(nil)); end

  def +(other); end

  # @return [nil] imitates MatchData interface
  def [](*args); end

  # @return [Array<String>] empty array for imitating MatchData interface
  def captures; end

  # @return [String] string representation
  def inspect; end

  # @return [Array<String>] empty array for imitating MatchData interface
  def names; end

  # @return [String] the string that was matched against
  def to_s; end
end

# Sinatra 2.0 style pattern implementation.
#
# @example
#   Mustermann.new('/:foo') === '/bar' # => true
# @see Mustermann::Pattern
# @see file:README.md#sinatra Syntax description in the README
class Mustermann::Sinatra < ::Mustermann::AST::Pattern
  include ::Mustermann::Concat::Native

  # Generates a string represenation of the pattern that can safely be used for def interpolation
  # without changing its semantics.
  #
  # @example
  #   require 'mustermann'
  #   unsafe = Mustermann.new("/:name")
  #
  #   Mustermann.new("#{unsafe}bar").params("/foobar") # => { "namebar" => "foobar" }
  #   Mustermann.new("#{unsafe.safe_string}bar").params("/foobar") # => { "name" => "bar" }
  # @return [String] string representatin of the pattern
  def safe_string; end

  # Creates a pattern that matches any string matching either one of the patterns.
  # If a string is supplied, it is treated as a fully escaped Sinatra pattern.
  #
  # If the other pattern is also a Sintara pattern, it might join the two to a third
  # sinatra pattern instead of generating a composite for efficiency reasons.
  #
  # This only happens if the sinatra pattern behaves exactly the same as a composite
  # would in regards to matching, parsing, expanding and template generation.
  #
  # @example
  #   pattern = Mustermann.new('/foo/:name') | Mustermann.new('/:first/:second')
  #   pattern === '/foo/bar' # => true
  #   pattern === '/fox/bar' # => true
  #   pattern === '/foo'     # => false
  # @param other [Mustermann::Pattern, String] the other pattern
  # @return [Mustermann::Pattern] a composite pattern
  # @see Mustermann::Pattern#|
  def |(other); end

  private

  def native_concat(other); end

  class << self
    # Takes a string and espaces any characters that have special meaning for Sinatra patterns.
    #
    # @example
    #   require 'mustermann/sinatra'
    #   Mustermann::Sinatra.escape("/:name") # => "/\\:name"
    # @param string [#to_s] the input string
    # @return [String] the escaped string
    def escape(string); end

    # Tries to convert the given input object to a Sinatra pattern with the given options, without
    # changing its parsing semantics.
    #
    # @return [Mustermann::Sinatra, nil] the converted pattern, if possible
    def try_convert(input, **options); end
  end
end

# Sinatra syntax definition.
class Mustermann::Sinatra::Parser < ::Mustermann::AST::Parser; end

# Generates a string that can safely be concatenated with other strings
# without chaning its semantics
#
# @see #safe_string
Mustermann::Sinatra::SafeRenderer = T.let(T.unsafe(nil), T.untyped)

# Tries to translate objects to Sinatra patterns.
class Mustermann::Sinatra::TryConvert < ::Mustermann::AST::Translator
  # @return [TryConvert] a new instance of TryConvert
  def initialize(options); end

  # @return [Mustermann::Sinatra]
  def new(input, escape = T.unsafe(nil)); end

  # Expected options for the resulting pattern.
  def options; end

  # @return [true, false] whether or not expected pattern should have uri_decode option set
  def uri_decode; end

  class << self
    # @return [Mustermann::Sinatra, nil]
    def convert(input, **options); end
  end
end

class Mustermann::Sinatra::TryConvert::NodeTranslator < ::Mustermann::AST::Translator::NodeTranslator
  class << self
    def translator; end
  end
end
