# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-struct` gem.
# Please instead update this file by running `bin/tapioca gem dry-struct`.

# A collection of micro-libraries, each intended to encapsulate
# a common task in Ruby
module Dry
  class << self
    # Build an equalizer module for the inclusion in other class
    #
    # ## Credits
    #
    # Equalizer has been originally imported from the equalizer gem created by Dan Kubb
    #
    # @api public
    def Equalizer(*keys, **options); end

    # Constructor method for easily creating a {Dry::Struct}.
    #
    # @example
    #   require 'dry-struct'
    #
    #   module Types
    #   include Dry.Types()
    #   end
    #
    #   Person = Dry.Struct(name: Types::String, age: Types::Integer)
    #   matz = Person.new(name: "Matz", age: 52)
    #   matz.name #=> "Matz"
    #   matz.age #=> 52
    #
    #   Test = Dry.Struct(expected: Types::String) { schema(schema.strict) }
    #   Test[expected: "foo", unexpected: "bar"]
    #   #=> Dry::Struct::Error: [Test.new] unexpected keys [:unexpected] in Hash input
    # @return [Dry::Struct]
    def Struct(attributes = T.unsafe(nil), &block); end

    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# Typed {Struct} with virtus-like DSL for defining schema.
#
# ### Differences between dry-struct and virtus
#
# {Struct} look somewhat similar to [Virtus][] but there are few significant differences:
#
# * {Struct}s don't provide attribute writers and are meant to be used
#   as "data objects" exclusively.
# * Handling of attribute values is provided by standalone type objects from
#   [`dry-types`][].
# * Handling of attribute hashes is provided by standalone hash schemas from
#   [`dry-types`][].
# * Struct classes quack like [`dry-types`][], which means you can use them
#   in hash schemas, as array members or sum them
#
# {Struct} class can specify a constructor type, which uses [hash schemas][]
# to handle attributes in `.new` method.
#
# [`dry-types`]: https://github.com/dry-rb/dry-types
# [Virtus]: https://github.com/solnic/virtus
# [hash schemas]: http://dry-rb.org/gems/dry-types/hash-schemas
#
# @example
#   require 'dry-struct'
#
#   module Types
#   include Dry.Types()
#   end
#
#   class Book < Dry::Struct
#   attribute :title, Types::String
#   attribute :subtitle, Types::String.optional
#   end
#
#   rom_n_roda = Book.new(
#   title: 'Web Development with ROM and Roda',
#   subtitle: nil
#   )
#   rom_n_roda.title #=> 'Web Development with ROM and Roda'
#   rom_n_roda.subtitle #=> nil
#
#   refactoring = Book.new(
#   title: 'Refactoring',
#   subtitle: 'Improving the Design of Existing Code'
#   )
#   refactoring.title #=> 'Refactoring'
#   refactoring.subtitle #=> 'Improving the Design of Existing Code'
class Dry::Struct
  include ::Dry::Core::Constants
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Extensions
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::Dry::Types::Type
  extend ::Dry::Types::Builder
  extend ::Dry::Struct::ClassInterface
  extend ::Dry::Core::Deprecations::Interface

  # @param attributes [Hash, #each]
  # @return [Struct] a new instance of Struct
  def initialize(attributes); end

  # Retrieves value of previously defined attribute by its' `name`
  #
  # @example
  #   class Book < Dry::Struct
  #   attribute :title, Types::String
  #   attribute :subtitle, Types::String.optional
  #   end
  #
  #   rom_n_roda = Book.new(
  #   title: 'Web Development with ROM and Roda',
  #   subtitle: nil
  #   )
  #   rom_n_roda[:title] #=> 'Web Development with ROM and Roda'
  #   rom_n_roda[:subtitle] #=> nil
  # @param name [String]
  # @return [Object]
  def [](name); end

  # Returns the value of attribute attributes.
  def __attributes__; end

  # Create a copy of {Dry::Struct} with overriden attributes
  #
  # @example
  #   class Book < Dry::Struct
  #   attribute :title, Types::String
  #   attribute :subtitle, Types::String.optional
  #   end
  #
  #   rom_n_roda = Book.new(
  #   title: 'Web Development with ROM and Roda',
  #   subtitle: '2nd edition'
  #   )
  #   #=> #<Book title="Web Development with ROM and Roda" subtitle="2nd edition">
  #
  #   rom_n_roda.new(subtitle: '3rd edition')
  #   #=> #<Book title="Web Development with ROM and Roda" subtitle="3rd edition">
  # @param changeset [Hash{Symbol => Object}]
  # @return [Struct]
  def __new__(changeset); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Pattern matching support
  #
  # @api private
  def deconstruct_keys(_keys); end

  # @return [String]
  def inspect; end

  # Create a copy of {Dry::Struct} with overriden attributes
  #
  # @example
  #   class Book < Dry::Struct
  #   attribute :title, Types::String
  #   attribute :subtitle, Types::String.optional
  #   end
  #
  #   rom_n_roda = Book.new(
  #   title: 'Web Development with ROM and Roda',
  #   subtitle: '2nd edition'
  #   )
  #   #=> #<Book title="Web Development with ROM and Roda" subtitle="2nd edition">
  #
  #   rom_n_roda.new(subtitle: '3rd edition')
  #   #=> #<Book title="Web Development with ROM and Roda" subtitle="3rd edition">
  # @param changeset [Hash{Symbol => Object}]
  # @return [Struct]
  def new(changeset); end

  # Converts the {Dry::Struct} to a hash with keys representing
  # each attribute (as symbols) and their corresponding values
  #
  # @example
  #   class Book < Dry::Struct
  #   attribute :title, Types::String
  #   attribute :subtitle, Types::String.optional
  #   end
  #
  #   rom_n_roda = Book.new(
  #   title: 'Web Development with ROM and Roda',
  #   subtitle: nil
  #   )
  #   rom_n_roda.to_hash
  #   #=> {title: 'Web Development with ROM and Roda', subtitle: nil}
  # @return [Hash{Symbol => Object}]
  def to_h; end

  # Converts the {Dry::Struct} to a hash with keys representing
  # each attribute (as symbols) and their corresponding values
  #
  # @example
  #   class Book < Dry::Struct
  #   attribute :title, Types::String
  #   attribute :subtitle, Types::String.optional
  #   end
  #
  #   rom_n_roda = Book.new(
  #   title: 'Web Development with ROM and Roda',
  #   subtitle: nil
  #   )
  #   rom_n_roda.to_hash
  #   #=> {title: 'Web Development with ROM and Roda', subtitle: nil}
  # @return [Hash{Symbol => Object}]
  def to_hash; end

  class << self
    def prepend(*_arg0); end
  end
end

# Class-level interface of {Struct} and {Value}
module Dry::Struct::ClassInterface
  include ::Dry::Core::Constants
  include ::Dry::Core::ClassAttributes
  include ::Dry::Types::Type
  include ::Dry::Types::Builder

  # @param other [Object, Dry::Struct]
  # @return [Boolean]
  def ===(other); end

  # Make the struct abstract. This class will be used as a default
  # parent class for nested structs
  def abstract; end

  # Adds an attribute for this {Struct} with given `name` and `type`
  # and modifies {.schema} accordingly.
  #
  # @example with nested structs
  #   class Language < Dry::Struct
  #   attribute :name, Types::String
  #   attribute :details, Dry::Struct do
  #   attribute :type, Types::String
  #   end
  #   end
  #
  #   Language.schema
  #   # => #<Dry::Types[Constructor<Schema<keys={name: Constrained<Nominal<String> rule=[type?(String)]> details: Language::Details}> fn=Kernel.Hash>]>
  #
  #   ruby = Language.new(name: 'Ruby', details: { type: 'OO' })
  #   ruby.name #=> 'Ruby'
  #   ruby.details #=> #<Language::Details type="OO">
  #   ruby.details.type #=> 'OO'
  # @example with a nested array of structs
  #   class Language < Dry::Struct
  #   attribute :name, Types::String
  #   attribute :versions, Types::Array.of(Types::String)
  #   attribute :celebrities, Types::Array.of(Dry::Struct) do
  #   attribute :name, Types::String
  #   attribute :pseudonym, Types::String
  #   end
  #   end
  #
  #   Language.schema
  #   => #<Dry::Types[Constructor<Schema<keys={
  #   name: Constrained<Nominal<String> rule=[type?(String)]>
  #   versions: Constrained<Array<Constrained<Nominal<String> rule=[type?(String)]>> rule=[type?(Array)]>
  #   celebrities: Constrained<Array<Language::Celebrity> rule=[type?(Array)]>
  #   }> fn=Kernel.Hash>]>
  #
  #   ruby = Language.new(
  #   name: 'Ruby',
  #   versions: %w(1.8.7 1.9.8 2.0.1),
  #   celebrities: [
  #   { name: 'Yukihiro Matsumoto', pseudonym: 'Matz' },
  #   { name: 'Aaron Patterson', pseudonym: 'tenderlove' }
  #   ]
  #   )
  #   ruby.name #=> 'Ruby'
  #   ruby.versions #=> ['1.8.7', '1.9.8', '2.0.1']
  #   ruby.celebrities
  #   #=> [
  #   #<Language::Celebrity name='Yukihiro Matsumoto' pseudonym='Matz'>,
  #   #<Language::Celebrity name='Aaron Patterson' pseudonym='tenderlove'>
  #   ]
  #   ruby.celebrities[0].name #=> 'Yukihiro Matsumoto'
  #   ruby.celebrities[0].pseudonym #=> 'Matz'
  #   ruby.celebrities[1].name #=> 'Aaron Patterson'
  #   ruby.celebrities[1].pseudonym #=> 'tenderlove'
  # @param name [Symbol] name of the defined attribute
  # @param type [Dry::Types::Type, nil] or superclass of nested type
  # @raise [RepeatedAttributeError] when trying to define attribute with the
  #   same name as previously defined one
  # @return [Dry::Struct]
  # @yield If a block is given, it will be evaluated in the context of
  #   a new struct class, and set as a nested type for the given
  #   attribute. A class with a matching name will also be defined for
  #   the nested type.
  def attribute(name, type = T.unsafe(nil), &block); end

  # Adds an omittable (key is not required on initialization) attribute for this {Struct}
  #
  # @example
  #   class User < Dry::Struct
  #   attribute  :name,  Types::String
  #   attribute? :email, Types::String
  #   end
  #
  #   User.new(name: 'John') # => #<User name="John" email=nil>
  # @param name [Symbol] name of the defined attribute
  # @param type [Dry::Types::Type, nil] or superclass of nested type
  # @return [Dry::Struct]
  def attribute?(*args, &block); end

  # Gets the list of attribute names
  #
  # @return [Array<Symbol>]
  def attribute_names; end

  # @example
  #   class Book < Dry::Struct
  #   attributes(
  #   title: Types::String,
  #   author: Types::String
  #   )
  #   end
  #
  #   Book.schema
  #   # => #<Dry::Types[Constructor<Schema<keys={
  #   #      title: Constrained<Nominal<String> rule=[type?(String)]>
  #   #      author: Constrained<Nominal<String> rule=[type?(String)]>
  #   #    }> fn=Kernel.Hash>]>
  # @param new_schema [Hash{Symbol => Dry::Types::Type}]
  # @raise [RepeatedAttributeError] when trying to define attribute with the
  #   same name as previously defined one
  # @return [Dry::Struct]
  # @see #attribute
  def attributes(new_schema); end

  # Add atributes from another struct
  #
  # @example
  #   class Address < Dry::Struct
  #   attribute :city, Types::String
  #   attribute :country, Types::String
  #   end
  #
  #   class User < Dry::Struct
  #   attribute :name, Types::String
  #   attributes_from Address
  #   end
  #
  #   User.new(name: 'Quispe', city: 'La Paz', country: 'Bolivia')
  # @example with nested structs
  #   class User < Dry::Struct
  #   attribute :name, Types::String
  #   attribute :address do
  #   attributes_from Address
  #   end
  #   end
  # @param struct [Dry::Struct]
  def attributes_from(struct); end

  # @api private
  def call_safe(input, &block); end

  # @api private
  def call_unsafe(input); end

  # @return [true]
  def constrained?; end

  # @param constructor [#call, nil]
  # @param block [#call, nil]
  # @return [Dry::Struct::Constructor]
  def constructor(constructor = T.unsafe(nil), **_arg1, &block); end

  # @return [false]
  def default?; end

  # @param args [({Symbol => Object})]
  # @return [Dry::Types::Result::Failure]
  def failure(*args); end

  # Checks if this {Struct} has the given attribute
  #
  # @param key [Symbol] Attribute name
  # @return [Boolean]
  def has_attribute?(key); end

  # @param klass [Class]
  def inherited(klass); end

  # @api private
  def load(attributes); end

  # @return [{Symbol => Object}]
  def meta(meta = T.unsafe(nil)); end

  # @param attributes [Hash{Symbol => Object}, Dry::Struct]
  # @raise [Struct::Error] if the given attributes don't conform {#schema}
  def new(attributes = T.unsafe(nil), safe = T.unsafe(nil), &block); end

  # @return [false]
  def optional?; end

  # @return [self]
  def primitive; end

  # @param other [Object, Dry::Struct]
  # @return [Boolean]
  def primitive?(other); end

  # @param klass [Class]
  # @param args [({Symbol => Object})]
  def result(klass, *args); end

  # @param args [({Symbol => Object})]
  # @return [Dry::Types::Result::Success]
  def success(*args); end

  # Dump to the AST
  #
  # @api public
  # @return [Array]
  def to_ast(meta: T.unsafe(nil)); end

  # @return [Proc]
  def to_proc; end

  # Add an arbitrary transformation for input hash keys.
  #
  # @example
  #   class Book < Dry::Struct
  #   transform_keys(&:to_sym)
  #
  #   attribute :title, Types::String
  #   end
  #
  #   Book.new('title' => "The Old Man and the Sea")
  #   # => #<Book title="The Old Man and the Sea">
  # @param proc [#call, nil]
  # @param block [#call, nil]
  def transform_keys(proc = T.unsafe(nil), &block); end

  # Add an arbitrary transformation for new attribute types.
  #
  # @example
  #   class Book < Dry::Struct
  #   transform_types { |t| t.meta(struct: :Book) }
  #
  #   attribute :title, Types::String
  #   end
  #
  #   Book.schema.key(:title).meta # => { struct: :Book }
  # @param proc [#call, nil]
  # @param block [#call, nil]
  def transform_types(proc = T.unsafe(nil), &block); end

  # @param input [Hash{Symbol => Object}, Dry::Struct]
  # @return [Dry::Types::Result]
  # @yieldparam failure [Dry::Types::Result::Failure]
  # @yieldreturn [Dry::Types::ResultResult]
  def try(input); end

  # @param input [Hash{Symbol => Object}, Dry::Struct]
  # @private
  # @return [Dry::Types::Result]
  def try_struct(input); end

  # Build a sum type
  #
  # @param type [Dry::Types::Type]
  # @return [Dry::Types::Sum]
  def |(type); end

  private

  # Constructs a type
  #
  # @return [Dry::Types::Type, Dry::Struct]
  def build_type(name, type = T.unsafe(nil), &block); end

  # @param new_keys [Hash{Symbol => Dry::Types::Type, Dry::Struct}]
  # @raise [RepeatedAttributeError] when trying to define attribute with the
  #   same name as previously defined one
  def check_schema_duplication(new_keys); end

  # Retrieves default attributes from defined {.schema}.
  # Used in a {Struct} constructor if no attributes provided to {.new}
  #
  # @return [Hash{Symbol => Object}]
  def default_attributes(default_schema = T.unsafe(nil)); end

  def define_accessors(keys); end

  # Checks if the given type is a Dry::Struct
  #
  # @param type [Dry::Types::Type]
  # @return [Boolean]
  def struct?(type); end

  # Stores an object for building nested struct classes
  #
  # @return [StructBuilder]
  def struct_builder; end
end

class Dry::Struct::Compiler < ::Dry::Types::Compiler
  def visit_struct(node); end
end

class Dry::Struct::Constructor < ::Dry::Types::Constructor
  def primitive; end
end

Dry::Struct::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Struct::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Struct::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Struct::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Struct::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Raised when given input doesn't conform schema and constructor type
class Dry::Struct::Error < ::TypeError; end

# Helper for {Struct#to_hash} implementation
module Dry::Struct::Hashify
  class << self
    # Converts value to hash recursively
    #
    # @param value [#to_hash, #map, Object]
    # @return [Hash, Array]
    def [](value); end
  end
end

Dry::Struct::IDENTITY = T.let(T.unsafe(nil), Proc)

# Raised when a struct doesn't have an attribute
class Dry::Struct::MissingAttributeError < ::KeyError
  # @return [MissingAttributeError] a new instance of MissingAttributeError
  def initialize(key); end
end

# When struct class stored in ast was garbage collected because no alive objects exists
# This shouldn't happen in a working application
class Dry::Struct::RecycledStructError < ::RuntimeError
  # @return [RecycledStructError] a new instance of RecycledStructError
  def initialize; end
end

# Raised when defining duplicate attributes
class Dry::Struct::RepeatedAttributeError < ::ArgumentError
  # @param key [Symbol] attribute name that is the same as previously defined one
  # @return [RepeatedAttributeError] a new instance of RepeatedAttributeError
  def initialize(key); end
end

Dry::Struct::Self = T.let(T.unsafe(nil), Proc)

# @private
class Dry::Struct::StructBuilder < ::Dry::Struct::Compiler
  # @return [StructBuilder] a new instance of StructBuilder
  def initialize(struct); end

  # @param attr_name [Symbol|String] the name of the nested type
  # @param type [Dry::Struct, Dry::Types::Type::Array, Undefined] the superclass of the nested struct
  # @yield the body of the nested struct
  def call(attr_name, type, &block); end

  # Returns the value of attribute struct.
  def struct; end

  private

  # @return [Boolean]
  def array?(type); end

  def check_name(name); end
  def const_name(type, attr_name); end

  # @return [Boolean]
  def optional?(type); end

  def parent(type); end

  # @return [Boolean]
  def type?(type); end

  def visit_array(node); end
  def visit_constrained(node); end
  def visit_constructor(node); end
  def visit_nominal(*_arg0); end
end

# A sum type of two or more structs
# As opposed to Dry::Types::Sum::Constrained
# this type tries no to coerce data first.
class Dry::Struct::Sum < ::Dry::Types::Sum::Constrained
  # @return [boolean]
  def ===(value); end

  def call(input); end

  # @param input [Hash{Symbol => Object}, Dry::Struct]
  # @return [Dry::Types::Result]
  # @yieldparam failure [Dry::Types::Result::Failure]
  # @yieldreturn [Dry::Types::ResultResult]
  def try(input); end

  # Build a new sum type
  #
  # @param type [Dry::Types::Type]
  # @return [Dry::Types::Sum]
  def |(type); end

  protected

  # @private
  def try_struct(input); end
end

Dry::Struct::Undefined = T.let(T.unsafe(nil), Object)

# @private
Dry::Struct::VERSION = T.let(T.unsafe(nil), String)

# {Value} objects behave like {Struct}s but *deeply frozen*
# using [`ice_nine`](https://github.com/dkubb/ice_nine)
#
# @example
#   class Location < Dry::Struct::Value
#   attribute :lat, Types::Float
#   attribute :lng, Types::Float
#   end
#
#   loc1 = Location.new(lat: 1.23, lng: 4.56)
#   loc2 = Location.new(lat: 1.23, lng: 4.56)
#
#   loc1.frozen? #=> true
#   loc2.frozen? #=> true
#   loc1 == loc2 #=> true
# @see https://github.com/dkubb/ice_nine
class Dry::Struct::Value < ::Dry::Struct
  class << self
    # @param attributes [Hash{Symbol => Object}, Dry::Struct]
    # @return [Value]
    # @see https://github.com/dkubb/ice_nine
    def new(*_arg0); end
  end
end

module Dry::Types
  extend ::Dry::Core::Constants

  class << self
    def Rule(options); end
    def [](name); end
    def const_missing(const); end
    def container; end
    def define_builder(method, &block); end
    def identifier(klass); end
    def included(*_arg0); end
    def module(*args, &block); end
    def register(name, type = T.unsafe(nil), &block); end
    def registered?(class_or_identifier); end
    def rule_compiler; end
    def type_map; end
  end
end

Dry::Types::ALL_PRIMITIVES = T.let(T.unsafe(nil), Hash)
Dry::Types::Any = T.let(T.unsafe(nil), Dry::Types::AnyClass)
Dry::Types::COERCIBLE = T.let(T.unsafe(nil), Hash)
Dry::Types::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Types::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Types::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Types::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Types::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Types::IDENTITY = T.let(T.unsafe(nil), Proc)
Dry::Types::Inflector = T.let(T.unsafe(nil), Dry::Inflector)
Dry::Types::KERNEL_COERCIBLE = T.let(T.unsafe(nil), Hash)
Dry::Types::METHOD_COERCIBLE = T.let(T.unsafe(nil), Hash)
Dry::Types::METHOD_COERCIBLE_METHODS = T.let(T.unsafe(nil), Hash)
class Dry::Types::MapError < ::Dry::Types::CoercionError; end
Dry::Types::NON_COERCIBLE = T.let(T.unsafe(nil), Hash)
Dry::Types::NON_NIL = T.let(T.unsafe(nil), Hash)
Dry::Types::PRINTER = T.let(T.unsafe(nil), Dry::Types::Printer)

# @api private
class Dry::Types::Printer
  def call(type); end
  def visit(type, &block); end
  def visit_any(_); end
  def visit_array(type); end
  def visit_array_member(array); end
  def visit_callable(callable); end
  def visit_constrained(constrained); end
  def visit_constructor(constructor); end
  def visit_default(default); end
  def visit_enum(enum); end
  def visit_hash(hash); end
  def visit_key(key); end
  def visit_lax(lax); end
  def visit_map(map); end
  def visit_nominal(type); end
  def visit_options(options, meta = T.unsafe(nil)); end
  def visit_schema(schema); end

  # @api private
  def visit_struct_constructor(constructor); end

  # @api private
  def visit_struct_sum(sum); end

  def visit_sum(sum); end
  def visit_sum_constructors(sum); end
end

Dry::Types::Printer::MAPPING = T.let(T.unsafe(nil), Hash)
Dry::Types::Self = T.let(T.unsafe(nil), Proc)
Dry::Types::TYPE_SPEC_REGEX = T.let(T.unsafe(nil), Regexp)
Dry::Types::Undefined = T.let(T.unsafe(nil), Object)
Dry::Types::VERSION = T.let(T.unsafe(nil), String)
