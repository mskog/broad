# typed: strict

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `down` gem.
# Please instead update this file by running `bin/tapioca gem down`.

module Down
  private

  # Allows setting a backend via a symbol or a downloader object.
  def backend(value = T.unsafe(nil)); end

  def download(*args, **options, &block); end
  def open(*args, **options, &block); end

  class << self
    # Allows setting a backend via a symbol or a downloader object.
    def backend(value = T.unsafe(nil)); end

    def download(*args, **options, &block); end
    def open(*args, **options, &block); end
  end
end

class Down::Backend
  private

  # If destination path is defined, move tempfile to the destination,
  # otherwise return the tempfile unchanged.
  def download_result(tempfile, destination); end

  def normalize_headers(response_headers); end

  class << self
    def download(*args, **options, &block); end
    def open(*args, **options, &block); end
  end
end

# Wraps an enumerator that yields chunks of content into an IO object. It
# implements some essential IO methods:
#
# * IO#read
# * IO#readpartial
# * IO#gets
# * IO#size
# * IO#pos
# * IO#eof?
# * IO#rewind
# * IO#close
#
# By default the Down::ChunkedIO caches all read content into a tempfile,
# allowing it to be rewindable. If rewindability won't be used, it can be
# disabled by setting `:rewindable` to false, which eliminates any disk I/O.
#
# Any cleanup code (i.e. ensure block) that the given enumerator carries is
# guaranteed to get executed, either when all content has been retrieved or
# when Down::ChunkedIO is closed. One can also specify an `:on_close`
# callback that will also get executed in those situations.
class Down::ChunkedIO
  # @return [ChunkedIO] a new instance of ChunkedIO
  def initialize(chunks:, size: T.unsafe(nil), on_close: T.unsafe(nil), data: T.unsafe(nil), rewindable: T.unsafe(nil), encoding: T.unsafe(nil)); end

  # Implements IO#close semantics. Closes the Down::ChunkedIO by terminating
  # chunk retrieval and deleting the cached content.
  def close; end

  # Returns whether the Down::ChunkedIO has been closed.
  #
  # @return [Boolean]
  def closed?; end

  # Returns the value of attribute data.
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  def data=(_arg0); end

  # Yields elements of the underlying enumerator.
  def each_chunk; end

  # Returns the value of attribute encoding.
  def encoding; end

  # Sets the attribute encoding
  #
  # @param value the value to set the attribute encoding to.
  def encoding=(_arg0); end

  # Implements IO#eof? semantics. Returns whether we've reached end of file.
  # It returns true if cache is at the end and there is no more content to
  # retrieve. Raises IOError if closed.
  #
  # @return [Boolean]
  def eof?; end

  # Implements IO#gets semantics. Without arguments it retrieves lines of
  # content separated by newlines.
  #
  # With `separator` argument it does the following:
  #
  # * if `separator` is a nonempty string returns chunks of content
  #   surrounded with that sequence of bytes
  # * if `separator` is an empty string returns paragraphs of content
  #   (content delimited by two newlines)
  # * if `separator` is nil and `limit` is nil returns all content
  #
  # With `limit` argument returns maximum of that amount of bytes.
  #
  # Returns nil if end of file is reached. Raises IOError if closed.
  def gets(separator_or_limit = T.unsafe(nil), limit = T.unsafe(nil)); end

  # Returns useful information about the Down::ChunkedIO object.
  def inspect; end

  # Implements IO#pos semantics. Returns the current position of the
  # Down::ChunkedIO.
  def pos; end

  # Implements IO#read semantics. Without arguments it retrieves and returns
  # all content.
  #
  # With `length` argument returns exactly that number of bytes if they're
  # available.
  #
  # With `outbuf` argument each call will return that same string object,
  # where the value is replaced with retrieved content.
  #
  # If end of file is reached, returns empty string if called without
  # arguments, or nil if called with arguments. Raises IOError if closed.
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # Implements IO#readpartial semantics. If there is any content readily
  # available reads from it, otherwise fetches and reads from the next chunk.
  # It writes to and reads from the cache when needed.
  #
  # Without arguments it either returns all content that's readily available,
  # or the next chunk. This is useful when you don't care about the size of
  # chunks and you want to minimize string allocations.
  #
  # With `maxlen` argument returns maximum of that amount of bytes (default
  # is 16KB).
  #
  # With `outbuf` argument each call will return that same string object,
  # where the value is replaced with retrieved content.
  #
  # Raises EOFError if end of file is reached. Raises IOError if closed.
  def readpartial(maxlen = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # Implements IO#rewind semantics. Rewinds the Down::ChunkedIO by rewinding
  # the cache and setting the position to the beginning of the file. Raises
  # IOError if closed or not rewindable.
  def rewind; end

  # Returns whether the Down::ChunkedIO was specified as rewindable.
  #
  # @return [Boolean]
  def rewindable?; end

  # Implements IO#seek semantics.
  def seek(amount, whence = T.unsafe(nil)); end

  # Returns the value of attribute size.
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  def size=(_arg0); end

  # Implements IO#pos semantics. Returns the current position of the
  # Down::ChunkedIO.
  def tell; end

  private

  # If Down::ChunkedIO is specified as rewindable, returns a new Tempfile for
  # writing read content to. This allows the Down::ChunkedIO to be rewinded.
  def cache; end

  # Returns whether there is any content left to retrieve.
  #
  # @return [Boolean]
  def chunks_depleted?; end

  # Creates a Fiber wrapper around the underlying enumerator. The advantage
  # of using a Fiber here is that we can terminate the chunk retrieval, in a
  # way that executes any cleanup code that the enumerator potentially
  # carries. At the end of iteration the :on_close callback is executed.
  def chunks_fiber; end

  # Finds encoding by name. If the encoding couldn't be find, falls back to
  # the generic binary encoding.
  def find_encoding(encoding); end

  # Returns whether the filesystem has POSIX semantics.
  #
  # @return [Boolean]
  def posix?; end

  # Returns current chunk and retrieves the next chunk. If next chunk is nil,
  # we know we've reached EOF.
  def retrieve_chunk; end
end

# raised when response returned 4xx response
class Down::ClientError < ::Down::ResponseError; end

# raised when there was an error connecting to the server
class Down::ConnectionError < ::Down::Error; end

# generic error which is a superclass to all other errors
class Down::Error < ::StandardError; end

# raised when the given URL couldn't be parsed
class Down::InvalidUrl < ::Down::Error; end

# Provides streaming downloads implemented with Net::HTTP and open-uri.
class Down::NetHttp < ::Down::Backend
  # Initializes the backend with common defaults.
  #
  # @return [NetHttp] a new instance of NetHttp
  def initialize(*args, **options); end

  # Downloads a remote file to disk using open-uri. Accepts any open-uri
  # options, and a few more.
  def download(url, *args, **options); end

  # Starts retrieving the remote file using Net::HTTP and returns an IO-like
  # object which downloads the response body on-demand.
  def open(url, *args, **options); end

  private

  # Build a Net::HTTP object for making a request.
  def create_net_http(uri, options); end

  # Converts the given IO into a Tempfile if it isn't one already (open-uri
  # returns a StringIO when there is less than 10KB of content), and gives
  # it the specified file extension.
  def ensure_tempfile(io, extension); end

  # Checks that the url is a valid URI and that its scheme is http or https.
  def ensure_uri(url, allow_relative: T.unsafe(nil)); end

  # Merge default and ad-hoc options, merging nested headers.
  def merge_options(options, headers = T.unsafe(nil), **new_options); end

  # Makes a Net::HTTP request and follows redirects.
  def net_http_request(uri, options, follows_remaining:, &block); end

  # Makes sure that the URL is properly encoded.
  def normalize_uri(url, uri_normalizer:); end

  # Calls open-uri's URI::HTTP#open method. Additionally handles redirects.
  def open_uri(uri, options, follows_remaining:); end

  # When open-uri raises an exception, it doesn't expose the response object.
  # Fortunately, the exception object holds response data that can be used to
  # rebuild the Net::HTTP response object.
  def rebuild_response_from_open_uri_exception(exception); end

  # Re-raise Net::HTTP exceptions as Down::Error exceptions.
  def request_error!(exception); end

  # Raises non-sucessful response as a Down::ResponseError.
  def response_error!(response); end

  # Yields chunks of the response body to the block.
  def stream_body(response, &block); end
end

# Defines some additional attributes for the returned Tempfile (on top of what
# OpenURI::Meta already defines).
module Down::NetHttp::DownloadedFile
  def content_type; end
  def original_filename; end
end

Down::NetHttp::URI_NORMALIZER = T.let(T.unsafe(nil), Proc)

# raised when response returned 404 response
class Down::NotFound < ::Down::ClientError; end

# raised when the requested resource has not been modified
class Down::NotModified < ::Down::Error; end

# raised when response returned 4xx or 5xx response
class Down::ResponseError < ::Down::Error
  # @return [ResponseError] a new instance of ResponseError
  def initialize(message, response = T.unsafe(nil)); end

  # Returns the value of attribute response.
  def response; end
end

# raised when an SSL error was raised
class Down::SSLError < ::Down::Error; end

# raised when response returned 5xx response
class Down::ServerError < ::Down::ResponseError; end

# raised when connecting to the server too longer than the specified timeout
class Down::TimeoutError < ::Down::ConnectionError; end

# raised when the file is larger than the specified maximum size
class Down::TooLarge < ::Down::Error; end

# raised when the number of redirects was larger than the specified maximum
class Down::TooManyRedirects < ::Down::Error; end

module Down::Utils
  private

  # Retrieves potential filename from the "Content-Disposition" header.
  def filename_from_content_disposition(content_disposition); end

  # Retrieves potential filename from the URL path.
  def filename_from_path(path); end

  class << self
    # Retrieves potential filename from the "Content-Disposition" header.
    def filename_from_content_disposition(content_disposition); end

    # Retrieves potential filename from the URL path.
    def filename_from_path(path); end
  end
end

Down::VERSION = T.let(T.unsafe(nil), String)
