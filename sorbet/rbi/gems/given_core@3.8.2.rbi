# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `given_core` gem.
# Please instead update this file by running `bin/tapioca gem given_core`.

# The before blocks defined in Minitest are inadequate for our use.
# This before_extension file allows us to use real before blocks.
module Given
  class << self
    # Increment the number of assertions made in the framework.
    def count_assertion(*args); end

    # Were there any explicit framework assertions made during the
    # execution of the Then block?
    #
    # @return [Boolean]
    def explicit_assertions?(*args); end

    # Fail an example with the given messages.
    def fail_with(*args); end

    def framework; end
    def framework=(framework); end

    # Return file and line number where the block is defined.
    def location_of(block); end

    # TRUE if natural assertions are globally enabled?
    #
    # @return [Boolean]
    def natural_assertions_enabled?; end

    # Error object used by the current framework to indicate a pending
    # example.
    def pending_error; end

    def source_caching_disabled; end
    def source_caching_disabled=(value); end

    # Mark the start of a Then assertion evaluation.
    def start_evaluation(*args); end

    # Globally enable/disable natural assertions.
    #
    # There is a similar function in Extensions that works at a
    # describe or context scope.
    def use_natural_assertions(enabled = T.unsafe(nil)); end

    # @return [Boolean]
    def using_old_rspec?; end
  end
end

class Given::BinaryOperation
  # @return [BinaryOperation] a new instance of BinaryOperation
  def initialize(left, operator, right); end

  def explain; end

  # Returns the value of attribute left.
  def left; end

  # Returns the value of attribute operator.
  def operator; end

  # Returns the value of attribute right.
  def right; end

  class << self
    def parse(sexp); end
  end
end

Given::BinaryOperation::BINARY_EXPLAINATIONS = T.let(T.unsafe(nil), Hash)

# Provide run-time class methods to support Given infrastructure.
# Methods that begin with _Gvn_ are considered private and
# implementation specific, and should not be directly called by
# appliation code. Other methods without the _Gvn_ prefix are public
# and intended for use by the application developer.
#
# (Note that private class methods are prefixed with _Gvn_ and
# private instance methods are prefixed with _gvn_).
module Given::ClassExtensions
  # Provide an assertion that shares setup with a peer Then command.
  def And(&block); end

  # Declare a "given" of the current specification.  If the given
  # is named, the block will be lazily evaluated the first time
  # the given is mentioned by name in the specification.  If the
  # given is unnamed, the block is evaluated for side effects
  # every time the specification is executed.
  #
  # :call-seq:
  #   Given(:name) { ... code ... }
  #   Given { ... code ... }
  def Given(*args, &block); end

  # Declare a named given of the current specification.  Similar
  # to the named version of the "Given" command, except that the
  # block is always evaluated.
  #
  # :call-seq:
  #   Given!(:name) { ... code ... }
  def Given!(name, &block); end

  # Establish an invariant that must be true for all Then blocks
  # in the current (and nested) scopes.
  def Invariant(&block); end

  # Provide an assertion about the specification.
  #
  # Then supplies an assertion that should be true after all the
  # Given and When blocks have been run. All invariants in scope
  # will be checked before the Then block is run.
  #
  # :call-seq:
  #   Then { ... assertion ... }
  def Then(*metadata, &block); end

  # Declare the code that is under test.
  #
  # :call-seq:
  #   When(:named_result) { ... code_under_test ... }
  #   When { ... code_under_test ... }
  def When(*args, &block); end

  # List of the and blocks directly in the current describe/context
  # block.
  def _Gvn_and_blocks; end

  # Context information ofr the current describe/context block.
  def _Gvn_context_info; end

  # List of all givens directly in the current describe/context
  # block.
  def _Gvn_givens; end

  # List of all invariants directly in the current
  # describe/context block.
  def _Gvn_invariants; end

  # Line extractor for the context.
  def _Gvn_lines; end

  # Trigger the evaluation of a Given! block by referencing its
  # name.
  def _Gvn_trigger_given(name); end

  # Normal When clause actions.
  def _Gvn_when_actions(block); end

  # Normal When clause actions except that exceptions are captured
  # in a Failure object.
  def _Gvn_when_actions_with_capture(name, block); end

  # Configure the use of natural assertions in this context.
  def use_natural_assertions(enabled = T.unsafe(nil)); end
end

class Given::EvalErr
  # @return [EvalErr] a new instance of EvalErr
  def initialize(str); end

  def inspect; end
  def size; end
  def to_s; end
end

class Given::Evaluator
  # @return [Evaluator] a new instance of Evaluator
  def initialize(example, block); end

  def eval_string(exp_string); end
  def location; end

  private

  def eval_in_context(exp_string); end
  def limit_length(string); end
end

Given::Evaluator::MAX_INSPECT_SIZE = T.let(T.unsafe(nil), Integer)

# Failure objects will raise the given exception whenever you try
# to send it *any* message.
class Given::Failure < ::BasicObject
  # Create a failure object that will rethrow the given exception
  # whenever an undefined method is called.
  #
  # @return [Failure] a new instance of Failure
  def initialize(exception); end

  # Failure objects may be compared for in-equality. If the comparison
  # object is not a matcher, then the exception is re-raised.
  def !=(other); end

  # Failure objects may be compared for equality. If the comparison
  # object is not a matcher, then the exception is re-raised.
  def ==(other); end

  # Failure objects will respond to #is_a?.
  #
  # @return [Boolean]
  def is_a?(klass); end

  # Most methods will just re-raise the captured exception.
  def method_missing(sym, *args, &block); end

  # Report that we respond to a limited number of methods.
  #
  # @return [Boolean]
  def respond_to?(method_symbol); end

  private

  # Re-raise the captured exception.
  def die; end

  # Is the comparison object a failure matcher?
  #
  # @return [Boolean]
  def failure_matcher?(other); end

  class << self
    # Evaluate a block. If an exception is raised, capture it in a
    # Failure object. Explicitly listed exceptions are passed thru
    # without capture.
    def capture(*exceptions); end
  end
end

class Given::FailureMatcher
  # @return [FailureMatcher] a new instance of FailureMatcher
  def initialize(exception_class, message_pattern); end

  def !=(other); end
  def ==(other); end

  # @return [Boolean]
  def does_not_match?(possible_failure); end

  def inspect; end

  # @return [Boolean]
  def matches?(possible_failure); end

  private

  def description; end
  def extract_exception(possible_failure); end
  def match_exception(ex); end
  def match_or_fail(possible_failure); end
  def mismatch_or_fail(possible_failure); end
  def unexpected_description; end
end

module Given::FailureMethod
  def Failure(exception_class = T.unsafe(nil), message_pattern = T.unsafe(nil)); end
end

class Given::FileCache
  # @return [FileCache] a new instance of FileCache
  def initialize; end

  def get(file_name); end

  private

  def read_lines(file_name); end
end

module Given::Fuzzy
  # Create an approximate number that is approximately equal to
  # the given number, plus or minus the delta value. If no
  # explicit delta is given, then the default delta that is about
  # 10X the size of the smallest possible change in the given
  # number will be used.
  def about(*args); end
end

class Given::Fuzzy::FuzzyNumber
  # @return [FuzzyNumber] a new instance of FuzzyNumber
  def initialize(exact_value); end

  # True if the other number is in range of the fuzzy number.
  def ==(other); end

  # Set the delta for a fuzzy number.
  def delta(delta); end

  # Returns the value of attribute delta_amount.
  def delta_amount; end

  # Specifying the number of epsilons to be used in setting the
  # delta.
  def epsilon(neps); end

  # Returns the value of attribute exact_value.
  def exact_value; end

  # @return [Boolean]
  def exactly_equals?(other); end

  # High limit of the fuzzy number.
  def high_limit; end

  # Low limit of the fuzzy number.
  def low_limit; end

  # Specifying a percentage of the exact number to be used in
  # setting the delta.
  def percent(percentage); end

  def to_s; end
end

Given::Fuzzy::FuzzyNumber::DEFAULT_EPSILON = T.let(T.unsafe(nil), Float)

# Provide run-time instance methods to support Given infrastructure.
# All the methods in this module are considered private and
# implementation-specific, and should not be directly called by the
# application developer.
#
# By convention, these private instance specific methods are
# prefixed with _gvn_ to avoid name collisions with application
# methods defined in a spec.
#
# (Note that private class methods are prefixed with _Gvn_ and
# private instance methods are prefixed with _gvn_).
module Given::InstanceExtensions
  # Determine of the natural assertion pass/fail status of the block
  #
  # @return [Boolean]
  def _gvn_block_passed?(block); end

  def _gvn_check_ands; end

  # Check all the invariants in the current and surrounding
  # describe/context blocks, starting with the outermost context.
  def _gvn_check_invariants; end

  # List of containing contexts in order from outermost to
  # innermost.
  def _gvn_contexts; end

  # Establish all the Given preconditions the current and
  # surrounding describe/context blocks, starting with the
  # outermost context.
  def _gvn_establish_givens; end

  # Evaluate a Then, And, or Invariant assertion.
  def _gvn_evaluate(clause_type, block); end

  # Return the context information for keyword from the innermost
  # defining context.
  def _gvn_info(keyword); end

  # List of containing contexts in order from innermost to
  # outermost.
  def _gvn_inner_contexts; end

  # Return the configuration value for natural assertions.
  #
  # If natural assertions are not configured in the contexts, use
  # the global configuration value.
  #
  # @return [Boolean]
  def _gvn_na_configured?; end

  # Naturally assert the block (based on +passed+).
  def _gvn_naturally_assert(clause_type, block, passed); end

  # Should a natural assertion failure message be generated?
  #
  # A natural assertion failure message is generated if the
  # assertion has non-empty content. The configuration options for
  # natural assertions are checked and applied accordingly.
  #
  # @return [Boolean]
  def _gvn_need_na_message?(nassert); end

  # Implement the run-time semantics of the Then clause.
  def _gvn_then(&block); end
end

class Given::InvalidThenError < ::StandardError; end

class Given::LineExtractor
  # @return [LineExtractor] a new instance of LineExtractor
  def initialize(file_cache = T.unsafe(nil)); end

  def line(file_name, line); end
  def to_s; end

  private

  # @return [Boolean]
  def complete_sexp?(sexp); end

  def extract_lines_from(lines, line_index); end

  # @return [Boolean]
  def incomplete?(string); end

  def parse(string); end
end

Given::NATURAL_ASSERTIONS_SUPPORTED = T.let(T.unsafe(nil), TrueClass)

class Given::NaturalAssertion
  # @return [NaturalAssertion] a new instance of NaturalAssertion
  def initialize(clause_type, block, example, line_extractor); end

  # @return [Boolean]
  def has_content?; end

  def message; end

  private

  def adjust_indentation(string); end
  def assertion_sexp; end
  def assertion_subexpressions; end

  # @return [Boolean]
  def contains_multiple_statements?(block_sexp); end

  # Safely dive into an array with a list of indicies. Return nil
  # if the element doesn't exist, or if the intermediate result is
  # not indexable.
  def delve(ary, *indicies); end

  def display_pairs(pairs); end
  def eval_sexp(sexp); end
  def explain_expected(expect_msg, expect_sexp, got_msg, got_sexp); end
  def explain_failure; end
  def expression_value_pairs; end
  def extract_brace_block(sexp); end
  def extract_first_statement(block_sexp); end
  def extract_statement_from_block(block_sexp); end
  def extract_test_expression(sexp); end

  # @return [Boolean]
  def has_block_sexp?(sexp); end

  def max_line_length(string); end

  # @return [Boolean]
  def method_with_block?(sexp); end

  # @return [Boolean]
  def multi_line?(string); end

  # @return [Boolean]
  def program_sexp?(sexp); end

  def set_file_and_line(block); end
  def source; end
  def source_line; end
  def suggest_width(pairs); end

  # @return [Boolean]
  def then_block?(sexp); end
end

Given::NaturalAssertion::VOID_SEXP = T.let(T.unsafe(nil), Array)
Given::NaturalAssertion::WRAP_WIDTH = T.let(T.unsafe(nil), Integer)
Given::VERSION = T.let(T.unsafe(nil), String)
Given::VERSION_BUILD = T.let(T.unsafe(nil), Integer)
Given::VERSION_MAJOR = T.let(T.unsafe(nil), Integer)
Given::VERSION_MINOR = T.let(T.unsafe(nil), Integer)
Given::VERSION_NUMBERS = T.let(T.unsafe(nil), Array)

module RSpec
  class << self
    def clear_examples; end
    def configuration; end
    def configuration=(_arg0); end
    def configure; end
    def const_missing(name); end
    def context(*args, &example_group_block); end
    def current_example; end
    def current_example=(example); end
    def describe(*args, &example_group_block); end
    def example_group(*args, &example_group_block); end
    def fcontext(*args, &example_group_block); end
    def fdescribe(*args, &example_group_block); end
    def reset; end
    def shared_context(name, *args, &block); end
    def shared_examples(name, *args, &block); end
    def shared_examples_for(name, *args, &block); end
    def world; end
    def world=(_arg0); end
    def xcontext(*args, &example_group_block); end
    def xdescribe(*args, &example_group_block); end
  end
end

module RSpec::Expectations
  class << self
    def configuration; end
    def differ; end
    def fail_with(message, expected = T.unsafe(nil), actual = T.unsafe(nil)); end
  end
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::NegativeExpectationHandler
  class << self
    def _gvn_rspec_original_handle_matcher(actual, initial_matcher, custom_message = T.unsafe(nil), &block); end
    def does_not_match?(matcher, actual, &block); end
    def handle_matcher(actual, matcher, message = T.unsafe(nil), &block); end
    def opposite_should_method; end
    def should_method; end
    def verb; end
  end
end

class RSpec::Expectations::PositiveExpectationHandler
  class << self
    def _gvn_rspec_original_handle_matcher(actual, initial_matcher, custom_message = T.unsafe(nil), &block); end
    def handle_matcher(actual, matcher, message = T.unsafe(nil), &block); end
    def opposite_should_method; end
    def should_method; end
    def verb; end
  end
end

module RSpec::Given
  class << self
    # Defined for backwards compatibility
    def use_natural_assertions(*args); end
  end
end

module RSpec::Given::BeforeHack
  # Some frameworks don't support a robust before block, so we
  # always use this one. In RSpec, we just delegate to the real
  # before block handler.
  def _Gvn_before(*args, &block); end
end

# Framework interface for RSpec/Given.
class RSpec::Given::Framework
  def count_assertion; end

  # @return [Boolean]
  def explicit_assertions?; end

  def explicitly_asserted; end
  def fail_with(*args); end
  def pending_error; end
  def start_evaluation; end
end

module RSpec::Given::HaveFailed
  # Simular to raise_error(...), but reads a bit better when using
  # a failure result from a when clause.
  #
  # Typical Usage:
  #
  #    When(:result) { fail "OUCH" }
  #    Then { expect(result).to have_failed(StandardError, /OUCH/) }
  #
  #    When(:result) { good_code }
  #    Then { expect(result).to_not have_failed }
  #
  # :call-seq:
  #    have_failed([exception_class [, message_pattern]])
  #    have_failed([exception_class [, message_pattern]]) { |ex| ... }
  def have_failed(error = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Simular to raise_error(...), but reads a bit better when using
  # a failure result from a when clause.
  #
  # Typical Usage:
  #
  #    When(:result) { fail "OUCH" }
  #    Then { expect(result).to have_failed(StandardError, /OUCH/) }
  #
  #    When(:result) { good_code }
  #    Then { expect(result).to_not have_failed }
  #
  # :call-seq:
  #    have_failed([exception_class [, message_pattern]])
  #    have_failed([exception_class [, message_pattern]]) { |ex| ... }
  def have_raised(error = T.unsafe(nil), message = T.unsafe(nil), &block); end
end

# The Pre-Rspec 2.12 version of the matcher
class RSpec::Given::HaveFailed::HaveFailedMatcher < ::RSpec::Matchers::BuiltIn::RaiseError
  # @return [Boolean]
  def does_not_match?(given_proc); end

  # @return [Boolean]
  def matches?(given_proc, negative_expectation = T.unsafe(nil)); end

  def to_s; end
end

RSpec::Given::MONKEY = T.let(T.unsafe(nil), TrueClass)
RSpec::MODULES_TO_AUTOLOAD = T.let(T.unsafe(nil), Hash)
RSpec::SharedContext = RSpec::Core::SharedContext
