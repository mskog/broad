# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sinatra` gem.
# Please instead update this file by running `bin/tapioca gem sinatra`.

# Rack::Attack::Request is the same as ::Rack::Request by default.
#
# This is a safe place to add custom helper methods to the request object
# through monkey patching:
#
#   class Rack::Attack::Request < ::Rack::Request
#     def localhost?
#       ip == "127.0.0.1"
#     end
#   end
#
#   Rack::Attack.safelist("localhost") {|req| req.localhost? }
module Rack
  class << self
    # Return the Rack release as a dotted string.
    def release; end

    # Return the Rack protocol version as a dotted string.
    def version; end
  end
end

# Rack::Builder implements a small DSL to iteratively construct Rack
# applications.
#
# Example:
#
#  require 'rack/lobster'
#  app = Rack::Builder.new do
#    use Rack::CommonLogger
#    use Rack::ShowExceptions
#    map "/lobster" do
#      use Rack::Lint
#      run Rack::Lobster.new
#    end
#  end
#
#  run app
#
# Or
#
#  app = Rack::Builder.app do
#    use Rack::CommonLogger
#    run lambda { |env| [200, {'Content-Type' => 'text/plain'}, ['OK']] }
#  end
#
#  run app
#
# +use+ adds middleware to the stack, +run+ dispatches to an application.
# You can use +map+ to construct a Rack::URLMap in a convenient way.
class Rack::Builder
  include ::Sinatra::Delegator

  # Initialize a new Rack::Builder instance.  +default_app+ specifies the
  # default application if +run+ is not called later.  If a block
  # is given, it is evaluted in the context of the instance.
  #
  # @return [Builder] a new instance of Builder
  def initialize(default_app = T.unsafe(nil), &block); end

  # Call the Rack application generated by this builder instance. Note that
  # this rebuilds the Rack application and runs the warmup code (if any)
  # every time it is called, so it should not be used if performance is important.
  def call(env); end

  # Freeze the app (set using run) and all middleware instances when building the application
  # in to_app.
  def freeze_app; end

  # Creates a route within the application.  Routes under the mapped path will be sent to
  # the Rack application specified by run inside the block.  Other requests will be sent to the
  # default application specified by run outside the block.
  #
  #   Rack::Builder.app do
  #     map '/heartbeat' do
  #       run Heartbeat
  #     end
  #     run App
  #   end
  #
  # The +use+ method can also be used inside the block to specify middleware to run under a specific path:
  #
  #   Rack::Builder.app do
  #     map '/heartbeat' do
  #       use Middleware
  #       run Heartbeat
  #     end
  #     run App
  #   end
  #
  # This example includes a piece of middleware which will run before +/heartbeat+ requests hit +Heartbeat+.
  #
  # Note that providing a +path+ of +/+ will ignore any default application given in a +run+ statement
  # outside the block.
  def map(path, &block); end

  # Takes an argument that is an object that responds to #call and returns a Rack response.
  # The simplest form of this is a lambda object:
  #
  #   run lambda { |env| [200, { "Content-Type" => "text/plain" }, ["OK"]] }
  #
  # However this could also be a class:
  #
  #   class Heartbeat
  #     def self.call(env)
  #      [200, { "Content-Type" => "text/plain" }, ["OK"]]
  #     end
  #   end
  #
  #   run Heartbeat
  def run(app); end

  # Return the Rack application generated by this instance.
  def to_app; end

  # Specifies middleware to use in a stack.
  #
  #   class Middleware
  #     def initialize(app)
  #       @app = app
  #     end
  #
  #     def call(env)
  #       env["rack.some_header"] = "setting an example"
  #       @app.call(env)
  #     end
  #   end
  #
  #   use Middleware
  #   run lambda { |env| [200, { "Content-Type" => "text/plain" }, ["OK"]] }
  #
  # All requests through to this application will first be processed by the middleware class.
  # The +call+ method in this example sets an additional environment key which then can be
  # referenced in the application if required.
  def use(middleware, *args, **_arg2, &block); end

  # Takes a lambda or block that is used to warm-up the application. This block is called
  # before the Rack application is returned by to_app.
  #
  #   warmup do |app|
  #     client = Rack::MockRequest.new(app)
  #     client.get('/')
  #   end
  #
  #   use SomeMiddleware
  #   run MyApp
  def warmup(prc = T.unsafe(nil), &block); end

  private

  # Generate a URLMap instance by generating new Rack applications for each
  # map block in this instance.
  def generate_map(default_app, mapping); end

  class << self
    # Create a new Rack::Builder instance and return the Rack application
    # generated from it.
    def app(default_app = T.unsafe(nil), &block); end

    # Load the given file as a rackup file, treating the
    # contents as if specified inside a Rack::Builder block.
    #
    # Treats the first comment at the beginning of a line
    # that starts with a backslash as options similar to
    # options passed on a rackup command line.
    #
    # Ignores content in the file after +__END__+, so that
    # use of +__END__+ will not result in a syntax error.
    #
    # Example config.ru file:
    #
    #   $ cat config.ru
    #
    #   #\ -p 9393
    #
    #   use Rack::ContentLength
    #   require './app.rb'
    #   run App
    def load_file(path, opts = T.unsafe(nil)); end

    # Evaluate the given +builder_script+ string in the context of
    # a Rack::Builder block, returning a Rack application.
    def new_from_string(builder_script, file = T.unsafe(nil)); end

    # Parse the given config file to get a Rack application.
    #
    # If the config file ends in +.ru+, it is treated as a
    # rackup file and the contents will be treated as if
    # specified inside a Rack::Builder block, using the given
    # options.
    #
    # If the config file does not end in +.ru+, it is
    # required and Rack will use the basename of the file
    # to guess which constant will be the Rack application to run.
    # The options given will be ignored in this case.
    #
    # Examples:
    #
    #   Rack::Builder.parse_file('config.ru')
    #   # Rack application built using Rack::Builder.new
    #
    #   Rack::Builder.parse_file('app.rb')
    #   # requires app.rb, which can be anywhere in Ruby's
    #   # load path. After requiring, assumes App constant
    #   # contains Rack application
    #
    #   Rack::Builder.parse_file('./my_app.rb')
    #   # requires ./my_app.rb, which should be in the
    #   # process's current directory.  After requiring,
    #   # assumes MyApp constant contains Rack application
    def parse_file(config, opts = T.unsafe(nil)); end
  end
end

# https://stackoverflow.com/questions/2223882/whats-the-difference-between-utf-8-and-utf-8-without-bom
Rack::Builder::UTF_8_BOM = T.let(T.unsafe(nil), String)

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Rack::CommonLogger forwards every request to the given +app+, and
# logs a line in the
# {Apache common log format}[http://httpd.apache.org/docs/1.3/logs.html#common]
# to the configured logger.
class Rack::CommonLogger
  # +logger+ can be any object that supports the +write+ or +<<+ methods,
  # which includes the standard library Logger.  These methods are called
  # with a single string argument, the log message.
  # If +logger+ is nil, CommonLogger will fall back <tt>env['rack.errors']</tt>.
  #
  # @return [CommonLogger] a new instance of CommonLogger
  def initialize(app, logger = T.unsafe(nil)); end

  # Log all requests in common_log format after a response has been
  # returned.  Note that if the app raises an exception, the request
  # will not be logged, so if exception handling middleware are used,
  # they should be loaded after this middleware.  Additionally, because
  # the logging happens after the request body has been fully sent, any
  # exceptions raised during the sending of the response body will
  # cause the request not to be logged.
  def call(env); end

  def call_without_check(env); end

  private

  # Attempt to determine the content length for the response to
  # include it in the logged data.
  def extract_content_length(headers); end

  # Log the request to the configured logger.
  def log(env, status, header, began_at); end
end

# Common Log Format: http://httpd.apache.org/docs/1.3/logs.html#common
#
#   lilith.local - - [07/Aug/2006 23:58:02 -0400] "GET / HTTP/1.1" 500 -
#
#   %{%s - %s [%s] "%s %s%s %s" %d %s\n} %
#
# The actual format is slightly different than the above due to the
# separation of SCRIPT_NAME and PATH_INFO, and because the elapsed
# time in seconds is included at the end.
Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files

# HTTP method verbs
Rack::GET = T.let(T.unsafe(nil), String)

Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)
Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)

module Rack::Protection
  class << self
    def new(app, options = T.unsafe(nil)); end
  end
end

# Prevented attack::   CSRF
# Supported browsers:: all
# More infos::         http://en.wikipedia.org/wiki/Cross-site_request_forgery
#
# This middleware only accepts requests other than <tt>GET</tt>,
# <tt>HEAD</tt>, <tt>OPTIONS</tt>, <tt>TRACE</tt> if their given access
# token matches the token included in the session.
#
# It checks the <tt>X-CSRF-Token</tt> header and the <tt>POST</tt> form
# data.
#
# Compatible with the {rack-csrf}[https://rubygems.org/gems/rack_csrf] gem.
#
# == Options
#
# [<tt>:authenticity_param</tt>] the name of the param that should contain
#                                the token on a request. Default value:
#                                <tt>"authenticity_token"</tt>
#
# [<tt>:key</tt>] the name of the param that should contain
#                                the token in the session. Default value:
#                                <tt>:csrf</tt>
#
# [<tt>:allow_if</tt>] a proc for custom allow/deny logic. Default value:
#                                <tt>nil</tt>
#
# == Example: Forms application
#
# To show what the AuthenticityToken does, this section includes a sample
# program which shows two forms. One with, and one without a CSRF token
# The one without CSRF token field will get a 403 Forbidden response.
#
# Install the gem, then run the program:
#
#   gem install 'rack-protection'
#   ruby server.rb
#
# Here is <tt>server.rb</tt>:
#
#   require 'rack/protection'
#
#   app = Rack::Builder.app do
#     use Rack::Session::Cookie, secret: 'secret'
#     use Rack::Protection::AuthenticityToken
#
#     run -> (env) do
#       [200, {}, [
#         <<~EOS
#           <!DOCTYPE html>
#           <html lang="en">
#           <head>
#             <meta charset="UTF-8" />
#             <title>rack-protection minimal example</title>
#           </head>
#           <body>
#             <h1>Without Authenticity Token</h1>
#             <p>This takes you to <tt>Forbidden</tt></p>
#             <form action="" method="post">
#               <input type="text" name="foo" />
#               <input type="submit" />
#             </form>
#
#             <h1>With Authenticity Token</h1>
#             <p>This successfully takes you to back to this form.</p>
#             <form action="" method="post">
#               <input type="hidden" name="authenticity_token" value="#{Rack::Protection::AuthenticityToken.token(env['rack.session'])}" />
#               <input type="text" name="foo" />
#               <input type="submit" />
#             </form>
#           </body>
#           </html>
#         EOS
#       ]]
#     end
#   end
#
#   Rack::Handler::WEBrick.run app
#
# == Example: Customize which POST parameter holds the token
#
# To customize the authenticity parameter for form data, use the
# <tt>:authenticity_param</tt> option:
#   use Rack::Protection::AuthenticityToken, authenticity_param: 'your_token_param_name'
class Rack::Protection::AuthenticityToken < ::Rack::Protection::Base
  # @return [Boolean]
  def accepts?(env); end

  def default_options; end
  def mask_authenticity_token(session, path: T.unsafe(nil), method: T.unsafe(nil)); end

  private

  def compare_with_global_token(token, session); end
  def compare_with_per_form_token(token, session, request); end
  def compare_with_real_token(token, session); end
  def decode_token(token); end
  def encode_token(token); end
  def global_token(session); end

  # Creates a masked version of the authenticity token that varies
  # on each request. The masking is used to mitigate SSL attacks
  # like BREACH.
  def mask_token(token); end

  # @return [Boolean]
  def masked_token?(token); end

  def per_form_token(session, path, method); end
  def real_token(session); end
  def set_token(session); end
  def token_hmac(session, identifier); end

  # Essentially the inverse of +mask_token+.
  def unmask_token(masked_token); end

  # @return [Boolean]
  def unmasked_token?(token); end

  # Checks the client's masked token to see if it matches the
  # session token.
  #
  # @return [Boolean]
  def valid_token?(env, token); end

  def xor_byte_strings(s1, s2); end

  class << self
    def random_token; end
    def token(session, path: T.unsafe(nil), method: T.unsafe(nil)); end
  end
end

Rack::Protection::AuthenticityToken::TOKEN_LENGTH = T.let(T.unsafe(nil), Integer)

class Rack::Protection::Base
  # @return [Base] a new instance of Base
  def initialize(app, options = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  # @return [Boolean]
  def accepts?(env); end

  # Returns the value of attribute app.
  def app; end

  def call(env); end
  def default_options; end
  def default_reaction(env); end
  def deny(env); end
  def drop_session(env); end
  def encrypt(value); end

  # @return [Boolean]
  def html?(headers); end

  def instrument(env); end

  # Returns the value of attribute options.
  def options; end

  def origin(env); end
  def random_string(secure = T.unsafe(nil)); end
  def react(env); end
  def referrer(env); end
  def report(env); end

  # @return [Boolean]
  def safe?(env); end

  def secure_compare(a, b); end
  def session(env); end

  # @return [Boolean]
  def session?(env); end

  def warn(env, message); end

  class << self
    def default_options(options); end
    def default_reaction(reaction); end
  end
end

Rack::Protection::Base::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# Prevented attack::   XSS and others
# Supported browsers:: Firefox 23+, Safari 7+, Chrome 25+, Opera 15+
#
# Description:: Content Security Policy, a mechanism web applications
#               can use to mitigate a broad class of content injection
#               vulnerabilities, such as cross-site scripting (XSS).
#               Content Security Policy is a declarative policy that lets
#               the authors (or server administrators) of a web application
#               inform the client about the sources from which the
#               application expects to load resources.
#
# More info::   W3C CSP Level 1 : https://www.w3.org/TR/CSP1/ (deprecated)
#               W3C CSP Level 2 : https://www.w3.org/TR/CSP2/ (current)
#               W3C CSP Level 3 : https://www.w3.org/TR/CSP3/ (draft)
#               https://developer.mozilla.org/en-US/docs/Web/Security/CSP
#               http://caniuse.com/#search=ContentSecurityPolicy
#               http://content-security-policy.com/
#               https://securityheaders.io
#               https://scotthelme.co.uk/csp-cheat-sheet/
#               http://www.html5rocks.com/en/tutorials/security/content-security-policy/
#
# Sets the 'Content-Security-Policy[-Report-Only]' header.
#
# Options: ContentSecurityPolicy configuration is a complex topic with
#          several levels of support that has evolved over time.
#          See the W3C documentation and the links in the more info
#          section for CSP usage examples and best practices. The
#          CSP3 directives in the 'NO_ARG_DIRECTIVES' constant need to be
#          presented in the options hash with a boolean 'true' in order
#          to be used in a policy.
class Rack::Protection::ContentSecurityPolicy < ::Rack::Protection::Base
  def call(env); end
  def csp_policy; end
  def default_options; end
end

Rack::Protection::ContentSecurityPolicy::DIRECTIVES = T.let(T.unsafe(nil), Array)
Rack::Protection::ContentSecurityPolicy::NO_ARG_DIRECTIVES = T.let(T.unsafe(nil), Array)

# Prevented attack::   Cookie Tossing
# Supported browsers:: all
# More infos::         https://github.com/blog/1466-yummy-cookies-across-domains
#
# Does not accept HTTP requests if the HTTP_COOKIE header contains more than one
# session cookie. This does not protect against a cookie overflow attack.
#
# Options:
#
# session_key:: The name of the session cookie (default: 'rack.session')
class Rack::Protection::CookieTossing < ::Rack::Protection::Base
  # @return [Boolean]
  def accepts?(env); end

  def bad_cookies; end
  def call(env); end
  def cookie_paths(path); end
  def default_reaction(env); end
  def empty_cookie(host, path); end
  def redirect(env); end
  def remove_bad_cookies(request, response); end
  def session_key; end
end

# Prevented attack::   XSS
# Supported browsers:: all
# More infos::         http://en.wikipedia.org/wiki/Cross-site_scripting
#
# Automatically escapes Rack::Request#params so they can be embedded in HTML
# or JavaScript without any further issues. Calls +html_safe+ on the escaped
# strings if defined, to avoid double-escaping in Rails.
#
# Options:
# escape:: What escaping modes to use, should be Symbol or Array of Symbols.
#          Available: :html (default), :javascript, :url
class Rack::Protection::EscapedParams < ::Rack::Protection::Base
  extend ::Rack::Utils

  # @return [EscapedParams] a new instance of EscapedParams
  def initialize(*_arg0); end

  def call(env); end
  def default_options; end
  def escape(object); end
  def escape_hash(hash); end
  def escape_string(str); end
  def handle(hash); end

  class << self
    private

    def escape_url(s); end
  end
end

# Prevented attack::   CSRF
# Supported browsers:: all
# More infos::         http://en.wikipedia.org/wiki/Cross-site_request_forgery
#
# Only accepts submitted forms if a given access token matches the token
# included in the session. Does not expect such a token from Ajax request.
#
# This middleware is not used when using the Rack::Protection collection,
# since it might be a security issue, depending on your application
#
# Compatible with rack-csrf.
class Rack::Protection::FormToken < ::Rack::Protection::AuthenticityToken
  # @return [Boolean]
  def accepts?(env); end
end

# Prevented attack::   Clickjacking
# Supported browsers:: Internet Explorer 8, Firefox 3.6.9, Opera 10.50,
#                      Safari 4.0, Chrome 4.1.249.1042 and later
# More infos::         https://developer.mozilla.org/en/The_X-FRAME-OPTIONS_response_header
#
# Sets X-Frame-Options header to tell the browser avoid embedding the page
# in a frame.
#
# Options:
#
# frame_options:: Defines who should be allowed to embed the page in a
#                 frame. Use :deny to forbid any embedding, :sameorigin
#                 to allow embedding from the same origin (default).
class Rack::Protection::FrameOptions < ::Rack::Protection::Base
  def call(env); end
  def default_options; end
  def frame_options; end
end

# Prevented attack::   CSRF
# Supported browsers:: Google Chrome 2, Safari 4 and later
# More infos::         http://en.wikipedia.org/wiki/Cross-site_request_forgery
#                      http://tools.ietf.org/html/draft-abarth-origin
#
# Does not accept unsafe HTTP requests when value of Origin HTTP request header
# does not match default or permitted URIs.
#
# If you want to permit a specific domain, you can pass in as the `:permitted_origins` option:
#
#     use Rack::Protection, permitted_origins: ["http://localhost:3000", "http://127.0.01:3000"]
#
# The `:allow_if` option can also be set to a proc to use custom allow/deny logic.
class Rack::Protection::HttpOrigin < ::Rack::Protection::Base
  # @return [Boolean]
  def accepts?(env); end

  def base_url(env); end
  def default_options; end
  def default_reaction(env); end
end

Rack::Protection::HttpOrigin::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# Prevented attack::   IP spoofing
# Supported browsers:: all
# More infos::         http://blog.c22.cc/2011/04/22/surveymonkey-ip-spoofing/
#
# Detect (some) IP spoofing attacks.
class Rack::Protection::IPSpoofing < ::Rack::Protection::Base
  # @return [Boolean]
  def accepts?(env); end

  def default_reaction(env); end
end

# Prevented attack::   CSRF
# Supported browsers:: all
# More infos::         http://flask.pocoo.org/docs/0.10/security/#json-security
#                      http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
#
# JSON GET APIs are vulnerable to being embedded as JavaScript when the
# Array prototype has been patched to track data. Checks the referrer
# even on GET requests if the content type is JSON.
#
# If request includes Origin HTTP header, defers to HttpOrigin to determine
# if the request is safe. Please refer to the documentation for more info.
#
# The `:allow_if` option can be set to a proc to use custom allow/deny logic.
class Rack::Protection::JsonCsrf < ::Rack::Protection::Base
  def call(env); end
  def close_body(body); end
  def default_options; end

  # @return [Boolean]
  def has_vector?(request, headers); end

  def react(env); end
  def react_and_close(env, body); end
end

# Prevented attack::   Directory traversal
# Supported browsers:: all
# More infos::         http://en.wikipedia.org/wiki/Directory_traversal
#
# Unescapes '/' and '.', expands +path_info+.
# Thus <tt>GET /foo/%2e%2e%2fbar</tt> becomes <tt>GET /bar</tt>.
class Rack::Protection::PathTraversal < ::Rack::Protection::Base
  def call(env); end
  def cleanup(path); end
end

# Prevented attack::   Secret leakage, third party tracking
# Supported browsers:: mixed support
# More infos::         https://www.w3.org/TR/referrer-policy/
#                      https://caniuse.com/#search=referrer-policy
#
# Sets Referrer-Policy header to tell the browser to limit the Referer header.
#
# Options:
# referrer_policy:: The policy to use (default: 'strict-origin-when-cross-origin')
class Rack::Protection::ReferrerPolicy < ::Rack::Protection::Base
  def call(env); end
  def default_options; end
end

# Prevented attack::   CSRF
# Supported browsers:: all
# More infos::         http://en.wikipedia.org/wiki/Cross-site_request_forgery
#
# Does not accept unsafe HTTP requests if the Referer [sic] header is set to
# a different host.
class Rack::Protection::RemoteReferrer < ::Rack::Protection::Base
  # @return [Boolean]
  def accepts?(env); end

  def default_reaction(env); end
end

# Prevented attack::   CSRF
# Supported browsers:: all
# More infos::         http://en.wikipedia.org/wiki/Cross-site_request_forgery
#
# Only accepts unsafe HTTP requests if a given access token matches the token
# included in the session *or* the request comes from the same origin.
#
# Compatible with rack-csrf.
class Rack::Protection::RemoteToken < ::Rack::Protection::AuthenticityToken
  # @return [Boolean]
  def accepts?(env); end

  def default_reaction(env); end
end

# Prevented attack::   Session Hijacking
# Supported browsers:: all
# More infos::         http://en.wikipedia.org/wiki/Session_hijacking
#
# Tracks request properties like the user agent in the session and empties
# the session if those properties change. This essentially prevents attacks
# from Firesheep. Since all headers taken into consideration can be
# spoofed, too, this will not prevent determined hijacking attempts.
class Rack::Protection::SessionHijacking < ::Rack::Protection::Base
  # @return [Boolean]
  def accepts?(env); end

  def default_options; end
  def default_reaction(env); end
  def encrypt(value); end
end

# Prevented attack::   Protects against against protocol downgrade attacks and cookie hijacking.
# Supported browsers:: all
# More infos::         https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security
#
# browser will prevent any communications from being sent over HTTP
# to the specified domain and will instead send all communications over HTTPS.
# It also prevents HTTPS click through prompts on browsers.
#
# Options:
#
# max_age:: How long future requests to the domain should go over HTTPS; specified in seconds
# include_subdomains:: If all present and future subdomains will be HTTPS
# preload:: Allow this domain to be included in browsers HSTS preload list. See https://hstspreload.appspot.com/
class Rack::Protection::StrictTransport < ::Rack::Protection::Base
  def call(env); end
  def default_options; end
  def strict_transport; end
end

Rack::Protection::VERSION = T.let(T.unsafe(nil), String)

# Prevented attack::   Non-permanent XSS
# Supported browsers:: Internet Explorer 8+ and Chrome
# More infos::         http://blogs.msdn.com/b/ie/archive/2008/07/01/ie8-security-part-iv-the-xss-filter.aspx
#
# Sets X-XSS-Protection header to tell the browser to block attacks.
#
# Options:
# xss_mode:: How the browser should prevent the attack (default: :block)
class Rack::Protection::XSSHeader < ::Rack::Protection::Base
  def call(env); end
  def default_options; end
end

Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# Rack environment variables
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)

# The Rack protocol version number implemented.
Rack::VERSION = T.let(T.unsafe(nil), Array)

module Sinatra
  class << self
    # Include the helper modules provided in Sinatra's request context.
    def helpers(*extensions, &block); end

    # Create a new Sinatra application; the block is evaluated in the class scope.
    def new(base = T.unsafe(nil), &block); end

    # Extend the top-level DSL with the modules provided.
    def register(*extensions, &block); end

    # Use the middleware for classic applications.
    def use(*args, &block); end
  end
end

# Execution context for classic style (top-level) applications. All
# DSL methods executed on main are delegated to this class.
#
# The Application class should not be subclassed, unless you want to
# inherit all settings, routes, handlers, and error pages from the
# top-level. Subclassing Sinatra::Base is highly recommended for
# modular applications.
class Sinatra::Application < ::Sinatra::Base
  class << self
    def app_file; end
    def app_file=(val); end
    def app_file?; end
    def logging; end
    def logging=(val); end
    def logging?; end
    def method_override; end
    def method_override=(val); end
    def method_override?; end
    def register(*extensions, &block); end
    def run; end
    def run=(val); end
    def run?; end
  end
end

class Sinatra::BadRequest < ::Sinatra::Error
  def http_status; end
end

# Base class for all Sinatra applications and middleware.
class Sinatra::Base
  include ::Rack::Utils
  include ::Sinatra::Helpers
  include ::Sinatra::Templates

  # @return [Base] a new instance of Base
  # @yield [_self]
  # @yieldparam _self [Sinatra::Base] the object that the method was called on
  def initialize(app = T.unsafe(nil), **kwargs); end

  # Returns the value of attribute app.
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  def app=(_arg0); end

  # Rack call interface.
  def call(env); end

  def call!(env); end

  # Returns the value of attribute env.
  def env; end

  # Sets the attribute env
  #
  # @param value the value to set the attribute env to.
  def env=(_arg0); end

  # Forward the request to the downstream app -- middleware only.
  def forward; end

  # Exit the current block, halts any further processing
  # of the request, and returns the specified response.
  def halt(*response); end

  def options; end

  # Returns the value of attribute params.
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  def params=(_arg0); end

  # Pass control to the next matching route.
  # If there are no more matching routes, Sinatra will
  # return a 404 response.
  def pass(&block); end

  # Returns the value of attribute request.
  def request; end

  # Sets the attribute request
  #
  # @param value the value to set the attribute request to.
  def request=(_arg0); end

  # Returns the value of attribute response.
  def response; end

  # Sets the attribute response
  #
  # @param value the value to set the attribute response to.
  def response=(_arg0); end

  # Access settings defined with Base.set.
  def settings; end

  # Returns the value of attribute template_cache.
  def template_cache; end

  private

  # Dispatch a request with error handling.
  def dispatch!; end

  def dump_errors!(boom); end

  # Find an custom error block for the key(s) specified.
  def error_block!(key, *block_params); end

  # Run filters defined on the class and all superclasses.
  # Accepts an optional block to call after each filter is applied.
  def filter!(type, base = T.unsafe(nil), &block); end

  def force_encoding(*args); end

  # Error handling during requests.
  def handle_exception!(boom); end

  # Run the block with 'throw :halt' support and apply result to the response.
  def invoke; end

  # If the current request matches pattern and conditions, fill params
  # with keys and call the given block.
  # Revert params afterwards.
  #
  # Returns pass block.
  def process_route(pattern, conditions, block = T.unsafe(nil), values = T.unsafe(nil)); end

  # Run routes defined on the class and all superclasses.
  def route!(base = T.unsafe(nil), pass_block = T.unsafe(nil)); end

  # Run a route block and throw :halt with the result.
  def route_eval; end

  # No matching route was found or all routes passed. The default
  # implementation is to forward the request downstream when running
  # as middleware (@app is non-nil); when no downstream app is set, raise
  # a NotFound exception. Subclasses can override this method to perform
  # custom route miss logic.
  def route_missing; end

  # Attempt to serve static files from public directory. Throws :halt when
  # a matching file is found, returns nil otherwise.
  def static!(options = T.unsafe(nil)); end

  class << self
    def absolute_redirects; end
    def absolute_redirects=(val); end
    def absolute_redirects?; end
    def add_charset; end
    def add_charset=(val); end
    def add_charset?; end

    # add a filter
    def add_filter(type, path = T.unsafe(nil), **options, &block); end

    # Define an after filter; runs after all requests within the same
    # context as route handlers and may access/modify the request and
    # response.
    def after(path = T.unsafe(nil), **options, &block); end

    def app_file; end
    def app_file=(val); end
    def app_file?; end

    # Define a before filter; runs before all requests within the same
    # context as route handlers and may access/modify the request and
    # response.
    def before(path = T.unsafe(nil), **options, &block); end

    def bind; end
    def bind=(val); end
    def bind?; end

    # Creates a Rack::Builder instance with all the middleware set up and
    # the given +app+ as end point.
    def build(app); end

    def call(env); end

    # Like Kernel#caller but excluding certain magic entries and without
    # line / method information; the resulting array contains filenames only.
    def caller_files; end

    # Add a route condition. The route is considered non-matching when the
    # block returns false.
    def condition(name = T.unsafe(nil), &block); end

    # Set configuration options for Sinatra and/or the app.
    # Allows scoping of settings for certain environments.
    #
    # @yield [_self]
    # @yieldparam _self [Sinatra::Base] the object that the method was called on
    def configure(*envs); end

    def default_content_type; end
    def default_content_type=(val); end
    def default_content_type?; end
    def default_encoding; end
    def default_encoding=(val); end
    def default_encoding?; end
    def delete(path, opts = T.unsafe(nil), &bk); end

    # @return [Boolean]
    def development?; end

    # Same as calling `set :option, false` for each of the given options.
    def disable(*opts); end

    def dump_errors; end
    def dump_errors=(val); end
    def dump_errors?; end
    def empty_path_info; end
    def empty_path_info=(val); end
    def empty_path_info?; end

    # Same as calling `set :option, true` for each of the given options.
    def enable(*opts); end

    def environment; end
    def environment=(val); end
    def environment?; end

    # Define a custom error handler. Optionally takes either an Exception
    # class, or an HTTP status code to specify which errors should be
    # handled.
    def error(*codes, &block); end

    # Returns the value of attribute errors.
    def errors; end

    # Extension modules registered on this class and all superclasses.
    def extensions; end

    # Returns the value of attribute filters.
    def filters; end

    # Force data to specified encoding. It defaults to settings.default_encoding
    # which is UTF-8 by default
    def force_encoding(data, encoding = T.unsafe(nil)); end

    # Defining a `GET` handler also automatically defines
    # a `HEAD` handler.
    def get(path, opts = T.unsafe(nil), &block); end

    def handler_name; end
    def handler_name=(val); end
    def handler_name?; end
    def head(path, opts = T.unsafe(nil), &bk); end

    # Makes the methods defined in the block and in the Modules given
    # in `extensions` available to the handlers and templates
    def helpers(*extensions, &block); end

    # Load embedded templates from the file; uses the caller's __FILE__
    # when no file is specified.
    def inline_templates=(file = T.unsafe(nil)); end

    # Define the layout template. The block must return the template source.
    def layout(name = T.unsafe(nil), &block); end

    def link(path, opts = T.unsafe(nil), &bk); end
    def lock; end
    def lock=(val); end
    def lock?; end
    def logging; end
    def logging=(val); end
    def logging?; end
    def method_override; end
    def method_override=(val); end
    def method_override?; end
    def methodoverride=(val); end
    def methodoverride?; end

    # Middleware used in this class and all superclasses.
    def middleware; end

    # Lookup or register a mime type in Rack's mime registry.
    def mime_type(type, value = T.unsafe(nil)); end

    # provides all mime types matching type, including deprecated types:
    #   mime_types :html # => ['text/html']
    #   mime_types :js   # => ['application/javascript', 'text/javascript']
    def mime_types(type); end

    def mustermann_opts; end
    def mustermann_opts=(val); end
    def mustermann_opts?; end

    # Create a new instance of the class fronted by its middleware
    # pipeline. The object is guaranteed to respond to #call but may not be
    # an instance of the class new was called on.
    def new(*args, **_arg1, &bk); end

    def new!(*_arg0); end

    # Sugar for `error(404) { ... }`
    def not_found(&block); end

    def options(path, opts = T.unsafe(nil), &bk); end
    def patch(path, opts = T.unsafe(nil), &bk); end
    def port; end
    def port=(val); end
    def port?; end
    def post(path, opts = T.unsafe(nil), &bk); end
    def prefixed_redirects; end
    def prefixed_redirects=(val); end
    def prefixed_redirects?; end

    # @return [Boolean]
    def production?; end

    def protection; end
    def protection=(val); end
    def protection?; end

    # The prototype instance used to process requests.
    def prototype; end

    def public=(value); end
    def public_dir; end
    def public_dir=(value); end
    def public_folder; end
    def public_folder=(val); end
    def public_folder?; end
    def put(path, opts = T.unsafe(nil), &bk); end
    def quiet; end
    def quiet=(val); end
    def quiet?; end

    # Stop the self-hosted server if running.
    def quit!; end

    def raise_errors; end
    def raise_errors=(val); end
    def raise_errors?; end

    # Register an extension. Alternatively take a block from which an
    # extension will be created and registered on the fly.
    def register(*extensions, &block); end

    def reload_templates; end
    def reload_templates=(val); end
    def reload_templates?; end

    # Removes all routes, filters, middleware and extension hooks from the
    # current class (not routes/filters/... defined by its superclass).
    def reset!; end

    def root; end
    def root=(val); end
    def root?; end

    # Returns the value of attribute routes.
    def routes; end

    def run; end

    # Run the Sinatra app as a self-hosted server using
    # Puma, Mongrel, or WEBrick (in that order). If given a block, will call
    # with the constructed handler once we have taken the stage.
    def run!(options = T.unsafe(nil), &block); end

    def run=(val); end
    def run?; end

    # Check whether the self-hosted server is running or not.
    #
    # @return [Boolean]
    def running?; end

    def running_server; end
    def running_server=(val); end
    def running_server?; end
    def server; end
    def server=(val); end
    def server?; end
    def session_secret; end
    def session_secret=(val); end
    def session_secret?; end
    def session_store; end
    def session_store=(val); end
    def session_store?; end
    def sessions; end
    def sessions=(val); end
    def sessions?; end

    # Sets an option to the given value.  If the value is a proc,
    # the proc will be called every time the option is accessed.
    #
    # @raise [ArgumentError]
    def set(option, value = T.unsafe(nil), ignore_setter = T.unsafe(nil), &block); end

    # Access settings defined with Base.set.
    def settings; end

    def show_exceptions; end
    def show_exceptions=(val); end
    def show_exceptions?; end

    # Run the Sinatra app as a self-hosted server using
    # Puma, Mongrel, or WEBrick (in that order). If given a block, will call
    # with the constructed handler once we have taken the stage.
    def start!(options = T.unsafe(nil), &block); end

    def static; end
    def static=(val); end
    def static?; end
    def static_cache_control; end
    def static_cache_control=(val); end
    def static_cache_control?; end

    # Stop the self-hosted server if running.
    def stop!; end

    def strict_paths; end
    def strict_paths=(val); end
    def strict_paths?; end

    # Define a named template. The block must return the template source.
    def template(name, &block); end

    # Returns the value of attribute templates.
    def templates; end

    # @return [Boolean]
    def test?; end

    def threaded; end
    def threaded=(val); end
    def threaded?; end
    def traps; end
    def traps=(val); end
    def traps?; end
    def unlink(path, opts = T.unsafe(nil), &bk); end

    # Use the specified Rack middleware
    def use(middleware, *args, **_arg2, &block); end

    def use_code; end
    def use_code=(val); end
    def use_code?; end
    def views; end
    def views=(val); end
    def views?; end
    def x_cascade; end
    def x_cascade=(val); end
    def x_cascade?; end

    private

    # Condition for matching user agent. Parameter should be Regexp.
    # Will set params[:agent].
    def agent(pattern); end

    # Like Kernel#caller but excluding certain magic entries
    def cleaned_caller(keep = T.unsafe(nil)); end

    def compile(path, route_mustermann_opts = T.unsafe(nil)); end
    def compile!(verb, path, block, **options); end

    # Dynamically defines a method on settings.
    def define_singleton(name, content = T.unsafe(nil)); end

    def generate_method(method_name, &block); end

    # Condition for matching host name. Parameter might be String or Regexp.
    def host_name(pattern); end

    # @private
    def inherited(subclass); end

    def invoke_hook(name, *args); end

    # Condition for matching mimetypes. Accepts file extensions.
    def provides(*types); end

    def route(verb, path, options = T.unsafe(nil), &block); end
    def setup_common_logger(builder); end
    def setup_custom_logger(builder); end
    def setup_default_middleware(builder); end
    def setup_logging(builder); end
    def setup_middleware(builder); end
    def setup_null_logger(builder); end
    def setup_protection(builder); end
    def setup_sessions(builder); end
    def setup_traps; end

    # Starts the server by running the Rack Handler.
    def start_server(handler, server_settings, handler_name); end

    # @return [Boolean]
    def suppress_messages?; end

    def synchronize(&block); end

    # Condition for matching user agent. Parameter should be Regexp.
    # Will set params[:agent].
    def user_agent(pattern); end

    # used for deprecation warnings
    def warn(message); end
  end
end

Sinatra::Base::URI_INSTANCE = T.let(T.unsafe(nil), URI::RFC2396_Parser)

# Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing,
# if another CommonLogger is already in the middleware chain.
class Sinatra::CommonLogger < ::Rack::CommonLogger
  def call(env); end
end

# Sinatra delegation mixin. Mixing this module into an object causes all
# methods to be delegated to the Sinatra::Application class. Used primarily
# at the top-level.
module Sinatra::Delegator
  private

  def after(*args, **_arg1, &block); end
  def before(*args, **_arg1, &block); end
  def configure(*args, **_arg1, &block); end
  def delete(*args, **_arg1, &block); end
  def development?(*args, **_arg1, &block); end
  def disable(*args, **_arg1, &block); end
  def enable(*args, **_arg1, &block); end
  def error(*args, **_arg1, &block); end
  def get(*args, **_arg1, &block); end
  def head(*args, **_arg1, &block); end
  def helpers(*args, **_arg1, &block); end
  def layout(*args, **_arg1, &block); end
  def link(*args, **_arg1, &block); end
  def mime_type(*args, **_arg1, &block); end
  def not_found(*args, **_arg1, &block); end
  def options(*args, **_arg1, &block); end
  def patch(*args, **_arg1, &block); end
  def post(*args, **_arg1, &block); end
  def production?(*args, **_arg1, &block); end
  def put(*args, **_arg1, &block); end
  def register(*args, **_arg1, &block); end
  def set(*args, **_arg1, &block); end
  def settings(*args, **_arg1, &block); end
  def template(*args, **_arg1, &block); end
  def test?(*args, **_arg1, &block); end
  def unlink(*args, **_arg1, &block); end
  def use(*args, **_arg1, &block); end

  class << self
    def delegate(*methods); end

    # Returns the value of attribute target.
    def target; end

    # Sets the attribute target
    #
    # @param value the value to set the attribute target to.
    def target=(_arg0); end
  end
end

class Sinatra::Error < ::StandardError; end

# Some Rack handlers (Rainbows!) implement an extended body object protocol, however,
# some middleware (namely Rack::Lint) will break it by not mirroring the methods in question.
# This middleware will detect an extended body object and will make sure it reaches the
# handler directly. We do this here, so our middleware and middleware set up by the app will
# still be able to run.
class Sinatra::ExtendedRack < ::Struct
  def call(env); end

  private

  # @raise [NotImplementedError]
  def after_response(&block); end

  # @return [Boolean]
  def async?(status, headers, body); end

  def setup_close(env, status, headers, body); end
end

# Methods available to routes, before/after filters, and views.
module Sinatra::Helpers
  # Set the Content-Disposition to "attachment" with the specified filename,
  # instructing the user agents to prompt to save.
  def attachment(filename = T.unsafe(nil), disposition = T.unsafe(nil)); end

  # Sugar for redirect (example:  redirect back)
  def back; end

  # whether or not the status is set to 400
  #
  # @return [Boolean]
  def bad_request?; end

  # Set or retrieve the response body. When a block is given,
  # evaluation is deferred until the body is read with #each.
  def body(value = T.unsafe(nil), &block); end

  # Specify response freshness policy for HTTP caches (Cache-Control header).
  # Any number of non-value directives (:public, :private, :no_cache,
  # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with
  # a Hash of value directives (:max_age, :s_maxage).
  #
  #   cache_control :public, :must_revalidate, :max_age => 60
  #   => Cache-Control: public, must-revalidate, max-age=60
  #
  # See RFC 2616 / 14.9 for more on standard cache control directives:
  # http://tools.ietf.org/html/rfc2616#section-14.9.1
  def cache_control(*values); end

  # whether or not the status is set to 4xx
  #
  # @return [Boolean]
  def client_error?; end

  # Set the Content-Type of the response body given a media type or file
  # extension.
  def content_type(type = T.unsafe(nil), params = T.unsafe(nil)); end

  # Halt processing and return the error status provided.
  def error(code, body = T.unsafe(nil)); end

  # Set the response entity tag (HTTP 'ETag' header) and halt if conditional
  # GET matches. The +value+ argument is an identifier that uniquely
  # identifies the current version of the resource. The +kind+ argument
  # indicates whether the etag should be used as a :strong (default) or :weak
  # cache validator.
  #
  # When the current request includes an 'If-None-Match' header with a
  # matching etag, execution is immediately halted. If the request method is
  # GET or HEAD, a '304 Not Modified' response is sent.
  def etag(value, options = T.unsafe(nil)); end

  # Set the Expires header and Cache-Control/max-age directive. Amount
  # can be an integer number of seconds in the future or a Time object
  # indicating when the response should be considered "stale". The remaining
  # "values" arguments are passed to the #cache_control helper:
  #
  #   expires 500, :public, :must_revalidate
  #   => Cache-Control: public, must-revalidate, max-age=500
  #   => Expires: Mon, 08 Jun 2009 08:50:17 GMT
  def expires(amount, *values); end

  # Set multiple response headers with Hash.
  def headers(hash = T.unsafe(nil)); end

  # whether or not the status is set to 1xx
  #
  # @return [Boolean]
  def informational?; end

  # Set the last modified time of the resource (HTTP 'Last-Modified' header)
  # and halt if conditional GET matches. The +time+ argument is a Time,
  # DateTime, or other object that responds to +to_time+.
  #
  # When the current request includes an 'If-Modified-Since' header that is
  # equal or later than the time specified, execution is immediately halted
  # with a '304 Not Modified' response.
  def last_modified(time); end

  # Access shared logger object.
  def logger; end

  # Look up a media type by file extension in Rack's mime registry.
  def mime_type(type); end

  # Halt processing and return a 404 Not Found.
  def not_found(body = T.unsafe(nil)); end

  # whether or not the status is set to 404
  #
  # @return [Boolean]
  def not_found?; end

  # Halt processing and redirect to the URI provided.
  def redirect(uri, *args); end

  # whether or not the status is set to 3xx
  #
  # @return [Boolean]
  def redirect?; end

  # Use the contents of the file at +path+ as the response body.
  def send_file(path, opts = T.unsafe(nil)); end

  # whether or not the status is set to 5xx
  #
  # @return [Boolean]
  def server_error?; end

  # Access the underlying Rack session.
  def session; end

  # Set or retrieve the response status code.
  def status(value = T.unsafe(nil)); end

  # Allows to start sending data to the client even though later parts of
  # the response body have not yet been generated.
  #
  # The close parameter specifies whether Stream#close should be called
  # after the block has been executed. This is only relevant for evented
  # servers like Rainbows.
  def stream(keep_open = T.unsafe(nil)); end

  # whether or not the status is set to 2xx
  #
  # @return [Boolean]
  def success?; end

  # Generates a Time object from the given value.
  # Used by #expires and #last_modified.
  def time_for(value); end

  # Generates the absolute URI for a given path in the app.
  # Takes Rack routers and reverse proxies into account.
  def to(addr = T.unsafe(nil), absolute = T.unsafe(nil), add_script_name = T.unsafe(nil)); end

  # Generates the absolute URI for a given path in the app.
  # Takes Rack routers and reverse proxies into account.
  def uri(addr = T.unsafe(nil), absolute = T.unsafe(nil), add_script_name = T.unsafe(nil)); end

  # Generates the absolute URI for a given path in the app.
  # Takes Rack routers and reverse proxies into account.
  def url(addr = T.unsafe(nil), absolute = T.unsafe(nil), add_script_name = T.unsafe(nil)); end

  private

  # Helper method checking if a ETag value list includes the current ETag.
  #
  # @return [Boolean]
  def etag_matches?(list, new_resource = T.unsafe(nil)); end

  def with_params(temp_params); end
end

Sinatra::Helpers::ETAG_KINDS = T.let(T.unsafe(nil), Array)

# Class of the response body in case you use #stream.
#
# Three things really matter: The front and back block (back being the
# block generating content, front the one sending it to the client) and
# the scheduler, integrating with whatever concurrency feature the Rack
# handler is using.
#
# Scheduler has to respond to defer and schedule.
class Sinatra::Helpers::Stream
  # @return [Stream] a new instance of Stream
  def initialize(scheduler = T.unsafe(nil), keep_open = T.unsafe(nil), &back); end

  def <<(data); end
  def callback(&block); end
  def close; end

  # @return [Boolean]
  def closed?; end

  def each(&front); end
  def errback(&block); end

  class << self
    def defer(*_arg0); end
    def schedule(*_arg0); end
  end
end

# A poor man's ActiveSupport::HashWithIndifferentAccess, with all the Rails-y
# stuff removed.
#
# Implements a hash where keys <tt>:foo</tt> and <tt>"foo"</tt> are
# considered to be the same.
#
#   rgb = Sinatra::IndifferentHash.new
#
#   rgb[:black]    =  '#000000' # symbol assignment
#   rgb[:black]  # => '#000000' # symbol retrieval
#   rgb['black'] # => '#000000' # string retrieval
#
#   rgb['white']   =  '#FFFFFF' # string assignment
#   rgb[:white]  # => '#FFFFFF' # symbol retrieval
#   rgb['white'] # => '#FFFFFF' # string retrieval
#
# Internally, symbols are mapped to strings when used as keys in the entire
# writing interface (calling e.g. <tt>[]=</tt>, <tt>merge</tt>). This mapping
# belongs to the public interface. For example, given:
#
#   hash = Sinatra::IndifferentHash.new(:a=>1)
#
# You are guaranteed that the key is returned as a string:
#
#   hash.keys # => ["a"]
#
# Technically other types of keys are accepted:
#
#   hash = Sinatra::IndifferentHash.new(:a=>1)
#   hash[0] = 0
#   hash # => { "a"=>1, 0=>0 }
#
# But this class is intended for use cases where strings or symbols are the
# expected keys and it is convenient to understand both as the same. For
# example the +params+ hash in Sinatra.
class Sinatra::IndifferentHash < ::Hash
  # @return [IndifferentHash] a new instance of IndifferentHash
  def initialize(*args); end

  def [](key); end
  def []=(key, value); end
  def assoc(key); end
  def compact; end
  def default(*args); end
  def default=(value); end
  def delete(key); end
  def dig(key, *other_keys); end
  def fetch(key, *args); end
  def fetch_values(*keys); end

  # @return [Boolean]
  def has_key?(key); end

  # @return [Boolean]
  def has_value?(value); end

  # @return [Boolean]
  def include?(key); end

  def key(value); end

  # @return [Boolean]
  def key?(key); end

  # @return [Boolean]
  def member?(key); end

  def merge(*other_hashes, &block); end
  def merge!(*other_hashes); end
  def rassoc(value); end
  def reject(*args, &block); end
  def replace(other_hash); end
  def select(*args, &block); end
  def slice(*keys); end
  def store(key, value); end
  def transform_keys(&block); end
  def transform_keys!; end
  def transform_values(&block); end
  def transform_values!; end
  def update(*other_hashes); end

  # @return [Boolean]
  def value?(value); end

  def values_at(*keys); end

  private

  def convert_key(key); end
  def convert_value(value); end

  class << self
    def [](*args); end
  end
end

class Sinatra::NotFound < ::Sinatra::Error
  def http_status; end
end

# The request object. See Rack::Request for more info:
# http://rubydoc.info/github/rack/rack/master/Rack/Request
class Sinatra::Request < ::Rack::Request
  # Returns an array of acceptable media types for the response
  def accept; end

  # @return [Boolean]
  def accept?(type); end

  # @return [Boolean]
  def forwarded?; end

  # @return [Boolean]
  def idempotent?; end

  # @return [Boolean]
  def link?; end

  def params; end
  def preferred_type(*types); end

  # @return [Boolean]
  def safe?; end

  def secure?; end

  # @return [Boolean]
  def unlink?; end
end

class Sinatra::Request::AcceptEntry
  # @return [AcceptEntry] a new instance of AcceptEntry
  def initialize(entry); end

  def <=>(other); end

  # Returns the value of attribute entry.
  def entry; end

  def method_missing(*args, &block); end

  # Returns the value of attribute params.
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  def params=(_arg0); end

  def priority; end

  # @return [Boolean]
  def respond_to?(*args); end

  def to_s(full = T.unsafe(nil)); end
  def to_str; end
end

Sinatra::Request::HEADER_PARAM = T.let(T.unsafe(nil), Regexp)
Sinatra::Request::HEADER_VALUE_WITH_PARAMS = T.let(T.unsafe(nil), Regexp)

class Sinatra::Request::MimeTypeEntry
  # @return [MimeTypeEntry] a new instance of MimeTypeEntry
  def initialize(entry); end

  # @return [Boolean]
  def accepts?(entry); end

  # @return [Boolean]
  def matches_params?(params); end

  # Returns the value of attribute params.
  def params; end

  def to_str; end
end

# The response object. See Rack::Response and Rack::Response::Helpers for
# more info:
# http://rubydoc.info/github/rack/rack/master/Rack/Response
# http://rubydoc.info/github/rack/rack/master/Rack/Response/Helpers
class Sinatra::Response < ::Rack::Response
  def body=(value); end
  def each; end
  def finish; end

  private

  # @return [Boolean]
  def calculate_content_length?; end

  # @return [Boolean]
  def drop_body?; end

  # @return [Boolean]
  def drop_content_info?; end
end

Sinatra::Response::DROP_BODY_RESPONSES = T.let(T.unsafe(nil), Array)

# Sinatra::ShowExceptions catches all exceptions raised from the app it
# wraps. It shows a useful backtrace with the sourcefile and clickable
# context, the whole Rack environment and the request data.
#
# Be careful when you use this on public-facing sites as it could reveal
# information helpful to attackers.
class Sinatra::ShowExceptions < ::Rack::ShowExceptions
  # @return [ShowExceptions] a new instance of ShowExceptions
  def initialize(app); end

  def call(env); end
  def template; end

  private

  # @return [Boolean]
  def bad_request?(e); end

  def frame_class(frame); end

  # @return [Boolean]
  def prefers_plain_text?(env); end
end

Sinatra::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), ERB)

# Template rendering methods. Each method takes the name of a template
# to render as a Symbol and returns a String with the rendered output,
# as well as an optional hash with additional options.
#
# `template` is either the name or path of the template as symbol
# (Use `:'subdir/myview'` for views in subdirectories), or a string
# that will be rendered.
#
# Possible options are:
#   :content_type   The content type to use, same arguments as content_type.
#   :layout         If set to something falsy, no layout is rendered, otherwise
#                   the specified layout is used
#   :layout_engine  Engine to use for rendering the layout.
#   :locals         A hash with local variables that should be available
#                   in the template
#   :scope          If set, template is evaluate with the binding of the given
#                   object rather than the application instance.
#   :views          Views directory to use.
module Sinatra::Templates
  def initialize; end

  def asciidoc(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end
  def builder(template = T.unsafe(nil), options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
  def coffee(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end
  def creole(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end
  def erb(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # Calls the given block for every possible template file in views,
  # named name.ext, where ext is registered on engine.
  #
  # @yield [::File.join(views, "#{name}.#{@preferred_extension}")]
  def find_template(views, name, engine); end

  def haml(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
  def liquid(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
  def markaby(template = T.unsafe(nil), options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
  def markdown(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end
  def mediawiki(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end
  def nokogiri(template = T.unsafe(nil), options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
  def rabl(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end
  def radius(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end
  def rdoc(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end
  def slim(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
  def wlang(template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
  def yajl(template, options = T.unsafe(nil), locals = T.unsafe(nil)); end

  private

  def compile_block_template(template, options, &body); end
  def compile_template(engine, data, options, views); end
  def render(engine, data, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end

  # logic shared between builder and nokogiri
  def render_ruby(engine, template, options = T.unsafe(nil), locals = T.unsafe(nil), &block); end
end

module Sinatra::Templates::ContentTyped
  # Returns the value of attribute content_type.
  def content_type; end

  # Sets the attribute content_type
  #
  # @param value the value to set the attribute content_type to.
  def content_type=(_arg0); end
end

Sinatra::VERSION = T.let(T.unsafe(nil), String)

class Sinatra::Wrapper
  # @return [Wrapper] a new instance of Wrapper
  def initialize(stack, instance); end

  def call(env); end
  def helpers; end
  def inspect; end
  def settings; end
end
