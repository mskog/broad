# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http` gem.
# Please instead update this file by running `bin/tapioca gem http`.

# HTTP should be easy
module HTTP
  extend ::HTTP::Chainable

  class << self
    # HTTP[:accept => 'text/html'].get(...)
    def [](headers); end
  end
end

module HTTP::Chainable
  # Accept the given MIME type(s)
  #
  # @param type
  def accept(type); end

  # Make a request with the given Authorization header
  #
  # @param value [#to_s] Authorization header value
  def auth(value); end

  # Make a request with the given Basic authorization header
  #
  # @option opts
  # @option opts
  # @param opts [#fetch]
  # @see http://tools.ietf.org/html/rfc2617
  def basic_auth(opts); end

  # Prepare an HTTP request with the given verb
  def build_request(*args); end

  # Convert to a transparent TCP/IP tunnel
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def connect(uri, options = T.unsafe(nil)); end

  # Make a request with the given cookies
  def cookies(cookies); end

  # Get options for HTTP
  #
  # @return [HTTP::Options]
  def default_options; end

  # Set options for HTTP
  #
  # @param opts
  # @return [HTTP::Options]
  def default_options=(opts); end

  # Delete a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def delete(uri, options = T.unsafe(nil)); end

  # Force a specific encoding for response body
  def encoding(encoding); end

  # Make client follow redirects.
  #
  # @param options
  # @return [HTTP::Client]
  # @see Redirector#initialize
  def follow(options = T.unsafe(nil)); end

  # Get a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def get(uri, options = T.unsafe(nil)); end

  # Request a get sans response body
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def head(uri, options = T.unsafe(nil)); end

  # Make a request with the given headers
  #
  # @param headers
  def headers(headers); end

  # Set TCP_NODELAY on the socket
  def nodelay; end

  # Return the methods supported on the given URI
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def options(uri, options = T.unsafe(nil)); end

  # Apply partial modifications to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def patch(uri, options = T.unsafe(nil)); end

  # @overload persistent
  # @overload persistent
  def persistent(host, timeout: T.unsafe(nil)); end

  # Post to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def post(uri, options = T.unsafe(nil)); end

  # Put to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def put(uri, options = T.unsafe(nil)); end

  # Make an HTTP request with the given verb
  def request(*args); end

  # Make a request through an HTTP proxy
  #
  # @param proxy [Array]
  # @raise [Request::Error] if HTTP proxy is invalid
  def through(*proxy); end

  # @overload timeout
  # @overload timeout
  def timeout(options); end

  # Echo the request back to the client
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  def trace(uri, options = T.unsafe(nil)); end

  # Turn on given features. Available features are:
  # * auto_inflate
  # * auto_deflate
  # * instrumentation
  # * logging
  # * normalize_uri
  #
  # @param features
  def use(*features); end

  # Make a request through an HTTP proxy
  #
  # @param proxy [Array]
  # @raise [Request::Error] if HTTP proxy is invalid
  def via(*proxy); end

  private

  def branch(options); end
end

# Clients make requests and receive responses
class HTTP::Client
  include ::HTTP::Chainable
  extend ::Forwardable

  # @return [Client] a new instance of Client
  def initialize(default_options = T.unsafe(nil)); end

  def __perform__(req, options); end

  # Prepare an HTTP request
  def build_request(verb, uri, opts = T.unsafe(nil)); end

  def close; end

  # Perform a single (no follow) HTTP request
  def perform(request, options); end

  # @return [Boolean] whenever client is persistent
  # @see Options#persistent?
  def persistent?(*args, **_arg1, &block); end

  # Make an HTTP request
  def request(verb, uri, opts = T.unsafe(nil)); end

  def webmock_enabled?; end

  private

  def build_response(req, options); end
  def make_form_data(form); end

  # Create the request body object to send
  def make_request_body(opts, headers); end

  # Creates request headers with cookies (if any) merged in
  def make_request_headers(opts); end

  # Merges query params if needed
  #
  # @param uri [#to_s]
  # @return [URI]
  def make_request_uri(uri, opts); end

  # Verify our request isn't going to be made against another URI
  def verify_connection!(uri); end

  def wrap_request(req, opts); end
end

HTTP::Client::HTTP_OR_HTTPS_RE = T.let(T.unsafe(nil), Regexp)

# A connection to the HTTP server
class HTTP::Connection
  extend ::Forwardable

  # @param req [HTTP::Request]
  # @param options [HTTP::Options]
  # @raise [HTTP::ConnectionError] when failed to connect
  # @return [Connection] a new instance of Connection
  def initialize(req, options); end

  # Close the connection
  #
  # @return [void]
  def close; end

  # Whether our connection has expired
  #
  # @return [Boolean]
  def expired?; end

  # @return [Boolean] whenever proxy connect failed
  def failed_proxy_connect?; end

  # Callback for when we've reached the end of a response
  #
  # @return [void]
  def finish_response; end

  def headers(*args, **_arg1, &block); end
  def http_version(*args, **_arg1, &block); end

  # Whether we're keeping the conn alive
  #
  # @return [Boolean]
  def keep_alive?; end

  # Returned after HTTP CONNECT (via proxy)
  def proxy_response_headers; end

  # Reads data from socket up until headers are loaded
  #
  # @return [void]
  def read_headers!; end

  # Read a chunk of the body
  #
  # @return [String] data chunk
  # @return [nil] when no more data left
  def readpartial(size = T.unsafe(nil)); end

  # Send a request to the server
  #
  # @param req [Request] Request to send to the server
  # @return [nil]
  def send_request(req); end

  def status_code(*args, **_arg1, &block); end

  private

  # Feeds some more data into parser
  #
  # @return [void]
  def read_more(size); end

  # Resets expiration of persistent connection.
  #
  # @return [void]
  def reset_timer; end

  # Open tunnel through proxy
  def send_proxy_connect_request(req); end

  # Store whether the connection should be kept alive.
  # Once we reset the parser, we lose all of this state.
  #
  # @return [void]
  def set_keep_alive; end

  # Sets up SSL context and starts TLS if needed.
  #
  # @param req [HTTP::Request]
  # @param options [HTTP::Options]
  # @return [void]
  def start_tls(req, options); end
end

# Attempt to read this much data
HTTP::Connection::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

HTTP::Connection::CLOSE = T.let(T.unsafe(nil), String)

# HTTP/1.0
HTTP::Connection::HTTP_1_0 = T.let(T.unsafe(nil), String)

# HTTP/1.1
HTTP::Connection::HTTP_1_1 = T.let(T.unsafe(nil), String)

# Allowed values for CONNECTION header
HTTP::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# Generic Connection error
class HTTP::ConnectionError < ::HTTP::Error; end

class HTTP::ContentType
  # @return [ContentType] a new instance of ContentType
  def initialize(mime_type = T.unsafe(nil), charset = T.unsafe(nil)); end

  # Returns the value of attribute charset.
  def charset; end

  # Sets the attribute charset
  #
  # @param value the value to set the attribute charset to.
  def charset=(_arg0); end

  # Returns the value of attribute mime_type.
  def mime_type; end

  # Sets the attribute mime_type
  #
  # @param value the value to set the attribute mime_type to.
  def mime_type=(_arg0); end

  class << self
    # Parse string and return ContentType struct
    def parse(str); end

    private

    def charset(str); end
    def mime_type(str); end
  end
end

HTTP::ContentType::CHARSET_RE = T.let(T.unsafe(nil), Regexp)
HTTP::ContentType::MIME_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# Generic error
class HTTP::Error < ::StandardError; end

class HTTP::Feature
  # @return [Feature] a new instance of Feature
  def initialize(opts = T.unsafe(nil)); end

  def on_error(request, error); end
  def wrap_request(request); end
  def wrap_response(response); end
end

module HTTP::Features; end

class HTTP::Features::AutoDeflate < ::HTTP::Feature
  # @raise [Error]
  # @return [AutoDeflate] a new instance of AutoDeflate
  def initialize(**_arg0); end

  def deflated_body(body); end

  # Returns the value of attribute method.
  def method; end

  def wrap_request(request); end
end

class HTTP::Features::AutoDeflate::CompressedBody < ::HTTP::Request::Body
  # @return [CompressedBody] a new instance of CompressedBody
  def initialize(uncompressed_body); end

  def each(&block); end
  def size; end

  private

  def compress_all!; end
  def compressed_each; end
end

class HTTP::Features::AutoDeflate::DeflatedBody < ::HTTP::Features::AutoDeflate::CompressedBody
  def compress; end
end

class HTTP::Features::AutoDeflate::GzippedBody < ::HTTP::Features::AutoDeflate::CompressedBody
  def compress(&block); end
end

class HTTP::Features::AutoDeflate::GzippedBody::BlockIO
  # @return [BlockIO] a new instance of BlockIO
  def initialize(block); end

  def write(data); end
end

class HTTP::Features::AutoInflate < ::HTTP::Feature
  def stream_for(connection); end
  def wrap_response(response); end

  private

  # @return [Boolean]
  def supported_encoding?(response); end
end

HTTP::Features::AutoInflate::SUPPORTED_ENCODING = T.let(T.unsafe(nil), Set)

# Instrument requests and responses. Expects an
# ActiveSupport::Notifications-compatible instrumenter. Defaults to use a
# namespace of 'http' which may be overridden with a `:namespace` param.
# Emits a single event like `"request.{namespace}"`, eg `"request.http"`.
# Be sure to specify the instrumenter when enabling the feature:
#
#    HTTP
#      .use(instrumentation: {instrumenter: ActiveSupport::Notifications.instrumenter})
#      .get("https://example.com/")
#
# Emits two events on every request:
#
#  * `start_request.http` before the request is made, so you can log the reqest being started
#  * `request.http` after the response is recieved, and contains `start`
#    and `finish` so the duration of the request can be calculated.
class HTTP::Features::Instrumentation < ::HTTP::Feature
  # @return [Instrumentation] a new instance of Instrumentation
  def initialize(instrumenter: T.unsafe(nil), namespace: T.unsafe(nil)); end

  # Returns the value of attribute instrumenter.
  def instrumenter; end

  # Returns the value of attribute name.
  def name; end

  def wrap_request(request); end
  def wrap_response(response); end
end

class HTTP::Features::Instrumentation::NullInstrumenter
  def finish(_name, _payload); end
  def instrument(name, payload = T.unsafe(nil)); end
  def start(_name, _payload); end
end

# Log requests and responses. Request verb and uri, and Response status are
# logged at `info`, and the headers and bodies of both are logged at
# `debug`. Be sure to specify the logger when enabling the feature:
#
#    HTTP.use(logging: {logger: Logger.new(STDOUT)}).get("https://example.com/")
class HTTP::Features::Logging < ::HTTP::Feature
  # @return [Logging] a new instance of Logging
  def initialize(logger: T.unsafe(nil)); end

  # Returns the value of attribute logger.
  def logger; end

  def wrap_request(request); end
  def wrap_response(response); end

  private

  def stringify_headers(headers); end
end

class HTTP::Features::Logging::NullLogger
  def debug(*_args); end
  def debug?; end
  def error(*_args); end
  def error?; end
  def fatal(*_args); end
  def fatal?; end
  def info(*_args); end
  def info?; end
  def warn(*_args); end
  def warn?; end
end

class HTTP::Features::NormalizeUri < ::HTTP::Feature
  # @return [NormalizeUri] a new instance of NormalizeUri
  def initialize(normalizer: T.unsafe(nil)); end

  # Returns the value of attribute normalizer.
  def normalizer; end
end

# Header value is of unexpected format (similar to Net::HTTPHeaderSyntaxError)
class HTTP::HeaderError < ::HTTP::Error; end

# HTTP Headers container.
class HTTP::Headers
  include ::Enumerable
  extend ::Forwardable

  # Class constructor.
  #
  # @return [Headers] a new instance of Headers
  def initialize; end

  # Compares headers to another Headers or Array of key/value pairs
  #
  # @return [Boolean]
  def ==(other); end

  # Smart version of {#get}.
  #
  # @return [nil] if header was not set
  # @return [String] if header has exactly one value
  # @return [Array<String>] if header has more than one value
  def [](name); end

  # Sets header.
  #
  # @return [void]
  def []=(name, value); end

  # Appends header.
  #
  # @param name [String, Symbol] header name. When specified as a string, the
  #   name is sent as-is. When specified as a symbol, the name is converted
  #   to a string of capitalized words separated by a dash. Word boundaries
  #   are determined by an underscore (`_`) or a dash (`-`).
  #   Ex: `:content_type` is sent as `"Content-Type"`, and `"auth_key"` (string)
  #   is sent as `"auth_key"`.
  # @param value [Array<#to_s>, #to_s] header value(s) to be appended
  # @return [void]
  def add(name, value); end

  # Removes header.
  #
  # @param name [#to_s] header name
  # @return [void]
  def delete(name); end

  # Calls the given block once for each key/value pair in headers container.
  #
  # @return [Enumerator] if no block given
  # @return [Headers] self-reference
  def each; end

  # Returns `true` if `self` has no key/value pairs
  #
  # @return [Boolean]
  def empty?(*args, **_arg1, &block); end

  # Returns list of header values if any.
  #
  # @return [Array<String>]
  def get(name); end

  # Compute a hash-code for this headers container.
  # Two containers with the same content will have the same hash code.
  #
  # @return [Fixnum]
  # @see http://www.ruby-doc.org/core/Object.html#method-i-hash
  def hash(*args, **_arg1, &block); end

  # Tells whenever header with given `name` is set or not.
  #
  # @return [Boolean]
  def include?(name); end

  # Returns human-readable representation of `self` instance.
  #
  # @return [String]
  def inspect; end

  # Returns list of header names.
  #
  # @return [Array<String>]
  def keys; end

  # Returns new instance with `other` headers merged in.
  #
  # @return [Headers]
  # @see #merge!
  def merge(other); end

  # Merges `other` headers into `self`.
  #
  # @return [void]
  # @see #merge
  def merge!(other); end

  # Sets header.
  #
  # @param name [String, Symbol] header name. When specified as a string, the
  #   name is sent as-is. When specified as a symbol, the name is converted
  #   to a string of capitalized words separated by a dash. Word boundaries
  #   are determined by an underscore (`_`) or a dash (`-`).
  #   Ex: `:content_type` is sent as `"Content-Type"`, and `"auth_key"` (string)
  #   is sent as `"auth_key"`.
  # @param value [Array<#to_s>, #to_s] header value(s) to be appended
  # @return [void]
  def set(name, value); end

  # Returns headers key/value pairs.
  #
  # @return [Array<[String, String]>]
  def to_a; end

  # Returns Rack-compatible headers Hash
  #
  # @return [Hash]
  def to_h; end

  # Returns Rack-compatible headers Hash
  #
  # @return [Hash]
  def to_hash; end

  private

  # Properly clones internal key/value storage.
  #
  # @api private
  def initialize_copy(orig); end

  # Transforms `name` to canonical HTTP header capitalization
  #
  # @param name [String]
  # @raise [HeaderError] if normalized name does not
  #   match {HEADER_NAME_RE}
  # @return [String] canonical HTTP header name
  def normalize_header(name); end

  # Ensures there is no new line character in the header value
  #
  # @param value [String]
  # @raise [HeaderError] if value includes new line character
  # @return [String] stringified header value
  def validate_value(value); end

  class << self
    # Coerces given `object` into Headers.
    #
    # @param object [#to_hash, #to_h, #to_a]
    # @raise [Error] if object can't be coerced
    # @return [Headers]
    def [](object); end

    # Coerces given `object` into Headers.
    #
    # @param object [#to_hash, #to_h, #to_a]
    # @raise [Error] if object can't be coerced
    # @return [Headers]
    def coerce(object); end
  end
end

# Content-Types that are acceptable for the response.
HTTP::Headers::ACCEPT = T.let(T.unsafe(nil), String)

# Content-codings that are acceptable in the response.
HTTP::Headers::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)

# The age the object has been in a proxy cache in seconds.
HTTP::Headers::AGE = T.let(T.unsafe(nil), String)

# Authentication credentials for HTTP authentication.
HTTP::Headers::AUTHORIZATION = T.let(T.unsafe(nil), String)

# Used to specify directives that must be obeyed by all caching mechanisms
# along the request-response chain.
HTTP::Headers::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# Matches HTTP header names when in "Canonical-Http-Format"
HTTP::Headers::CANONICAL_NAME_RE = T.let(T.unsafe(nil), Regexp)

# Matches valid header field name according to RFC.
#
# @see http://tools.ietf.org/html/rfc7230#section-3.2
HTTP::Headers::COMPLIANT_NAME_RE = T.let(T.unsafe(nil), Regexp)

# Control options for the current connection and list
# of hop-by-hop request fields.
HTTP::Headers::CONNECTION = T.let(T.unsafe(nil), String)

# Indicates what additional content codings have been applied to the
# entity-body.
HTTP::Headers::CONTENT_ENCODING = T.let(T.unsafe(nil), String)

# The length of the request body in octets (8-bit bytes).
HTTP::Headers::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# The MIME type of the body of the request
# (used with POST and PUT requests).
HTTP::Headers::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# An HTTP cookie previously sent by the server with Set-Cookie.
HTTP::Headers::COOKIE = T.let(T.unsafe(nil), String)

# The date and time that the message was sent (in "HTTP-date" format as
# defined by RFC 7231 Date/Time Formats).
HTTP::Headers::DATE = T.let(T.unsafe(nil), String)

# An identifier for a specific version of a resource,
# often a message digest.
HTTP::Headers::ETAG = T.let(T.unsafe(nil), String)

# Gives the date/time after which the response is considered stale (in
# "HTTP-date" format as defined by RFC 7231).
HTTP::Headers::EXPIRES = T.let(T.unsafe(nil), String)

# The domain name of the server (for virtual hosting), and the TCP port
# number on which the server is listening. The port number may be omitted
# if the port is the standard port for the service requested.
HTTP::Headers::HOST = T.let(T.unsafe(nil), String)

# Allows a 304 Not Modified to be returned if content is unchanged.
HTTP::Headers::IF_MODIFIED_SINCE = T.let(T.unsafe(nil), String)

# Allows a 304 Not Modified to be returned if content is unchanged.
HTTP::Headers::IF_NONE_MATCH = T.let(T.unsafe(nil), String)

# The last modified date for the requested object (in "HTTP-date" format as
# defined by RFC 7231).
HTTP::Headers::LAST_MODIFIED = T.let(T.unsafe(nil), String)

# Used in redirection, or when a new resource has been created.
HTTP::Headers::LOCATION = T.let(T.unsafe(nil), String)

# Provides shared behavior for {HTTP::Request} and {HTTP::Response}.
# Expects `@headers` to be an instance of {HTTP::Headers}.
#
# @example Usage
#
#   class MyHttpRequest
#   include HTTP::Headers::Mixin
#
#   def initialize
#   @headers = HTTP::Headers.new
#   end
#   end
module HTTP::Headers::Mixin
  extend ::Forwardable

  # Smart version of {#get}.
  #
  # @return [nil] if header was not set
  # @return [String] if header has exactly one value
  # @return [Array<String>] if header has more than one value
  def [](*args, **_arg1, &block); end

  # Sets header.
  #
  # @return [void]
  def []=(*args, **_arg1, &block); end

  # @return [HTTP::Headers]
  def headers; end
end

# Authorization credentials for connecting to a proxy.
HTTP::Headers::PROXY_AUTHORIZATION = T.let(T.unsafe(nil), String)

# An HTTP cookie.
HTTP::Headers::SET_COOKIE = T.let(T.unsafe(nil), String)

# The form of encoding used to safely transfer the entity to the user.
# Currently defined methods are: chunked, compress, deflate, gzip, identity.
HTTP::Headers::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# The user agent string of the user agent.
HTTP::Headers::USER_AGENT = T.let(T.unsafe(nil), String)

# Tells downstream proxies how to match future request headers to decide
# whether the cached response can be used rather than requesting a fresh
# one from the origin server.
HTTP::Headers::VARY = T.let(T.unsafe(nil), String)

# MIME type encode/decode adapters
module HTTP::MimeType
  class << self
    # Returns adapter associated with MIME type
    #
    # @param type [#to_s]
    # @raise [Error] if no adapter found
    # @return [Class]
    def [](type); end

    # Resolves type by shortcut if possible
    #
    # @param type [#to_s]
    # @return [String]
    def normalize(type); end

    # Associate MIME type with adapter
    #
    # @example
    #
    #   module JsonAdapter
    #   class << self
    #   def encode(obj)
    #   # encode logic here
    #   end
    #
    #   def decode(str)
    #   # decode logic here
    #   end
    #   end
    #   end
    #
    #   HTTP::MimeType.register_adapter 'application/json', MyJsonAdapter
    # @param type [#to_s]
    # @param adapter [#encode, #decode]
    # @return [void]
    def register_adapter(type, adapter); end

    # Register a shortcut for MIME type
    #
    # @example
    #
    #   HTTP::MimeType.register_alias 'application/json', :json
    # @param type [#to_s]
    # @param shortcut [#to_sym]
    # @return [void]
    def register_alias(type, shortcut); end

    private

    def adapters; end
    def aliases; end
  end
end

# Base encode/decode MIME type adapter
class HTTP::MimeType::Adapter
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def decode(*_arg0); end
  def encode(*_arg0); end

  class << self
    def decode(*args, **_arg1, &block); end
    def encode(*args, **_arg1, &block); end
  end
end

# JSON encode/decode MIME type adapter
class HTTP::MimeType::JSON < ::HTTP::MimeType::Adapter
  # Decodes JSON
  def decode(str); end

  # Encodes object to JSON
  def encode(obj); end
end

class HTTP::Options
  # @return [Options] a new instance of Options
  def initialize(options = T.unsafe(nil)); end

  def body; end
  def cookies; end

  # @yield [dupped]
  def dup; end

  def encoding; end
  def feature(name); end
  def features; end
  def features=(features); end
  def follow; end
  def follow=(value); end
  def form; end
  def headers; end
  def json; end
  def keep_alive_timeout; end
  def merge(other); end
  def nodelay; end
  def params; end
  def persistent; end
  def persistent=(value); end

  # @return [Boolean]
  def persistent?; end

  def proxy; end
  def response; end
  def socket_class; end
  def ssl; end
  def ssl_context; end
  def ssl_socket_class; end
  def timeout_class; end
  def timeout_options; end
  def to_hash; end
  def with_body(value); end
  def with_cookies(value); end
  def with_encoding(value); end
  def with_features(value); end
  def with_follow(value); end
  def with_form(value); end
  def with_headers(value); end
  def with_json(value); end
  def with_keep_alive_timeout(value); end
  def with_nodelay(value); end
  def with_params(value); end
  def with_persistent(value); end
  def with_proxy(value); end
  def with_response(value); end
  def with_socket_class(value); end
  def with_ssl(value); end
  def with_ssl_context(value); end
  def with_ssl_socket_class(value); end
  def with_timeout_class(value); end
  def with_timeout_options(value); end

  protected

  def []=(option, val); end
  def body=(_arg0); end
  def cookies=(_arg0); end
  def encoding=(_arg0); end
  def form=(_arg0); end
  def headers=(_arg0); end
  def json=(_arg0); end
  def keep_alive_timeout=(_arg0); end
  def nodelay=(_arg0); end
  def params=(_arg0); end
  def proxy=(_arg0); end
  def response=(_arg0); end
  def socket_class=(_arg0); end
  def ssl=(_arg0); end
  def ssl_context=(_arg0); end
  def ssl_socket_class=(_arg0); end
  def timeout_class=(_arg0); end
  def timeout_options=(_arg0); end

  private

  # @raise [Error]
  def argument_error!(message); end

  class << self
    # Returns the value of attribute available_features.
    def available_features; end

    # Returns the value of attribute default_socket_class.
    def default_socket_class; end

    # Sets the attribute default_socket_class
    #
    # @param value the value to set the attribute default_socket_class to.
    def default_socket_class=(_arg0); end

    # Returns the value of attribute default_ssl_socket_class.
    def default_ssl_socket_class; end

    # Sets the attribute default_ssl_socket_class
    #
    # @param value the value to set the attribute default_ssl_socket_class to.
    def default_ssl_socket_class=(_arg0); end

    # Returns the value of attribute default_timeout_class.
    def default_timeout_class; end

    # Sets the attribute default_timeout_class
    #
    # @param value the value to set the attribute default_timeout_class to.
    def default_timeout_class=(_arg0); end

    def defined_options; end
    def new(options = T.unsafe(nil)); end
    def register_feature(name, impl); end

    protected

    def def_option(name, reader_only: T.unsafe(nil), &interpreter); end
  end
end

class HTTP::Redirector
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [Redirector] a new instance of Redirector
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute max_hops.
  def max_hops; end

  # Follows redirects until non-redirect response found
  def perform(request, response); end

  # Returns the value of attribute strict.
  def strict; end

  private

  # Check if we got into an endless loop
  #
  # @return [Boolean]
  def endless_loop?; end

  # Redirect policy for follow
  #
  # @raise [StateError]
  # @return [Request]
  def redirect_to(uri); end

  # Check if we reached max amount of redirect hops
  #
  # @return [Boolean]
  def too_many_hops?; end
end

# Notifies that following redirects got into an endless loop
class HTTP::Redirector::EndlessRedirectError < ::HTTP::Redirector::TooManyRedirectsError; end

# HTTP status codes which indicate redirects
HTTP::Redirector::REDIRECT_CODES = T.let(T.unsafe(nil), Set)

# Verbs which will remain unchanged upon See Other response.
HTTP::Redirector::SEE_OTHER_ALLOWED_VERBS = T.let(T.unsafe(nil), Set)

# Codes which which should raise StateError in strict mode if original
# request was any of {UNSAFE_VERBS}
HTTP::Redirector::STRICT_SENSITIVE_CODES = T.let(T.unsafe(nil), Set)

# Notifies that we reached max allowed redirect hops
class HTTP::Redirector::TooManyRedirectsError < ::HTTP::ResponseError; end

# Insecure http verbs, which should trigger StateError in strict mode
# upon {STRICT_SENSITIVE_CODES}
HTTP::Redirector::UNSAFE_VERBS = T.let(T.unsafe(nil), Set)

class HTTP::Request
  include ::HTTP::Headers::Mixin
  extend ::Forwardable

  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @raise [UnsupportedMethodError]
  # @return [Request] a new instance of Request
  def initialize(opts); end

  # Returns the value of attribute body.
  def body; end

  # Setup tunnel through proxy for SSL request
  def connect_using_proxy(socket); end

  # Compute HTTP request header for direct or proxy request
  def headline; end

  # @return [String]
  def host(*args, **_arg1, &block); end

  # Compute and add the Proxy-Authorization header
  def include_proxy_authorization_header; end

  def include_proxy_headers; end

  # Human-readable representation of base request info.
  #
  # @example
  #
  #   req.inspect
  #   # => #<HTTP::Request/1.1 GET https://example.com>
  # @return [String]
  def inspect; end

  # Returns the value of attribute proxy.
  def proxy; end

  def proxy_authorization_header; end

  # Compute HTTP request header SSL proxy connection
  def proxy_connect_header; end

  # Headers to send with proxy connect request
  def proxy_connect_headers; end

  # Returns new Request with updated uri
  def redirect(uri, verb = T.unsafe(nil)); end

  # Scheme is normalized to be a lowercase symbol e.g. :http, :https
  def scheme; end

  # Host for tcp socket
  def socket_host; end

  # Port for tcp socket
  def socket_port; end

  # Stream the request to a socket
  def stream(socket); end

  # "Request URI" as per RFC 2616
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html
  def uri; end

  # Returns the value of attribute uri_normalizer.
  def uri_normalizer; end

  # Is this request using an authenticated proxy?
  #
  # @return [Boolean]
  def using_authenticated_proxy?; end

  # Is this request using a proxy?
  #
  # @return [Boolean]
  def using_proxy?; end

  # Method is given as a lowercase symbol e.g. :get, :post
  def verb; end

  # Returns the value of attribute version.
  def version; end

  def webmock_signature; end

  private

  # @return [String] Default host (with port if needed) header value.
  def default_host_header_value; end

  def port; end
  def prepare_body(body); end
  def prepare_headers(headers); end
end

class HTTP::Request::Body
  # @return [Body] a new instance of Body
  def initialize(source); end

  # Request bodies are equivalent when they have the same source.
  def ==(other); end

  # Yields chunks of content to be streamed to the request body.
  #
  # @yieldparam [String]
  def each(&block); end

  # Returns size which should be used for the "Content-Length" header.
  #
  # @return [Integer]
  def size; end

  # Returns the value of attribute source.
  def source; end

  private

  def rewind(io); end

  # @raise [RequestError]
  def validate_source_type!; end
end

# This class provides a "writable IO" wrapper around a proc object, with
# #write simply calling the proc, which we can pass in as the
# "destination IO" in IO.copy_stream.
class HTTP::Request::Body::ProcIO
  # @return [ProcIO] a new instance of ProcIO
  def initialize(block); end

  def write(data); end
end

HTTP::Request::METHODS = T.let(T.unsafe(nil), Array)

# Default ports of supported schemes
HTTP::Request::PORTS = T.let(T.unsafe(nil), Hash)

# Allowed schemes
HTTP::Request::SCHEMES = T.let(T.unsafe(nil), Array)

# Default User-Agent header value
HTTP::Request::USER_AGENT = T.let(T.unsafe(nil), String)

# The method given was not understood
class HTTP::Request::UnsupportedMethodError < ::HTTP::RequestError; end

# The scheme of given URI was not understood
class HTTP::Request::UnsupportedSchemeError < ::HTTP::RequestError; end

class HTTP::Request::Writer
  # @return [Writer] a new instance of Writer
  def initialize(socket, body, headers, headline); end

  # Adds the headers to the header array for the given request body we are working
  # with
  def add_body_type_headers; end

  # Adds headers to the request header from the headers array
  def add_headers; end

  # Returns true if the request should be sent in chunked encoding.
  #
  # @return [Boolean]
  def chunked?; end

  # Send headers needed to connect through proxy
  def connect_through_proxy; end

  # Yields chunks of request data that should be sent to the socket.
  #
  # It's important to send the request in a single write call when possible
  # in order to play nicely with Nagle's algorithm. Making two writes in a
  # row triggers a pathological case where Nagle is expecting a third write
  # that never happens.
  #
  # @yield [data]
  def each_chunk; end

  # Returns the chunk encoded for to the specified "Transfer-Encoding" header.
  def encode_chunk(chunk); end

  # Joins the headers specified in the request into a correctly formatted
  # http request header string
  def join_headers; end

  # Writes HTTP request data into the socket.
  def send_request; end

  # Stream the request to a socket
  def stream; end

  private

  def write(data); end
end

# Chunked transfer encoding
HTTP::Request::Writer::CHUNKED = T.let(T.unsafe(nil), String)

# End of a chunked transfer
HTTP::Request::Writer::CHUNKED_END = T.let(T.unsafe(nil), String)

# CRLF is the universal HTTP delimiter
HTTP::Request::Writer::CRLF = T.let(T.unsafe(nil), String)

# Chunked data termintaor.
HTTP::Request::Writer::ZERO = T.let(T.unsafe(nil), String)

# Generic Request error
class HTTP::RequestError < ::HTTP::Error; end

class HTTP::Response
  include ::HTTP::Headers::Mixin
  extend ::Forwardable

  # Inits a new instance
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Response] a new instance of Response
  def initialize(opts); end

  # @return [Body]
  def body; end

  # Charset of response (if any)
  #
  # @return [String, nil]
  def charset(*args, **_arg1, &block); end

  # @return [Boolean]
  def chunked?; end

  # @return [Fixnum] status code
  def code(*args, **_arg1, &block); end

  # The connection object used to make the corresponding request.
  #
  # @return [HTTP::Connection]
  def connection(*args, **_arg1, &block); end

  # Value of the Content-Length header.
  #
  # @return [nil] if Content-Length was not given, or it's value was invalid
  #   (not an integer, e.g. empty string or string with non-digits).
  # @return [Integer] otherwise
  def content_length; end

  # Parsed Content-Type header
  #
  # @return [HTTP::ContentType]
  def content_type; end

  def cookies; end

  # Flushes body and returns self-reference
  #
  # @return [Response]
  def flush; end

  # Inspect a response
  def inspect; end

  # MIME type of response (if any)
  #
  # @return [String, nil]
  def mime_type(*args, **_arg1, &block); end

  # Parse response body with corresponding MIME type adapter.
  #
  # @param type [#to_s] Parse as given MIME type.
  # @raise [Error] if no adapter found
  # @return [Object]
  def parse(type = T.unsafe(nil)); end

  # @return [Hash]
  def proxy_headers; end

  def readpartial(*args, **_arg1, &block); end

  # @return [String, nil] status message
  def reason(*args, **_arg1, &block); end

  # @return [Request]
  def request; end

  # @return [Status]
  def status; end

  # Returns an Array ala Rack: `[status, headers, body]`
  #
  # @return [Array(Fixnum, Hash, String)]
  def to_a; end

  # @return [String] eagerly consume the entire body as a string
  def to_s(*args, **_arg1, &block); end

  # @return [String] eagerly consume the entire body as a string
  def to_str(*args, **_arg1, &block); end

  def to_webmock; end
  def uri(*args, **_arg1, &block); end

  # @return [String]
  def version; end

  private

  # Initialize an HTTP::Request from options.
  #
  # @raise [ArgumentError]
  # @return [HTTP::Request]
  def init_request(opts); end

  class << self
    def from_webmock(request, webmock_response, request_signature = T.unsafe(nil)); end

    private

    def normalize_uri(uri); end
  end
end

# A streamable response body, also easily converted into a string
class HTTP::Response::Body
  include ::Enumerable
  extend ::Forwardable

  # @return [Body] a new instance of Body
  def initialize(stream, encoding: T.unsafe(nil)); end

  # The connection object used to make the corresponding request.
  #
  # @return [HTTP::Connection]
  def connection; end

  # Iterate over the body, allowing it to be enumerable
  def each; end

  def empty?(*args, **_arg1, &block); end

  # Easier to interpret string inspect
  def inspect; end

  def readpartial(*args); end

  # Assert that the body is actively being streamed
  #
  # @raise [StateError]
  def stream!; end

  # @raise [StateError]
  # @return [String] eagerly consume the entire body as a string
  def to_s; end

  # @raise [StateError]
  # @return [String] eagerly consume the entire body as a string
  def to_str; end

  private

  # Retrieve encoding by name. If encoding cannot be found, default to binary.
  def find_encoding(encoding); end
end

class HTTP::Response::Inflater
  # @return [Inflater] a new instance of Inflater
  def initialize(connection); end

  # Returns the value of attribute connection.
  def connection; end

  def readpartial(*args); end

  private

  def zstream; end
end

# @api private
class HTTP::Response::Parser
  # @api private
  # @return [Parser] a new instance of Parser
  def initialize; end

  # @api private
  def <<(data); end

  # @api private
  def add(data); end

  # @api private
  def add_body(chunk); end

  # @api private
  def add_header(name, value); end

  # @api private
  # @return [Boolean]
  def finished?; end

  # @api private
  def headers; end

  # @api private
  # @return [Boolean]
  def headers?; end

  # @api private
  def http_version; end

  # @api private
  def mark_header_finished; end

  # @api private
  def mark_message_finished; end

  # @api private
  def parser; end

  # @api private
  def read(size); end

  # @api private
  def reset; end

  # @api private
  def status_code; end
end

# @api private
class HTTP::Response::Parser::Handler < ::LLHttp::Delegate
  # @api private
  # @return [Handler] a new instance of Handler
  def initialize(target); end

  # @api private
  def on_body(body); end

  # @api private
  def on_header_field(field); end

  # @api private
  def on_header_value(value); end

  # @api private
  def on_headers_complete; end

  # @api private
  def on_message_complete; end

  # @api private
  def reset; end

  private

  # @api private
  def append_header; end
end

class HTTP::Response::Status
  def __getobj__; end

  # @raise [TypeError]
  def __setobj__(obj); end

  def accepted?; end
  def already_reported?; end
  def bad_gateway?; end
  def bad_request?; end

  # Check if status code is client error (4XX)
  #
  # @return [Boolean]
  def client_error?; end

  # @return [Fixnum] status code
  def code; end

  def conflict?; end
  def continue?; end
  def created?; end
  def expectation_failed?; end
  def failed_dependency?; end
  def forbidden?; end
  def found?; end
  def gateway_timeout?; end
  def gone?; end
  def http_version_not_supported?; end
  def im_used?; end

  # Check if status code is informational (1XX)
  #
  # @return [Boolean]
  def informational?; end

  # Printable version of HTTP Status, surrounded by quote marks,
  # with special characters escaped.
  #
  # (see String#inspect)
  def inspect; end

  def insufficient_storage?; end
  def internal_server_error?; end
  def length_required?; end
  def locked?; end
  def loop_detected?; end
  def method_not_allowed?; end
  def misdirected_request?; end
  def moved_permanently?; end
  def multi_status?; end
  def multiple_choices?; end
  def network_authentication_required?; end
  def no_content?; end
  def non_authoritative_information?; end
  def not_acceptable?; end
  def not_extended?; end
  def not_found?; end
  def not_implemented?; end
  def not_modified?; end
  def ok?; end
  def partial_content?; end
  def payload_too_large?; end
  def payment_required?; end
  def permanent_redirect?; end
  def precondition_failed?; end
  def precondition_required?; end
  def processing?; end
  def proxy_authentication_required?; end
  def range_not_satisfiable?; end

  # @return [String, nil] status message
  # @see REASONS
  def reason; end

  # Check if status code is redirection (3XX)
  #
  # @return [Boolean]
  def redirect?; end

  def request_header_fields_too_large?; end
  def request_timeout?; end
  def reset_content?; end
  def see_other?; end

  # Check if status code is server error (5XX)
  #
  # @return [Boolean]
  def server_error?; end

  def service_unavailable?; end

  # Check if status code is successful (2XX)
  #
  # @return [Boolean]
  def success?; end

  def switching_protocols?; end
  def temporary_redirect?; end

  # @return [String] string representation of HTTP status
  def to_s; end

  # Symbolized {#reason}
  #
  # @return [nil] unless code is well-known (see REASONS)
  # @return [Symbol]
  def to_sym; end

  def too_many_requests?; end
  def unauthorized?; end
  def unavailable_for_legal_reasons?; end
  def unprocessable_entity?; end
  def unsupported_media_type?; end
  def upgrade_required?; end
  def uri_too_long?; end
  def use_proxy?; end
  def variant_also_negotiates?; end

  class << self
    # Coerces given value to Status.
    #
    # @example
    #   Status.coerce(:bad_request) # => Status.new(400)
    #   Status.coerce("400")        # => Status.new(400)
    #   Status.coerce(true)         # => raises HTTP::Error
    # @param object [Symbol, #to_i]
    # @raise [Error] if coercion is impossible
    # @return [Status]
    def [](object); end

    # Coerces given value to Status.
    #
    # @example
    #
    #   Status.coerce(:bad_request) # => Status.new(400)
    #   Status.coerce("400")        # => Status.new(400)
    #   Status.coerce(true)         # => raises HTTP::Error
    # @param object [Symbol, #to_i]
    # @raise [Error] if coercion is impossible
    # @return [Status]
    def coerce(object); end

    private

    # Symbolizes given string
    #
    # @example
    #
    #   symbolize "Bad Request"           # => :bad_request
    #   symbolize "Request-URI Too Long"  # => :request_uri_too_long
    #   symbolize "I'm a Teapot"          # => :im_a_teapot
    # @param str [#to_s]
    # @return [Symbol]
    def symbolize(str); end
  end
end

# Code to Reason map
#
# @example Usage
#
#   REASONS[400] # => "Bad Request"
#   REASONS[414] # => "Request-URI Too Long"
# @return [Hash<Fixnum => String>]
HTTP::Response::Status::REASONS = T.let(T.unsafe(nil), Hash)

# Code to Symbol map
#
# @example Usage
#
#   SYMBOLS[400] # => :bad_request
#   SYMBOLS[414] # => :request_uri_too_long
#   SYMBOLS[418] # => :im_a_teapot
# @return [Hash<Fixnum => Symbol>]
HTTP::Response::Status::SYMBOLS = T.let(T.unsafe(nil), Hash)

# Reversed {SYMBOLS} map.
#
# @example Usage
#
#   SYMBOL_CODES[:bad_request]           # => 400
#   SYMBOL_CODES[:request_uri_too_long]  # => 414
#   SYMBOL_CODES[:im_a_teapot]           # => 418
# @return [Hash<Symbol => Fixnum>]
HTTP::Response::Status::SYMBOL_CODES = T.let(T.unsafe(nil), Hash)

# Generic Response error
class HTTP::ResponseError < ::HTTP::Error; end

# Requested to do something when we're in the wrong state
class HTTP::StateError < ::HTTP::ResponseError; end

module HTTP::Timeout; end

class HTTP::Timeout::Global < ::HTTP::Timeout::Null
  # @return [Global] a new instance of Global
  def initialize(*args); end

  # Write to the socket
  def <<(data); end

  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end
  def connect_ssl; end

  # Read from the socket
  def readpartial(size, buffer = T.unsafe(nil)); end

  # To future me: Don't remove this again, past you was smarter.
  def reset_counter; end

  # Write to the socket
  def write(data); end

  private

  # @raise [TimeoutError]
  def log_time; end

  # Perform the given I/O operation with the given argument
  def perform_io; end

  def read_nonblock(size, buffer = T.unsafe(nil)); end

  # Due to the run/retry nature of nonblocking I/O, it's easier to keep track of time
  # via method calls instead of a block to monitor.
  def reset_timer; end

  # Wait for a socket to become readable
  def wait_readable_or_timeout; end

  # Wait for a socket to become writable
  def wait_writable_or_timeout; end

  def write_nonblock(data); end
end

class HTTP::Timeout::Null
  extend ::Forwardable

  # @return [Null] a new instance of Null
  def initialize(options = T.unsafe(nil)); end

  # Write to the socket
  def <<(data); end

  def close(*args, **_arg1, &block); end
  def closed?(*args, **_arg1, &block); end

  # Connects to a socket
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end

  # Starts a SSL connection on a socket
  def connect_ssl; end

  # Returns the value of attribute options.
  def options; end

  # Read from the socket
  def readpartial(size, buffer = T.unsafe(nil)); end

  # Returns the value of attribute socket.
  def socket; end

  # Configures the SSL connection and starts the connection
  def start_tls(host, ssl_socket_class, ssl_context); end

  # Write to the socket
  def write(data); end

  private

  # Retry reading
  def rescue_readable(timeout = T.unsafe(nil)); end

  # Retry writing
  def rescue_writable(timeout = T.unsafe(nil)); end
end

class HTTP::Timeout::PerOperation < ::HTTP::Timeout::Null
  # @return [PerOperation] a new instance of PerOperation
  def initialize(*args); end

  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end
  def connect_ssl; end

  # Read data from the socket
  def readpartial(size, buffer = T.unsafe(nil)); end

  # Write data to the socket
  def write(data); end
end

HTTP::Timeout::PerOperation::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Float)
HTTP::Timeout::PerOperation::READ_TIMEOUT = T.let(T.unsafe(nil), Float)
HTTP::Timeout::PerOperation::WRITE_TIMEOUT = T.let(T.unsafe(nil), Float)

# Generic Timeout error
class HTTP::TimeoutError < ::HTTP::Error; end

class HTTP::URI
  extend ::Forwardable

  # Creates an HTTP::URI instance from the given options
  #
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @param options_or_uri [Hash, Addressable::URI]
  # @return [HTTP::URI] new URI instance
  def initialize(options_or_uri = T.unsafe(nil)); end

  # Are these URI objects equal? Normalizes both URIs prior to comparison
  #
  # @param other [Object] URI to compare this one with
  # @return [TrueClass, FalseClass] are the URIs equivalent (after normalization)?
  def ==(other); end

  def authority(*args, **_arg1, &block); end
  def authority=(*args, **_arg1, &block); end

  # @return [Object] duplicated URI
  def dup; end

  # Are these URI objects equal? Does NOT normalizes both URIs prior to comparison
  #
  # @param other [Object] URI to compare this one with
  # @return [TrueClass, FalseClass] are the URIs equivalent?
  def eql?(other); end

  def fragment(*args, **_arg1, &block); end
  def fragment=(*args, **_arg1, &block); end

  # Hash value based off the normalized form of a URI
  #
  # @return [Integer] A hash of the URI
  def hash; end

  def host(*args, **_arg1, &block); end
  def host=(*args, **_arg1, &block); end

  # @return [True] if URI is HTTP
  # @return [False] otherwise
  def http?; end

  # @return [True] if URI is HTTPS
  # @return [False] otherwise
  def https?; end

  # @return [String] human-readable representation of URI
  def inspect; end

  def join(*args, **_arg1, &block); end
  def normalize(*args, **_arg1, &block); end
  def normalized_authority(*args, **_arg1, &block); end
  def normalized_fragment(*args, **_arg1, &block); end
  def normalized_host(*args, **_arg1, &block); end
  def normalized_password(*args, **_arg1, &block); end
  def normalized_path(*args, **_arg1, &block); end
  def normalized_port(*args, **_arg1, &block); end
  def normalized_query(*args, **_arg1, &block); end
  def normalized_scheme(*args, **_arg1, &block); end
  def normalized_user(*args, **_arg1, &block); end
  def omit(*args, **_arg1, &block); end
  def origin(*args, **_arg1, &block); end
  def origin=(*args, **_arg1, &block); end
  def password(*args, **_arg1, &block); end
  def password=(*args, **_arg1, &block); end
  def path(*args, **_arg1, &block); end
  def path=(*args, **_arg1, &block); end

  # Port number, either as specified or the default if unspecified
  #
  # @return [Integer] port number
  def port; end

  def port=(*args, **_arg1, &block); end
  def query(*args, **_arg1, &block); end
  def query=(*args, **_arg1, &block); end
  def query_values(*args, **_arg1, &block); end
  def query_values=(*args, **_arg1, &block); end
  def request_uri(*args, **_arg1, &block); end
  def request_uri=(*args, **_arg1, &block); end
  def scheme(*args, **_arg1, &block); end
  def scheme=(*args, **_arg1, &block); end

  # Convert an HTTP::URI to a String
  #
  # @return [String] URI serialized as a String
  def to_s; end

  # Convert an HTTP::URI to a String
  #
  # @return [String] URI serialized as a String
  def to_str; end

  def user(*args, **_arg1, &block); end
  def user=(*args, **_arg1, &block); end

  class << self
    # Encodes key/value pairs as application/x-www-form-urlencoded
    #
    # @param form_values [#to_hash, #to_ary] to encode
    # @param sort [TrueClass, FalseClass] should key/value pairs be sorted first?
    # @return [String] encoded value
    def form_encode(form_values, sort = T.unsafe(nil)); end

    # Parse the given URI string, returning an HTTP::URI object
    #
    # @param uri [HTTP::URI, String, #to_str] to parse
    # @return [HTTP::URI] new URI instance
    def parse(uri); end
  end
end

# @private
HTTP::URI::HTTPS_SCHEME = T.let(T.unsafe(nil), String)

# @private
HTTP::URI::HTTP_SCHEME = T.let(T.unsafe(nil), String)

# @private
HTTP::URI::NORMALIZER = T.let(T.unsafe(nil), Proc)

HTTP::VERSION = T.let(T.unsafe(nil), String)
