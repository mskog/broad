# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq-limit_fetch` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq-limit_fetch`.

# Sidekiq's systemd integration allows Sidekiq to inform systemd:
#  1. when it has successfully started
#  2. when it is starting shutdown
#  3. periodically for a liveness check with a watchdog thread
module Sidekiq
  class << self
    # How frequently Redis should be checked by a random Sidekiq process for
    # scheduled and retriable jobs. Each individual process will take turns by
    # waiting some multiple of this value.
    #
    # See sidekiq/scheduled.rb for an in-depth explanation of this value
    def average_scheduled_poll_interval=(interval); end

    # @yield [@client_chain]
    def client_middleware; end

    # Configuration for Sidekiq client, use like:
    #
    #   Sidekiq.configure_client do |config|
    #     config.redis = { :namespace => 'myapp', :size => 1, :url => 'redis://myhost:8877/0' }
    #   end
    #
    # @yield [_self]
    # @yieldparam _self [Sidekiq] the object that the method was called on
    def configure_client; end

    # Configuration for Sidekiq server, use like:
    #
    #   Sidekiq.configure_server do |config|
    #     config.redis = { :namespace => 'myapp', :size => 25, :url => 'redis://myhost:8877/0' }
    #     config.server_middleware do |chain|
    #       chain.add MyServerHook
    #     end
    #   end
    #
    # @yield [_self]
    # @yieldparam _self [Sidekiq] the object that the method was called on
    def configure_server; end

    # Death handlers are called when all retries for a job have been exhausted and
    # the job dies.  It's the notification to your application
    # that this job will not succeed without manual intervention.
    #
    # Sidekiq.configure_server do |config|
    #   config.death_handlers << ->(job, ex) do
    #   end
    # end
    def death_handlers; end

    def default_server_middleware; end
    def default_worker_options; end
    def default_worker_options=(hash); end
    def dump_json(object); end

    # Register a proc to handle any error which occurs within the Sidekiq process.
    #
    #   Sidekiq.configure_server do |config|
    #     config.error_handlers << proc {|ex,ctx_hash| MyErrorService.notify(ex, ctx_hash) }
    #   end
    #
    # The default error handler logs errors to Sidekiq.logger.
    def error_handlers; end

    def load_json(string); end
    def log_formatter; end
    def log_formatter=(log_formatter); end
    def logger; end
    def logger=(logger); end

    # Register a block to run at a point in the Sidekiq lifecycle.
    # :startup, :quiet or :shutdown are valid events.
    #
    #   Sidekiq.configure_server do |config|
    #     config.on(:shutdown) do
    #       puts "Goodbye cruel world!"
    #     end
    #   end
    #
    # @raise [ArgumentError]
    def on(event, &block); end

    def options; end
    def options=(opts); end

    # @return [Boolean]
    def pro?; end

    # @raise [ArgumentError]
    def redis; end

    def redis=(hash); end
    def redis_info; end
    def redis_pool; end

    # @return [Boolean]
    def server?; end

    # @yield [@server_chain]
    def server_middleware; end

    def strict_args!(mode = T.unsafe(nil)); end
    def ❨╯°□°❩╯︵┻━┻; end
  end
end

class Sidekiq::BasicFetch::UnitOfWork < ::Struct
  def acknowledge; end

  # Returns the value of attribute job
  #
  # @return [Object] the current value of job
  def job; end

  # Sets the attribute job
  #
  # @param value [Object] the value to set the attribute job to.
  # @return [Object] the newly set value
  def job=(_); end

  # Returns the value of attribute queue
  #
  # @return [Object] the current value of queue
  def queue; end

  # Sets the attribute queue
  #
  # @param value [Object] the value to set the attribute queue to.
  # @return [Object] the newly set value
  def queue=(_); end

  def queue_name; end
  def requeue; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

Sidekiq::DEFAULTS = T.let(T.unsafe(nil), Hash)
Sidekiq::DEFAULT_WORKER_OPTIONS = T.let(T.unsafe(nil), Hash)
Sidekiq::FAKE_INFO = T.let(T.unsafe(nil), Hash)

# Sidekiq::Job is a new alias for Sidekiq::Worker as of Sidekiq 6.3.0.
# Use `include Sidekiq::Job` rather than `include Sidekiq::Worker`.
#
# The term "worker" is too generic and overly confusing, used in several
# different contexts meaning different things. Many people call a Sidekiq
# process a "worker". Some people call the thread that executes jobs a
# "worker". This change brings Sidekiq closer to ActiveJob where your job
# classes extend ApplicationJob.
Sidekiq::Job = Sidekiq::Worker

Sidekiq::LICENSE = T.let(T.unsafe(nil), String)

module Sidekiq::LimitFetch
  extend ::Sidekiq::LimitFetch

  def bulk_requeue(*args); end
  def new(_); end
  def redis_retryable; end
  def retrieve_work; end

  private

  def redis_brpop(queues); end
end

module Sidekiq::LimitFetch::Global; end

module Sidekiq::LimitFetch::Global::Monitor
  extend ::Sidekiq::LimitFetch::Global::Monitor

  def add_dynamic_queues; end
  def all_processes; end
  def old_processes; end
  def remove_old_processes!; end
  def start!(ttl = T.unsafe(nil), timeout = T.unsafe(nil)); end

  private

  def heartbeat_key(process = T.unsafe(nil)); end
  def invalidate_old_processes; end
  def update_heartbeat(ttl); end
end

Sidekiq::LimitFetch::Global::Monitor::HEARTBEAT_PREFIX = T.let(T.unsafe(nil), String)
Sidekiq::LimitFetch::Global::Monitor::HEARTBEAT_TTL = T.let(T.unsafe(nil), Integer)
Sidekiq::LimitFetch::Global::Monitor::PROCESS_SET = T.let(T.unsafe(nil), String)
Sidekiq::LimitFetch::Global::Monitor::REFRESH_TIMEOUT = T.let(T.unsafe(nil), Integer)

module Sidekiq::LimitFetch::Global::Selector
  extend ::Sidekiq::LimitFetch::Global::Selector

  def acquire(queues, namespace); end
  def release(queues, namespace); end
  def uuid; end

  private

  def redis_acquire_script; end
  def redis_acquire_sha; end
  def redis_eval(script_name, args); end
  def redis_release_script; end
  def redis_release_sha; end
end

Sidekiq::LimitFetch::Global::Selector::MUTEX_FOR_UUID = T.let(T.unsafe(nil), Thread::Mutex)

class Sidekiq::LimitFetch::Global::Semaphore
  # @return [Semaphore] a new instance of Semaphore
  def initialize(name); end

  def acquire; end
  def block; end

  # @raise [ArgumentError]
  def block_except(*queues); end

  # @return [Boolean]
  def blocking?; end

  def busy; end
  def busy_processes; end
  def decrease_busy; end
  def decrease_local_busy; end
  def explain; end
  def increase_busy; end
  def increase_local_busy; end
  def limit; end
  def limit=(value); end

  # @return [Boolean]
  def limit_changed?; end

  # Returns the value of attribute local_busy.
  def local_busy; end

  # @return [Boolean]
  def local_busy?; end

  def pause; end
  def pause_for_ms(ms); end

  # @return [Boolean]
  def paused?; end

  def probed; end
  def probed_processes; end
  def process_limit; end
  def process_limit=(value); end
  def release; end
  def remove_lock!(process); end
  def remove_locks_except!(processes); end
  def unblock; end
  def unpause; end

  private

  def namespace; end
  def redis(&block); end
end

Sidekiq::LimitFetch::Global::Semaphore::PREFIX = T.let(T.unsafe(nil), String)

module Sidekiq::LimitFetch::Instances
  def [](*args); end
  def instances; end
  def new(*args); end
  def reset_instances!; end

  class << self
    # @private
    def extended(klass); end
  end
end

module Sidekiq::LimitFetch::Queues
  extend ::Sidekiq::LimitFetch::Queues

  def acquire; end
  def add(queues); end

  # @return [Boolean]
  def dynamic?; end

  def namespace; end
  def release_except(full_name); end
  def start(options); end
  def strict_order!; end
  def weighted_order!; end

  private

  def apply_blocks_to_queues; end
  def apply_limit_to_queue(queue_name); end
  def apply_limit_to_queues; end
  def apply_process_limit_to_queue(queue_name); end
  def apply_process_limit_to_queues; end
  def restore; end
  def save(queues); end
  def selector; end
end

Sidekiq::LimitFetch::Queues::THREAD_KEY = T.let(T.unsafe(nil), Symbol)
Sidekiq::LimitFetch::TIMEOUT = T.let(T.unsafe(nil), Integer)

class Sidekiq::LimitFetch::UnitOfWork < ::Sidekiq::BasicFetch::UnitOfWork
  def initialize(queue, job); end

  def acknowledge; end
  def requeue; end

  private

  def redis_retryable(&block); end
end

# The Manager is the central coordination point in Sidekiq, controlling
# the lifecycle of the Processors.
#
# Tasks:
#
# 1. start: Spin up Processors.
# 3. processor_died: Handle job failure, throw away Processor, create new one.
# 4. quiet: shutdown idle Processors.
# 5. stop: hard stop the Processors by deadline.
#
# Note that only the last task requires its own Thread since it has to monitor
# the shutdown process.  The other tasks are performed by other threads.
class Sidekiq::Manager
  include ::Sidekiq::Manager::InitLimitFetch
  include ::Sidekiq::ExceptionHandler

  # @raise [ArgumentError]
  # @return [Manager] a new instance of Manager
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute options.
  def options; end

  def processor_died(processor, reason); end
  def processor_stopped(processor); end
  def quiet; end
  def start; end
  def stop(deadline); end

  # @return [Boolean]
  def stopped?; end

  # Returns the value of attribute workers.
  def workers; end

  private

  def hard_shutdown; end
end

module Sidekiq::Manager::InitLimitFetch
  def initialize(options = T.unsafe(nil)); end

  def start; end
end

Sidekiq::NAME = T.let(T.unsafe(nil), String)

# Encapsulates a queue within Sidekiq.
# Allows enumeration of all jobs within the queue
# and deletion of jobs.
#
#   queue = Sidekiq::Queue.new("mailer")
#   queue.each do |job|
#     job.klass # => 'MyWorker'
#     job.args # => [1, 2, 3]
#     job.delete if job.jid == 'abcdef1234567890'
#   end
class Sidekiq::Queue
  extend ::Forwardable
  extend ::Sidekiq::LimitFetch::Instances

  # @return [Queue] a new instance of Queue
  def initialize(name = T.unsafe(nil)); end

  def acquire(*args, **_arg1, &block); end
  def block(*args, **_arg1, &block); end
  def block_except(*args, **_arg1, &block); end
  def blocking?(*args, **_arg1, &block); end
  def busy(*args, **_arg1, &block); end
  def clear; end
  def decrease_busy(*args, **_arg1, &block); end
  def each; end
  def explain(*args, **_arg1, &block); end

  # Find the job with the given JID within this queue.
  #
  # This is a slow, inefficient operation.  Do not use under
  # normal conditions.
  def find_job(jid); end

  def increase_busy(*args, **_arg1, &block); end

  # Calculates this queue's latency, the difference in seconds since the oldest
  # job in the queue was enqueued.
  #
  # @return Float
  def latency; end

  def limit(*args, **_arg1, &block); end
  def limit=(*args, **_arg1, &block); end
  def limit_changed?(*args, **_arg1, &block); end
  def local_busy?(*args, **_arg1, &block); end
  def lock; end

  # Returns the value of attribute name.
  def name; end

  def pause(*args, **_arg1, &block); end
  def pause_for_ms(*args, **_arg1, &block); end

  # Sidekiq Pro overrides this
  #
  # @return [Boolean]
  def paused?(*args, **_arg1, &block); end

  def probed(*args, **_arg1, &block); end
  def process_limit(*args, **_arg1, &block); end
  def process_limit=(*args, **_arg1, &block); end
  def release(*args, **_arg1, &block); end
  def remove_locks_except!(*args, **_arg1, &block); end

  # Returns the value of attribute rname.
  def rname; end

  def size; end
  def unblock(*args, **_arg1, &block); end
  def unblocked(*args, **_arg1, &block); end
  def unpause(*args, **_arg1, &block); end
  def 💣; end

  class << self
    # Return all known queues within Redis.
    def all; end
  end
end

Sidekiq::VERSION = T.let(T.unsafe(nil), String)

# Since "worker" is a nebulous term, we've deprecated the use of this class name.
# Is "worker" a process, a type of job, a thread? Undefined!
# WorkSet better describes the data.
Sidekiq::Workers = Sidekiq::WorkSet
