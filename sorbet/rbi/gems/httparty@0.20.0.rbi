# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `httparty` gem.
# Please instead update this file by running `bin/tapioca gem httparty`.

# @see HTTParty::ClassMethods
module HTTParty
  include ::HTTParty::ModuleInheritableAttributes

  mixes_in_class_methods ::HTTParty::ClassMethods
  mixes_in_class_methods ::HTTParty::ModuleInheritableAttributes::ClassMethods

  class << self
    def copy(*args, &block); end
    def delete(*args, &block); end
    def get(*args, &block); end
    def head(*args, &block); end

    # @private
    def included(base); end

    def move(*args, &block); end
    def normalize_base_uri(url); end
    def options(*args, &block); end
    def patch(*args, &block); end
    def post(*args, &block); end
    def put(*args, &block); end
  end
end

class HTTParty::Basement
  include ::HTTParty
  include ::HTTParty::ModuleInheritableAttributes
  extend ::HTTParty::ClassMethods
  extend ::HTTParty::ModuleInheritableAttributes::ClassMethods

  class << self
    def default_cookies; end
    def default_cookies=(_arg0); end
    def default_options; end
    def default_options=(_arg0); end
  end
end

# == Common Request Options
# Request methods (get, post, patch, put, delete, head, options) all take a common set of options. These are:
#
# [:+body+:] Body of the request. If passed an object that responds to #to_hash, will try to normalize it first, by default passing it to ActiveSupport::to_params. Any other kind of object will get used as-is.
# [:+http_proxyaddr+:] Address of proxy server to use.
# [:+http_proxyport+:]  Port of proxy server to use.
# [:+http_proxyuser+:] User for proxy server authentication.
# [:+http_proxypass+:] Password for proxy server authentication.
# [:+limit+:] Maximum number of redirects to follow. Takes precedences over :+no_follow+.
# [:+query+:] Query string, or an object that responds to #to_hash representing it. Normalized according to the same rules as :+body+. If you specify this on a POST, you must use an object which responds to #to_hash. See also HTTParty::ClassMethods.default_params.
# [:+timeout+:] Timeout for opening connection and reading data.
# [:+local_host+:] Local address to bind to before connecting.
# [:+local_port+:] Local port to bind to before connecting.
# [:+body_stream+:] Allow streaming to a REST server to specify a body_stream.
# [:+stream_body+:] Allow for streaming large files without loading them into memory.
# [:+multipart+:] Force content-type to be multipart
#
# There are also another set of options with names corresponding to various class methods. The methods in question are those that let you set a class-wide default, and the options override the defaults on a request-by-request basis. Those options are:
# * :+base_uri+: see HTTParty::ClassMethods.base_uri.
# * :+basic_auth+: see HTTParty::ClassMethods.basic_auth. Only one of :+basic_auth+ and :+digest_auth+ can be used at a time; if you try using both, you'll get an ArgumentError.
# * :+debug_output+: see HTTParty::ClassMethods.debug_output.
# * :+digest_auth+: see HTTParty::ClassMethods.digest_auth. Only one of :+basic_auth+ and :+digest_auth+ can be used at a time; if you try using both, you'll get an ArgumentError.
# * :+format+: see HTTParty::ClassMethods.format.
# * :+headers+: see HTTParty::ClassMethods.headers. Must be a an object which responds to #to_hash.
# * :+maintain_method_across_redirects+: see HTTParty::ClassMethods.maintain_method_across_redirects.
# * :+no_follow+: see HTTParty::ClassMethods.no_follow.
# * :+parser+: see HTTParty::ClassMethods.parser.
# * :+uri_adapter+: see HTTParty::ClassMethods.uri_adapter
# * :+connection_adapter+: see HTTParty::ClassMethods.connection_adapter.
# * :+pem+: see HTTParty::ClassMethods.pem.
# * :+query_string_normalizer+: see HTTParty::ClassMethods.query_string_normalizer
# * :+ssl_ca_file+: see HTTParty::ClassMethods.ssl_ca_file.
# * :+ssl_ca_path+: see HTTParty::ClassMethods.ssl_ca_path.
module HTTParty::ClassMethods
  # Allows setting a base uri to be used for each request.
  # Will normalize uri to include http, etc.
  #
  #   class Foo
  #     include HTTParty
  #     base_uri 'twitter.com'
  #   end
  def base_uri(uri = T.unsafe(nil)); end

  # Allows setting basic authentication username and password.
  #
  #   class Foo
  #     include HTTParty
  #     basic_auth 'username', 'password'
  #   end
  def basic_auth(u, p); end

  # Allows setting of SSL ciphers to use.  This only works in Ruby 1.9+.
  # You can get a list of valid specific ciphers from OpenSSL::Cipher.ciphers.
  # You also can specify a cipher suite here, listed here at openssl.org:
  # http://www.openssl.org/docs/apps/ciphers.html#CIPHER_SUITE_NAMES
  #
  #   class Foo
  #     include HTTParty
  #     ciphers "RC4-SHA"
  #   end
  def ciphers(cipher_names); end

  # Allows setting a custom connection_adapter for the http connections
  #
  # @example
  #   class Foo
  #   include HTTParty
  #   connection_adapter Proc.new {|uri, options| ... }
  #   end
  # @example provide optional configuration for your connection_adapter
  #   class Foo
  #   include HTTParty
  #   connection_adapter Proc.new {|uri, options| ... }, {foo: :bar}
  #   end
  # @see HTTParty::ConnectionAdapter
  def connection_adapter(custom_adapter = T.unsafe(nil), options = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def cookies(h = T.unsafe(nil)); end

  # Perform a COPY request to a path
  def copy(path, options = T.unsafe(nil), &block); end

  # Set an output stream for debugging, defaults to $stderr.
  # The output stream is passed on to Net::HTTP#set_debug_output.
  #
  #   class Foo
  #     include HTTParty
  #     debug_output $stderr
  #   end
  def debug_output(stream = T.unsafe(nil)); end

  # Returns the value of attribute default_options.
  def default_options; end

  # Allows setting default parameters to be appended to each request.
  # Great for api keys and such.
  #
  #   class Foo
  #     include HTTParty
  #     default_params api_key: 'secret', another: 'foo'
  #   end
  #
  # @raise [ArgumentError]
  def default_params(h = T.unsafe(nil)); end

  # Allows setting a default timeout for all HTTP calls
  # Timeout is specified in seconds.
  #
  #   class Foo
  #     include HTTParty
  #     default_timeout 10
  #   end
  def default_timeout(value); end

  # Perform a DELETE request to a path
  def delete(path, options = T.unsafe(nil), &block); end

  # Allows setting digest authentication username and password.
  #
  #   class Foo
  #     include HTTParty
  #     digest_auth 'username', 'password'
  #   end
  def digest_auth(u, p); end

  # Do not send rails style query strings.
  # Specifically, don't use bracket notation when sending an array
  #
  # For a query:
  #   get '/', query: {selected_ids: [1,2,3]}
  #
  # The default query string looks like this:
  #   /?selected_ids[]=1&selected_ids[]=2&selected_ids[]=3
  #
  # Call `disable_rails_query_string_format` to transform the query string
  # into:
  #   /?selected_ids=1&selected_ids=2&selected_ids=3
  #
  # @example
  #   class Foo
  #   include HTTParty
  #   disable_rails_query_string_format
  #   end
  def disable_rails_query_string_format; end

  # Proceed to the location header when an HTTP response dictates a redirect.
  # Redirects are always followed by default.
  #
  # @example
  #   class Foo
  #   include HTTParty
  #   base_uri 'http://google.com'
  #   follow_redirects true
  #   end
  def follow_redirects(value = T.unsafe(nil)); end

  # Allows setting the format with which to parse.
  # Must be one of the allowed formats ie: json, xml
  #
  #   class Foo
  #     include HTTParty
  #     format :json
  #   end
  def format(f = T.unsafe(nil)); end

  # Allows making a get request to a url.
  #
  #   class Foo
  #     include HTTParty
  #   end
  #
  #   # Simple get with full url
  #   Foo.get('http://foo.com/resource.json')
  #
  #   # Simple get with full url and query parameters
  #   # ie: http://foo.com/resource.json?limit=10
  #   Foo.get('http://foo.com/resource.json', query: {limit: 10})
  def get(path, options = T.unsafe(nil), &block); end

  # Perform a HEAD request to a path
  def head(path, options = T.unsafe(nil), &block); end

  # Allows setting HTTP headers to be used for each request.
  #
  #   class Foo
  #     include HTTParty
  #     headers 'Accept' => 'text/html'
  #   end
  def headers(h = T.unsafe(nil)); end

  # Allows setting http proxy information to be used
  #
  #   class Foo
  #     include HTTParty
  #     http_proxy 'http://foo.com', 80, 'user', 'pass'
  #   end
  def http_proxy(addr = T.unsafe(nil), port = T.unsafe(nil), user = T.unsafe(nil), pass = T.unsafe(nil)); end

  def lock(path, options = T.unsafe(nil), &block); end

  # Turns on logging
  #
  #   class Foo
  #     include HTTParty
  #     logger Logger.new('http_logger'), :info, :apache
  #   end
  def logger(logger, level = T.unsafe(nil), format = T.unsafe(nil)); end

  # Declare that you wish to maintain the chosen HTTP method across redirects.
  # The default behavior is to follow redirects via the GET method, except
  # if you are making a HEAD request, in which case the default is to
  # follow all redirects with HEAD requests.
  # If you wish to maintain the original method, you can set this option to true.
  #
  # @example
  #   class Foo
  #   include HTTParty
  #   base_uri 'http://google.com'
  #   maintain_method_across_redirects true
  #   end
  def maintain_method_across_redirects(value = T.unsafe(nil)); end

  # Perform a MKCOL request to a path
  def mkcol(path, options = T.unsafe(nil), &block); end

  # Perform a MOVE request to a path
  def move(path, options = T.unsafe(nil), &block); end

  # Declare whether or not to follow redirects.  When true, an
  # {HTTParty::RedirectionTooDeep} error will raise upon encountering a
  # redirect. You can then gain access to the response object via
  # HTTParty::RedirectionTooDeep#response.
  #
  # @example
  #   class Foo
  #   include HTTParty
  #   base_uri 'http://google.com'
  #   no_follow true
  #   end
  #
  #   begin
  #   Foo.get('/')
  #   rescue HTTParty::RedirectionTooDeep => e
  #   puts e.response.body
  #   end
  # @see HTTParty::ResponseError#response
  def no_follow(value = T.unsafe(nil)); end

  # Allows setting a default open_timeout for all HTTP calls in seconds
  #
  #   class Foo
  #     include HTTParty
  #     open_timeout 10
  #   end
  def open_timeout(value); end

  # Perform an OPTIONS request to a path
  def options(path, options = T.unsafe(nil), &block); end

  # Allows setting a custom parser for the response.
  #
  #   class Foo
  #     include HTTParty
  #     parser Proc.new {|data| ...}
  #   end
  def parser(custom_parser = T.unsafe(nil)); end

  # Perform a PATCH request to a path
  def patch(path, options = T.unsafe(nil), &block); end

  # Allows setting a PEM file to be used
  #
  #   class Foo
  #     include HTTParty
  #     pem File.read('/home/user/my.pem'), "optional password"
  #   end
  def pem(pem_contents, password = T.unsafe(nil)); end

  # Allows setting a PKCS12 file to be used
  #
  #   class Foo
  #     include HTTParty
  #     pkcs12 File.read('/home/user/my.p12'), "password"
  #   end
  def pkcs12(p12_contents, password); end

  # Allows making a post request to a url.
  #
  #   class Foo
  #     include HTTParty
  #   end
  #
  #   # Simple post with full url and setting the body
  #   Foo.post('http://foo.com/resources', body: {bar: 'baz'})
  #
  #   # Simple post with full url using :query option,
  #   # which appends the parameters to the URI.
  #   Foo.post('http://foo.com/resources', query: {bar: 'baz'})
  def post(path, options = T.unsafe(nil), &block); end

  # Perform a PUT request to a path
  def put(path, options = T.unsafe(nil), &block); end

  # Override the way query strings are normalized.
  # Helpful for overriding the default rails normalization of Array queries.
  #
  # For a query:
  #   get '/', query: {selected_ids: [1,2,3]}
  #
  # The default query string normalizer returns:
  #   /?selected_ids[]=1&selected_ids[]=2&selected_ids[]=3
  #
  # Let's change it to this:
  #  /?selected_ids=1&selected_ids=2&selected_ids=3
  #
  # Pass a Proc to the query normalizer which accepts the yielded query.
  #
  # @example Modifying Array query strings
  #   class ServiceWrapper
  #   include HTTParty
  #
  #   query_string_normalizer proc { |query|
  #   query.map do |key, value|
  #   value.map {|v| "#{key}=#{v}"}
  #   end.join('&')
  #   }
  #   end
  # @param normalizer [Proc] custom query string normalizer.
  # @yield [Hash, String] query string
  # @yieldreturn [Array] an array that will later be joined with '&'
  def query_string_normalizer(normalizer); end

  # Raises HTTParty::ResponseError if response's code matches this statuses
  #
  #   class Foo
  #     include HTTParty
  #     raise_on [404, 500]
  #   end
  def raise_on(codes = T.unsafe(nil)); end

  # Allows setting a default read_timeout for all HTTP calls in seconds
  #
  #   class Foo
  #     include HTTParty
  #     read_timeout 10
  #   end
  def read_timeout(value); end

  # Declare that you wish to resend the full HTTP request across redirects,
  # even on redirects that should logically become GET requests.
  # A 303 redirect in HTTP signifies that the redirected url should normally
  # retrieved using a GET request, for instance, it is the output of a previous
  # POST. maintain_method_across_redirects respects this behavior, but you
  # can force HTTParty to resend_on_redirect even on 303 responses.
  #
  # @example
  #   class Foo
  #   include HTTParty
  #   base_uri 'http://google.com'
  #   resend_on_redirect
  #   end
  def resend_on_redirect(value = T.unsafe(nil)); end

  # Deactivate automatic decompression of the response body.
  # This will require you to explicitly handle body decompression
  # by inspecting the Content-Encoding response header.
  #
  # Refer to docs/README.md "HTTP Compression" section for
  # further details.
  #
  # @example
  #   class Foo
  #   include HTTParty
  #   skip_decompression
  #   end
  def skip_decompression(value = T.unsafe(nil)); end

  # Allows setting an OpenSSL certificate authority file.  The file
  # should contain one or more certificates in PEM format.
  #
  # Setting this option enables certificate verification.  All
  # certificates along a chain must be available in ssl_ca_file or
  # ssl_ca_path for verification to succeed.
  #
  #
  #   class Foo
  #     include HTTParty
  #     ssl_ca_file '/etc/ssl/certs/ca-certificates.crt'
  #   end
  def ssl_ca_file(path); end

  # Allows setting an OpenSSL certificate authority path (directory).
  #
  # Setting this option enables certificate verification.  All
  # certificates along a chain must be available in ssl_ca_file or
  # ssl_ca_path for verification to succeed.
  #
  #   class Foo
  #     include HTTParty
  #     ssl_ca_path '/etc/ssl/certs/'
  #   end
  def ssl_ca_path(path); end

  # Allows setting of SSL version to use. This only works in Ruby 1.9+.
  # You can get a list of valid versions from OpenSSL::SSL::SSLContext::METHODS.
  #
  #   class Foo
  #     include HTTParty
  #     ssl_version :SSLv3
  #   end
  def ssl_version(version); end

  def unlock(path, options = T.unsafe(nil), &block); end

  # Allows setting a custom URI adapter.
  #
  #   class Foo
  #     include HTTParty
  #     uri_adapter Addressable::URI
  #   end
  #
  # @raise [ArgumentError]
  def uri_adapter(uri_adapter); end

  # Allows setting a default write_timeout for all HTTP calls in seconds
  # Supported by Ruby > 2.6.0
  #
  #   class Foo
  #     include HTTParty
  #     write_timeout 10
  #   end
  def write_timeout(value); end

  private

  def ensure_method_maintained_across_redirects(options); end
  def perform_request(http_method, path, options, &block); end
  def process_cookies(options); end
  def validate_format; end

  # @raise [ArgumentError]
  def validate_timeout_argument(timeout_type, value); end
end

# Default connection adapter that returns a new Net::HTTP each time
#
# == Custom Connection Factories
#
# If you like to implement your own connection adapter, subclassing
# HTTParty::ConnectionAdapter will make it easier. Just override
# the #connection method. The uri and options attributes will have
# all the info you need to construct your http connection. Whatever
# you return from your connection method needs to adhere to the
# Net::HTTP interface as this is what HTTParty expects.
#
# === Configuration
# There is lots of configuration data available for your connection adapter
# in the #options attribute. It is up to you to interpret them within your
# connection adapter. Take a look at the implementation of
# HTTParty::ConnectionAdapter#connection for examples of how they are used.
# The keys used in options are
# * :+timeout+: timeout in seconds
# * :+open_timeout+: http connection open_timeout in seconds, overrides timeout if set
# * :+read_timeout+: http connection read_timeout in seconds, overrides timeout if set
# * :+write_timeout+: http connection write_timeout in seconds, overrides timeout if set (Ruby >= 2.6.0 required)
# * :+debug_output+: see HTTParty::ClassMethods.debug_output.
# * :+cert_store+: contains certificate data. see method 'attach_ssl_certificates'
# * :+pem+: contains pem client certificate data. see method 'attach_ssl_certificates'
# * :+p12+: contains PKCS12 client client certificate data.  see method 'attach_ssl_certificates'
# * :+verify+: verify the serverâ€™s certificate against the ca certificate.
# * :+verify_peer+: set to false to turn off server verification but still send client certificate
# * :+ssl_ca_file+: see HTTParty::ClassMethods.ssl_ca_file.
# * :+ssl_ca_path+: see HTTParty::ClassMethods.ssl_ca_path.
# * :+ssl_version+: SSL versions to allow. see method 'attach_ssl_certificates'
# * :+ciphers+: The list of SSL ciphers to support
# * :+connection_adapter_options+: contains the hash you passed to HTTParty.connection_adapter when you configured your connection adapter
# * :+local_host+: The local address to bind to
# * :+local_port+: The local port to bind to
# * :+http_proxyaddr+: HTTP Proxy address
# * :+http_proxyport+: HTTP Proxy port
# * :+http_proxyuser+: HTTP Proxy user
# * :+http_proxypass+: HTTP Proxy password
#
# === Inherited methods
# * :+clean_host+: Method used to sanitize host names
#
# @example log the uri and options
#   class LoggingConnectionAdapter < HTTParty::ConnectionAdapter
#   def connection
#   puts uri
#   puts options
#   Net::HTTP.new(uri)
#   end
#   end
# @example count number of http calls
#   class CountingConnectionAdapter < HTTParty::ConnectionAdapter
#   @@count = 0
#
#   self.count
#   @@count
#   end
#
#   def connection
#   self.count += 1
#   super
#   end
#   end
class HTTParty::ConnectionAdapter
  # @raise [ArgumentError]
  # @return [ConnectionAdapter] a new instance of ConnectionAdapter
  def initialize(uri, options = T.unsafe(nil)); end

  def connection; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute uri.
  def uri; end

  private

  # @return [Boolean]
  def add_max_retries?(max_retries); end

  # @return [Boolean]
  def add_timeout?(timeout); end

  def attach_ssl_certificates(http, options); end
  def clean_host(host); end
  def from_ruby_version(ruby_version, option: T.unsafe(nil), warn: T.unsafe(nil)); end

  # @return [Boolean]
  def ssl_implied?(uri); end

  def strip_ipv6_brackets(host); end

  # @return [Boolean]
  def verify_ssl_certificate?; end

  class << self
    # Public
    def call(uri, options); end

    def default_cert_store; end
  end
end

HTTParty::ConnectionAdapter::OPTION_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Private: Regex used to strip brackets from IPv6 URIs.
HTTParty::ConnectionAdapter::StripIpv6BracketsRegex = T.let(T.unsafe(nil), Regexp)

class HTTParty::CookieHash < ::Hash
  def add_cookies(data); end
  def to_cookie_string; end
end

HTTParty::CookieHash::CLIENT_COOKIES = T.let(T.unsafe(nil), Array)

# Decompresses the response body based on the Content-Encoding header.
#
# Net::HTTP automatically decompresses Content-Encoding values "gzip" and "deflate".
# This class will handle "br" (Brotli) and "compress" (LZW) if the requisite
# gems are installed. Otherwise, it returns nil if the body data cannot be
# decompressed.
#
# @abstract Read the HTTP Compression section for more information.
class HTTParty::Decompressor
  # @param body [String] - the response body of the request
  # @param encoding [Symbol] - the Content-Encoding algorithm used to encode the body
  # @return [Decompressor] a new instance of Decompressor
  def initialize(body, encoding); end

  # The response body of the request
  #
  # @return [String]
  def body; end

  # Perform decompression on the response body
  #
  # @return [String] the decompressed body
  # @return [nil] when the response body is nil or cannot decompressed
  def decompress; end

  # The Content-Encoding algorithm used to encode the body
  #
  # @return [Symbol] e.g. :gzip
  def encoding; end

  protected

  def brotli; end
  def decompress_supported_encoding; end
  def lzw; end
  def none; end

  # @return [Boolean]
  def supports_encoding?; end
end

# "gzip" and "deflate" are handled by Net::HTTP
# hence they do not need to be handled by HTTParty
HTTParty::Decompressor::SupportedEncodings = T.let(T.unsafe(nil), Hash)

# Exception that is raised when request redirects and location header is present more than once
class HTTParty::DuplicateLocationHeader < ::HTTParty::ResponseError; end

# @abstract Exceptions raised by HTTParty inherit from Error
class HTTParty::Error < ::StandardError; end

module HTTParty::HashConversions
  class << self
    def normalize_keys(key, value); end

    # @example normalize_param(:name, "Bob Jones") #=> "name=Bob%20Jones&"
    # @param key [Object] The key for the param.
    # @param value [Object] The value for the param.
    # @return [String] This key value pair as a param
    def normalize_param(key, value); end

    # @example
    #   { name: "Bob",
    #   address: {
    #   street: '111 Ruby Ave.',
    #   city: 'Ruby Central',
    #   phones: ['111-111-1111', '222-222-2222']
    #   }
    #   }.to_params
    #   #=> "name=Bob&address[city]=Ruby Central&address[phones][]=111-111-1111&address[phones][]=222-222-2222&address[street]=111 Ruby Ave."
    # @return [String] This hash as a query string
    def to_params(hash); end
  end
end

class HTTParty::HeadersProcessor
  # @return [HeadersProcessor] a new instance of HeadersProcessor
  def initialize(headers, options); end

  def call; end

  # Returns the value of attribute headers.
  def headers; end

  # Returns the value of attribute options.
  def options; end

  private

  def process_dynamic_headers; end
end

module HTTParty::Logger
  class << self
    # @raise [HTTParty::Error]
    def add_formatter(name, formatter); end

    def build(logger, level, formatter); end
    def formatters; end
  end
end

class HTTParty::Logger::ApacheFormatter
  # @return [ApacheFormatter] a new instance of ApacheFormatter
  def initialize(logger, level); end

  def format(request, response); end

  # Returns the value of attribute level.
  def level; end

  # Sets the attribute level
  #
  # @param value the value to set the attribute level to.
  def level=(_arg0); end

  # Returns the value of attribute logger.
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  def logger=(_arg0); end

  private

  def content_length; end
  def current_time; end
  def http_method; end
  def message; end
  def path; end

  # Returns the value of attribute request.
  def request; end

  # Returns the value of attribute response.
  def response; end
end

HTTParty::Logger::ApacheFormatter::TAG_NAME = T.let(T.unsafe(nil), String)

class HTTParty::Logger::CurlFormatter
  # @return [CurlFormatter] a new instance of CurlFormatter
  def initialize(logger, level); end

  def format(request, response); end

  # Returns the value of attribute level.
  def level; end

  # Sets the attribute level
  #
  # @param value the value to set the attribute level to.
  def level=(_arg0); end

  # Returns the value of attribute logger.
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  def logger=(_arg0); end

  private

  def current_time; end
  def log(direction, line = T.unsafe(nil)); end
  def log_hash(hash); end
  def log_headers; end
  def log_query; end
  def log_request; end
  def log_response; end
  def log_response_headers; end
  def log_url; end

  # Returns the value of attribute messages.
  def messages; end

  # Sets the attribute messages
  #
  # @param value the value to set the attribute messages to.
  def messages=(_arg0); end

  # Returns the value of attribute request.
  def request; end

  # Returns the value of attribute response.
  def response; end
end

HTTParty::Logger::CurlFormatter::IN = T.let(T.unsafe(nil), String)
HTTParty::Logger::CurlFormatter::OUT = T.let(T.unsafe(nil), String)
HTTParty::Logger::CurlFormatter::TAG_NAME = T.let(T.unsafe(nil), String)

class HTTParty::Logger::LogstashFormatter
  # @return [LogstashFormatter] a new instance of LogstashFormatter
  def initialize(logger, level); end

  def format(request, response); end

  # Returns the value of attribute level.
  def level; end

  # Sets the attribute level
  #
  # @param value the value to set the attribute level to.
  def level=(_arg0); end

  # Returns the value of attribute logger.
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  def logger=(_arg0); end

  private

  def content_length; end
  def current_time; end
  def http_method; end
  def logstash_message; end
  def message; end
  def path; end

  # Returns the value of attribute request.
  def request; end

  # Returns the value of attribute response.
  def response; end
end

HTTParty::Logger::LogstashFormatter::TAG_NAME = T.let(T.unsafe(nil), String)

module HTTParty::ModuleInheritableAttributes
  mixes_in_class_methods ::HTTParty::ModuleInheritableAttributes::ClassMethods

  class << self
    # borrowed from Rails 3.2 ActiveSupport
    def hash_deep_dup(hash); end

    # @private
    def included(base); end
  end
end

module HTTParty::ModuleInheritableAttributes::ClassMethods
  def inherited(subclass); end
  def mattr_inheritable(*args); end
end

# The default parser used by HTTParty, supports xml, json, html, csv and
# plain text.
#
# == Custom Parsers
#
# If you'd like to do your own custom parsing, subclassing HTTParty::Parser
# will make that process much easier. There are a few different ways you can
# utilize HTTParty::Parser as a superclass.
#
# @abstract Read the Custom Parsers section for more information.
# @example Intercept the parsing for all formats
#   class SimpleParser < HTTParty::Parser
#   def parse
#   perform_parsing
#   end
#   end
# @example Add the atom format and parsing method to the default parser
#   class AtomParsingIncluded < HTTParty::Parser
#   SupportedFormats.merge!(
#   {"application/atom+xml" => :atom}
#   )
#
#   def atom
#   perform_atom_parsing
#   end
#   end
# @example Only support the atom format
#   class ParseOnlyAtom < HTTParty::Parser
#   SupportedFormats = {"application/atom+xml" => :atom}
#
#   def atom
#   perform_atom_parsing
#   end
#   end
class HTTParty::Parser
  # @return [Parser] a new instance of Parser
  def initialize(body, format); end

  # The response body of the request
  #
  # @return [String]
  def body; end

  # The intended parsing format for the request
  #
  # @return [Symbol] e.g. :json
  def format; end

  # @return [Object] the parsed body
  # @return [nil] when the response body is nil, an empty string, spaces only or "null"
  def parse; end

  protected

  def csv; end
  def html; end
  def json; end
  def parse_supported_format; end
  def plain; end

  # @return [Boolean]
  def supports_format?; end

  def xml; end

  class << self
    # Instantiate the parser and call {#parse}.
    #
    # @param body [String] the response body
    # @param format [Symbol] the response format
    # @return parsed response
    def call(body, format); end

    # @param mimetype [String] response MIME type
    # @return [Symbol]
    # @return [nil] mime type not supported
    def format_from_mimetype(mimetype); end

    # @return [Hash] the SupportedFormats hash
    def formats; end

    # @return [Array<Symbol>] list of supported formats
    def supported_formats; end

    # @param format [Symbol] e.g. :json, :xml
    # @return [Boolean]
    def supports_format?(format); end
  end
end

HTTParty::Parser::SupportedFormats = T.let(T.unsafe(nil), Hash)
HTTParty::Parser::UTF8_BOM = T.let(T.unsafe(nil), String)

# Exception that is raised when request has redirected too many times.
# Calling {#response} returns the Net:HTTP response object.
class HTTParty::RedirectionTooDeep < ::HTTParty::ResponseError; end

class HTTParty::Request
  # @return [Request] a new instance of Request
  def initialize(http_method, path, o = T.unsafe(nil)); end

  def _dump(_level); end
  def base_uri; end
  def connection_adapter; end
  def format; end
  def handle_unauthorized(&block); end

  # Returns the value of attribute http_method.
  def http_method; end

  # Sets the attribute http_method
  #
  # @param value the value to set the attribute http_method to.
  def http_method=(_arg0); end

  # Returns the value of attribute last_response.
  def last_response; end

  # Sets the attribute last_response
  #
  # @param value the value to set the attribute last_response to.
  def last_response=(_arg0); end

  # Returns the value of attribute last_uri.
  def last_uri; end

  # Sets the attribute last_uri
  #
  # @param value the value to set the attribute last_uri to.
  def last_uri=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  def options=(_arg0); end

  def parser; end

  # Returns the value of attribute path.
  def path; end

  def path=(uri); end
  def perform(&block); end
  def raw_body; end

  # Returns the value of attribute redirect.
  def redirect; end

  # Sets the attribute redirect
  #
  # @param value the value to set the attribute redirect to.
  def redirect=(_arg0); end

  def request_uri(uri); end
  def uri; end

  private

  def assume_utf16_is_big_endian; end
  def capture_cookies(response); end
  def check_duplicate_location_header; end
  def credentials; end
  def decompress(body, encoding); end

  # @return [Boolean]
  def decompress_content?; end

  # @return [Boolean]
  def digest_auth?; end

  def encode_text(text, content_type); end

  # Uses the HTTP Content-Type header to determine the format of the
  # response It compares the MIME type returned to the types stored in the
  # SupportedFormats hash
  def format_from_mimetype(mimetype); end

  def handle_host_redirection; end
  def handle_response(raw_body, &block); end
  def http; end
  def normalize_query(query); end
  def parse_response(body); end
  def password; end

  # @return [Boolean]
  def post?; end

  def query_string(uri); end
  def query_string_normalizer; end

  # @return [Boolean]
  def response_has_digest_auth_challenge?; end

  # @return [Boolean]
  def response_redirects?; end

  # @return [Boolean]
  def response_unauthorized?; end

  # @return [Boolean]
  def send_authorization_header?; end

  def set_basic_auth_from_uri; end
  def setup_digest_auth; end
  def setup_raw_request; end
  def username; end

  # @raise [HTTParty::RedirectionTooDeep.new(last_response)]
  def validate; end

  class << self
    def _load(data); end
  end
end

class HTTParty::Request::Body
  # @return [Body] a new instance of Body
  def initialize(params, query_string_normalizer: T.unsafe(nil), force_multipart: T.unsafe(nil)); end

  def boundary; end
  def call; end

  # @return [Boolean]
  def multipart?; end

  private

  def content_body(object); end
  def content_type(object); end

  # @return [Boolean]
  def file?(object); end

  def file_name(object); end

  # Returns the value of attribute force_multipart.
  def force_multipart; end

  def generate_multipart; end

  # @return [Boolean]
  def has_file?(value); end

  def normalize_query(query); end

  # Returns the value of attribute params.
  def params; end

  # Returns the value of attribute query_string_normalizer.
  def query_string_normalizer; end
end

HTTParty::Request::Body::NEWLINE = T.let(T.unsafe(nil), String)
HTTParty::Request::JSON_API_QUERY_STRING_NORMALIZER = T.let(T.unsafe(nil), Proc)

class HTTParty::Request::MultipartBoundary
  class << self
    def generate; end
  end
end

HTTParty::Request::NON_RAILS_QUERY_STRING_NORMALIZER = T.let(T.unsafe(nil), Proc)
HTTParty::Request::SupportedHTTPMethods = T.let(T.unsafe(nil), Array)
HTTParty::Request::SupportedURISchemes = T.let(T.unsafe(nil), Array)

class HTTParty::Response
  # @return [Response] a new instance of Response
  def initialize(request, response, parsed_block, options = T.unsafe(nil)); end

  def _dump(_level); end
  def accepted?; end
  def already_reported?; end
  def bad_gateway?; end
  def bad_request?; end

  # Returns the value of attribute body.
  def body; end

  def client_error?; end
  def code; end
  def conflict?; end
  def continue?; end
  def created?; end
  def display(port = T.unsafe(nil)); end
  def early_hints?; end
  def expectation_failed?; end
  def failed_dependency?; end
  def forbidden?; end
  def found?; end
  def gateway_time_out?; end
  def gateway_timeout?; end
  def gone?; end

  # Returns the value of attribute headers.
  def headers; end

  def http_version; end
  def im_used?; end
  def information?; end
  def inspect; end
  def insufficient_storage?; end
  def internal_server_error?; end
  def length_required?; end
  def locked?; end
  def loop_detected?; end
  def method_not_allowed?; end
  def misdirected_request?; end
  def moved_permanently?; end
  def multi_status?; end
  def multiple_choice?; end
  def multiple_choices?; end
  def network_authentication_required?; end

  # @return [Boolean]
  def nil?; end

  def no_content?; end
  def non_authoritative_information?; end
  def not_acceptable?; end
  def not_extended?; end
  def not_found?; end
  def not_implemented?; end
  def not_modified?; end
  def ok?; end
  def parsed_response; end
  def partial_content?; end
  def payload_too_large?; end
  def payment_required?; end
  def permanent_redirect?; end
  def precondition_failed?; end
  def precondition_required?; end
  def pretty_print(pp); end
  def processing?; end
  def proxy_authentication_required?; end
  def range_not_satisfiable?; end
  def redirection?; end

  # Returns the value of attribute request.
  def request; end

  def request_entity_too_large?; end
  def request_header_fields_too_large?; end
  def request_time_out?; end
  def request_timeout?; end
  def request_uri_too_long?; end
  def requested_range_not_satisfiable?; end
  def reset_content?; end

  # Returns the value of attribute response.
  def response; end

  def see_other?; end
  def server_error?; end
  def service_unavailable?; end
  def success?; end
  def switch_protocol?; end

  # @yield [_self]
  # @yieldparam _self [HTTParty::Response] the object that the method was called on
  def tap; end

  def temporary_redirect?; end
  def to_s; end
  def too_many_requests?; end
  def unauthorized?; end
  def unavailable_for_legal_reasons?; end
  def unprocessable_entity?; end
  def unsupported_media_type?; end
  def upgrade_required?; end
  def uri_too_long?; end
  def use_proxy?; end
  def variant_also_negotiates?; end
  def version_not_supported?; end

  protected

  def method_missing(name, *args, &block); end
  def throw_exception; end

  private

  # @return [Boolean]
  def respond_to_missing?(name, *args); end

  def warn_about_nil_deprecation; end

  class << self
    def _load(data); end
    def underscore(string); end
  end
end

HTTParty::Response::CODES_TO_OBJ = T.let(T.unsafe(nil), Hash)

class HTTParty::Response::Headers < ::SimpleDelegator
  include ::Net::HTTPHeader

  # @return [Headers] a new instance of Headers
  def initialize(header_values = T.unsafe(nil)); end

  def ==(other); end
end

# response object accessible via the {#response} method.
#
# @abstract Exceptions which inherit from ResponseError contain the Net::HTTP
class HTTParty::ResponseError < ::HTTParty::Error
  # Instantiate an instance of ResponseError with a Net::HTTPResponse object
  #
  # @param [Net::HTTPResponse]
  # @return [ResponseError] a new instance of ResponseError
  def initialize(response); end

  # Returns the response of the last request
  # Net::HTTPOK
  #
  # @return [Net::HTTPResponse] A subclass of Net::HTTPResponse, e.g.
  def response; end
end

# Allow access to http_response and code by delegation on fragment
class HTTParty::ResponseFragment < ::SimpleDelegator
  # @return [ResponseFragment] a new instance of ResponseFragment
  def initialize(fragment, http_response, connection); end

  def code; end

  # Returns the value of attribute connection.
  def connection; end

  # Returns the value of attribute http_response.
  def http_response; end
end

class HTTParty::TextEncoder
  # @return [TextEncoder] a new instance of TextEncoder
  def initialize(text, assume_utf16_is_big_endian: T.unsafe(nil), content_type: T.unsafe(nil)); end

  # Returns the value of attribute assume_utf16_is_big_endian.
  def assume_utf16_is_big_endian; end

  def call; end

  # Returns the value of attribute content_type.
  def content_type; end

  # Returns the value of attribute text.
  def text; end

  private

  # @return [Boolean]
  def can_encode?; end

  def charset; end
  def encode_utf_16; end
  def encode_with_ruby_encoding; end
  def encoded_text; end
end

# Exception raised when you attempt to set a non-existent format
class HTTParty::UnsupportedFormat < ::HTTParty::Error; end

# Exception raised when using a URI scheme other than HTTP or HTTPS
class HTTParty::UnsupportedURIScheme < ::HTTParty::Error; end

module HTTParty::Utils
  class << self
    def stringify_keys(hash); end
  end
end

HTTParty::VERSION = T.let(T.unsafe(nil), String)

module Net::HTTPHeader
  def digest_auth(username, password, response); end
end

class Net::HTTPHeader::DigestAuthenticator
  # @return [DigestAuthenticator] a new instance of DigestAuthenticator
  def initialize(username, password, method, path, response_header); end

  def authorization_header; end
  def cookie_header; end

  private

  def a1; end
  def a2; end

  # @return [Boolean]
  def algorithm_present?; end

  def md5(str); end

  # @return [Boolean]
  def opaque_present?; end

  def parse(response_header); end
  def parse_cookies(response_header); end

  # @return [Boolean]
  def qop_present?; end

  def random; end
  def request_digest; end

  # @return [Boolean]
  def use_md5_sess?; end
end
