# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-types` gem.
# Please instead update this file by running `bin/tapioca gem dry-types`.

# Main library namespace
#
# @api public
module Dry
  class << self
    # Build an equalizer module for the inclusion in other class
    #
    # ## Credits
    #
    # Equalizer has been originally imported from the equalizer gem created by Dan Kubb
    #
    # @api public
    def Equalizer(*keys, **options); end

    # Constructor method for easily creating a {Dry::Struct}.
    #
    # @example
    #   require 'dry-struct'
    #
    #   module Types
    #   include Dry.Types()
    #   end
    #
    #   Person = Dry.Struct(name: Types::String, age: Types::Integer)
    #   matz = Person.new(name: "Matz", age: 52)
    #   matz.name #=> "Matz"
    #   matz.age #=> 52
    #
    #   Test = Dry.Struct(expected: Types::String) { schema(schema.strict) }
    #   Test[expected: "foo", unexpected: "bar"]
    #   #=> Dry::Struct::Error: [Test.new] unexpected keys [:unexpected] in Hash input
    # @return [Dry::Struct]
    def Struct(attributes = T.unsafe(nil), &block); end

    # Export registered types as a module with constants
    #
    # @api public
    # @example no options
    #
    #   module Types
    #   # imports all types as constants, uses modules for namespaces
    #   include Dry::Types()
    #   end
    #   # strict types are exported by default
    #   Types::Integer
    #   # => #<Dry::Types[Constrained<Nominal<Integer> rule=[type?(Integer)]>]>
    #   Types::Nominal::Integer
    #   # => #<Dry::Types[Nominal<Integer>]>
    # @example changing default types
    #
    #   module Types
    #   include Dry::Types(default: :nominal)
    #   end
    #   Types::Integer
    #   # => #<Dry::Types[Nominal<Integer>]>
    # @example cherry-picking namespaces
    #
    #   module Types
    #   include Dry::Types(:strict, :coercible)
    #   end
    #   # cherry-picking discards default types,
    #   # provide the :default option along with the list of
    #   # namespaces if you want the to be exported
    #   Types.constants # => [:Coercible, :Strict]
    # @example custom names
    #   module Types
    #   include Dry::Types(coercible: :Kernel)
    #   end
    #   Types::Kernel::Integer
    #   # => #<Dry::Types[Constructor<Nominal<Integer> fn=Kernel.Integer>]>
    # @param namespaces [Array<Symbol>] List of type namespaces to export
    # @param default [Symbol] Default namespace to export
    # @param aliases [Hash{Symbol => Symbol}] Optional renamings, like strict: :Draconian
    # @return [Dry::Types::Module]
    # @see Dry::Types::Module
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# @api public
# @see Dry.Types
module Dry::Types
  include ::Dry::Core::Constants
  extend ::Dry::Core::Deprecations::Interface
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::Dry::Core::Extensions

  class << self
    # @api public
    # @param options [Hash]
    # @return [Dry::Logic::Rule]
    def Rule(options); end

    # Get a built-in type by its name
    #
    # @api public
    # @param name [String, Class]
    # @return [Type, Class]
    def [](name); end

    # @api private
    def const_missing(const); end

    # Return container with registered built-in type objects
    #
    # @api private
    # @return [Container{String => Nominal}]
    def container; end

    # Add a new type builder method. This is a public API for defining custom
    # type constructors
    #
    # @api public
    # @example simple custom type constructor
    #   Dry::Types.define_builder(:or_nil) do |type|
    #   type.optional.fallback(nil)
    #   end
    #
    #   Dry::Types["integer"].or_nil.("foo") # => nil
    # @example fallback alias
    #   Dry::Types.define_builder(:or) do |type, fallback|
    #   type.fallback(fallback)
    #   end
    #
    #   Dry::Types["integer"].or(100).("foo") # => 100
    # @param method [Symbol]
    # @param block [#call]
    def define_builder(method, &block); end

    # Infer a type identifier from the provided class
    #
    # @api public
    # @param klass [#to_s]
    # @return [String]
    def identifier(klass); end

    # @api private
    # @private
    def included(*_arg0); end

    # @api public
    def module(*args, &block); end

    # Register a new built-in type
    #
    # @api private
    # @param name [String]
    # @param type [Type]
    # @param block [#call, nil]
    # @return [Container{String => Nominal}]
    def register(name, type = T.unsafe(nil), &block); end

    # Check if a give type is registered
    #
    # @api private
    # @return [Boolean]
    def registered?(class_or_identifier); end

    # @api private
    # @return [Dry::Logic::RuleCompiler]
    def rule_compiler; end

    # Cached type map
    #
    # @api private
    # @return [Concurrent::Map]
    def type_map; end
  end
end

# All built-in primitives
#
# @api public
Dry::Types::ALL_PRIMITIVES = T.let(T.unsafe(nil), Hash)

Dry::Types::Any = T.let(T.unsafe(nil), Dry::Types::AnyClass)

# Any is a nominal type that defines Object as the primitive class
#
# This type is useful in places where you can't be specific about the type
# and anything is acceptable.
#
# @api public
class Dry::Types::AnyClass < ::Dry::Types::Nominal
  # @api private
  # @return [AnyClass] a new instance of AnyClass
  def initialize(**options); end

  # @api public
  # @return [String]
  def name; end

  # @api public
  # @return [Array]
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param new_options [Hash]
  # @return [Type]
  def with(**new_options); end

  class << self
    # @api public
    def name; end
  end
end

# Array type can be used to define an array with optional member type
#
# @api public
class Dry::Types::Array < ::Dry::Types::Nominal
  # @api private
  def constructor_type; end

  # Build an array type with a member type
  #
  # @api public
  # @param type [Type, #call]
  # @return [Array::Member]
  def of(type); end
end

# @api private
class Dry::Types::Array::Constructor < ::Dry::Types::Constructor
  # @api private
  def constructor_type; end

  # @api public
  # @return [Lax]
  def lax; end

  # @api public
  # @see Dry::Types::Array#of
  def of(member); end
end

# Member arrays define their member type that is applied to each element
#
# @api public
class Dry::Types::Array::Member < ::Dry::Types::Array
  # @api private
  # @option options
  # @param primitive [Class]
  # @param options [Hash]
  # @return [Member] a new instance of Member
  def initialize(primitive, **options); end

  # @api private
  # @param input [Object]
  # @return [Array]
  def call_safe(input); end

  # @api private
  # @param input [Object]
  # @return [Array]
  def call_unsafe(input); end

  # @api private
  def constructor_type; end

  # Build a lax type
  #
  # @api public
  # @return [Lax]
  def lax; end

  # @api public
  # @return [Type]
  def member; end

  # @api public
  # @see Nominal#to_ast
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param input [Array, Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  def try(input, &block); end
end

# Common API for building types and composition
#
# @api public
module Dry::Types::Builder
  include ::Dry::Core::Constants

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def <<(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def append(constructor = T.unsafe(nil), **options, &block); end

  # Turn a type into a constrained type
  #
  # @api public
  # @param options [Hash] constraining rule (see {Types.Rule})
  # @return [Constrained]
  def constrained(options); end

  # @api private
  # @return [Class]
  def constrained_type; end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Class]
  def constructor_type; end

  # Turn a type into a type with a default value
  #
  # @api public
  # @option [Boolean]
  # @param input [Object]
  # @param block [#call, nil]
  # @param [Boolean] [Hash] a customizable set of options
  # @raise [ConstraintError]
  # @return [Default]
  def default(input = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Define an enum on top of the existing type
  #
  # @api public
  # @param values [Array]
  # @return [Enum]
  def enum(*values); end

  # Use the given value on type mismatch
  #
  # @api public
  # @option [Boolean]
  # @param value [Object]
  # @param fallback [#call, nil]
  # @param [Boolean] [Hash] a customizable set of options
  # @return [Constructor]
  def fallback(value = T.unsafe(nil), shared: T.unsafe(nil), &_fallback); end

  # Turn a type into a lax type that will rescue from type-errors and
  # return the original input
  #
  # @api public
  # @return [Lax]
  def lax; end

  # Turn a type into an optional type
  #
  # @api public
  # @return [Sum]
  def optional; end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def prepend(constructor = T.unsafe(nil), **options, &block); end

  # Compose two types into a Sum type
  #
  # @api private
  # @param other [Type]
  # @return [Sum, Sum::Constrained]
  def |(other); end
end

Dry::Types::Builder::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Types::Builder::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Types::Builder::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Types::Builder::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Types::Builder::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Types::Builder::IDENTITY = T.let(T.unsafe(nil), Proc)
Dry::Types::Builder::Self = T.let(T.unsafe(nil), Proc)
Dry::Types::Builder::Undefined = T.let(T.unsafe(nil), Object)

# Common API for building type objects in a convenient way
#
# @api public
module Dry::Types::BuilderMethods
  # Build an array type.
  #
  # Shortcut for Array#of.
  #
  # @api public
  # @example
  #   Types::Strings = Types.Array(Types::String)
  # @param type [Dry::Types::Type]
  # @return [Dry::Types::Array]
  def Array(type); end

  # Build a type with a single value
  # The equality check done with `equal?`
  #
  # @api public
  # @param object [Object]
  # @return [Dry::Types::Type]
  def Constant(object); end

  # Build a constructor type
  # If no constructor block given it uses .new method
  #
  # @api public
  # @param klass [Class]
  # @param cons [#call, nil] Value constructor
  # @param block [#call, nil] Value constructor
  # @return [Dry::Types::Type]
  def Constructor(klass, cons = T.unsafe(nil), &block); end

  # Build a hash schema
  #
  # @api public
  # @param type_map [Hash{Symbol => Dry::Types::Type}]
  # @return [Dry::Types::Array]
  def Hash(type_map); end

  # Build a type which values are instances of a given class
  # Values are checked using `is_a?` call
  #
  # @api public
  # @example
  #   Types::Error = Types.Instance(StandardError)
  #   Types::Error = Types.Strict(StandardError)
  #   Types.Strict(Integer) == Types::Strict::Int # => true
  # @param klass [Class, Module] Class or module
  # @return [Dry::Types::Type]
  def Instance(klass); end

  # Builds a constrained nominal type accepting any value that
  # responds to given methods
  #
  # @api public
  # @example
  #   Types::Callable = Types.Interface(:call)
  #   Types::Contact = Types.Interface(:name, :address)
  # @param methods [Array<String, Symbol>] Method names
  # @return [Dry::Types::Contrained]
  def Interface(*methods); end

  # Build a map type
  #
  # @api public
  # @example
  #   Types::IntMap = Types.Map(Types::Strict::Integer, 'any')
  #   Types::IntStringMap = Types.Map(Types::Strict::Integer, Types::Strict::String)
  # @param key_type [Type] Key type
  # @param value_type [Type] Value type
  # @return [Dry::Types::Map]
  def Map(key_type, value_type); end

  # Build a nominal type
  #
  # @api public
  # @param klass [Class]
  # @return [Dry::Types::Type]
  def Nominal(klass); end

  # Build a type which values are instances of a given class
  # Values are checked using `is_a?` call
  #
  # @api public
  # @example
  #   Types::Error = Types.Instance(StandardError)
  #   Types::Error = Types.Strict(StandardError)
  #   Types.Strict(Integer) == Types::Strict::Int # => true
  # @param klass [Class, Module] Class or module
  # @return [Dry::Types::Type]
  def Strict(klass); end

  # Build a type with a single value
  # The equality check done with `eql?`
  #
  # @api public
  # @param value [Object]
  # @return [Dry::Types::Type]
  def Value(value); end

  # @api private
  def included(base); end
end

# All coercible types
#
# @api public
Dry::Types::COERCIBLE = T.let(T.unsafe(nil), Hash)

# Base class for coercion errors raise by dry-types
#
# @api public
class Dry::Types::CoercionError < ::StandardError
  # @api private
  # @return [CoercionError] a new instance of CoercionError
  def initialize(message, meta: T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # Metadata associated with the error
  #
  # @api public
  # @return [Object]
  def meta; end

  class << self
    # @api private
    def handle(exception, meta: T.unsafe(nil)); end
  end
end

# Common coercion functions used by the built-in `Params` and `JSON` types
#
# @api public
module Dry::Types::Coercions
  include ::Dry::Core::Constants

  # @api public
  # @param input [#to_str, Object]
  # @return [Date, Object]
  # @see Date.parse
  def to_date(input, &block); end

  # @api public
  # @param input [#to_str, Object]
  # @return [DateTime, Object]
  # @see DateTime.parse
  def to_date_time(input, &block); end

  # @api public
  # @param input [#to_sym, Object]
  # @raise CoercionError
  # @return [Symbol, Object]
  def to_symbol(input, &block); end

  # @api public
  # @param input [#to_str, Object]
  # @return [Time, Object]
  # @see Time.parse
  def to_time(input, &block); end

  private

  # Checks whether String is empty
  #
  # @api private
  # @param value [String, Object]
  # @return [Boolean]
  def empty_str?(value); end
end

Dry::Types::Coercions::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Types::Coercions::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Types::Coercions::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Types::Coercions::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Types::Coercions::EMPTY_STRING = T.let(T.unsafe(nil), String)
Dry::Types::Coercions::IDENTITY = T.let(T.unsafe(nil), Proc)

# JSON-specific coercions
#
# @api public
module Dry::Types::Coercions::JSON
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # @api public
    # @param input [#to_d, Object]
    # @raise CoercionError
    # @return [BigDecimal, nil]
    def to_decimal(input, &_block); end

    # @api public
    # @param input [Object]
    # @raise CoercionError
    # @return [nil] if the input is nil
    def to_nil(input, &_block); end
  end
end

# Params-specific coercions
#
# @api public
module Dry::Types::Coercions::Params
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # @api public
    # @param input [Array, String, Object]
    # @raise CoercionError
    # @return [Array, Object]
    def to_ary(input, &_block); end

    # @api public
    # @param input [#to_d, Object]
    # @raise CoercionError
    # @return [BigDecimal, nil, Object]
    def to_decimal(input, &_block); end

    # @api public
    # @param input [String, Object]
    # @raise CoercionError
    # @return [Boolean, Object]
    # @see TRUE_VALUES
    # @see FALSE_VALUES
    def to_false(input, &_block); end

    # @api public
    # @param input [#to_f, Object]
    # @raise CoercionError
    # @return [Float, nil, Object]
    def to_float(input, &block); end

    # @api public
    # @param input [Hash, String, Object]
    # @raise CoercionError
    # @return [Hash, Object]
    def to_hash(input, &_block); end

    # @api public
    # @param input [#to_int, #to_i, Object]
    # @raise CoercionError
    # @return [Integer, nil, Object]
    def to_int(input, &block); end

    # @api public
    # @param input [Object]
    # @raise CoercionError
    # @return [nil] if the input is an empty string or nil
    def to_nil(input, &_block); end

    # @api public
    # @param input [String, Object]
    # @raise CoercionError
    # @return [Boolean, Object]
    # @see TRUE_VALUES
    # @see FALSE_VALUES
    def to_true(input, &_block); end
  end
end

# @api public
Dry::Types::Coercions::Params::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)

# @api public
Dry::Types::Coercions::Params::FALSE_VALUES = T.let(T.unsafe(nil), Array)

# @api public
Dry::Types::Coercions::Params::TRUE_VALUES = T.let(T.unsafe(nil), Array)

Dry::Types::Coercions::Self = T.let(T.unsafe(nil), Proc)
Dry::Types::Coercions::Undefined = T.let(T.unsafe(nil), Object)

# @api private
class Dry::Types::Compiler
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Compiler] a new instance of Compiler
  def initialize(registry); end

  # @api private
  def call(ast); end

  # @api private
  def compile_fn(fn); end

  # @api private
  def registry; end

  # @api private
  def visit(node); end

  # @api private
  def visit_any(meta); end

  # @api private
  def visit_array(node); end

  # @api private
  def visit_constrained(node); end

  # @api private
  def visit_constructor(node); end

  # @api private
  def visit_enum(node); end

  # @api private
  def visit_hash(node); end

  # @api private
  def visit_json_array(node); end

  # @api private
  def visit_json_hash(node); end

  # @api private
  def visit_key(node); end

  # @api private
  def visit_lax(node); end

  # @api private
  def visit_map(node); end

  # @api private
  def visit_nominal(node); end

  # @api private
  def visit_params_array(node); end

  # @api private
  def visit_params_hash(node); end

  # @api private
  def visit_rule(node); end

  def visit_safe(*args, &block); end

  # @api private
  def visit_schema(node); end

  # @api private
  def visit_sum(node); end
end

# Constrained types apply rules to the input
#
# @api public
class Dry::Types::Constrained
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param type [Type]
  # @param options [Hash]
  # @return [Constrained] a new instance of Constrained
  def initialize(type, **options); end

  # @api public
  # @param value [Object]
  # @return [Boolean]
  def ===(value); end

  # @api private
  # @return [Object]
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  def call_unsafe(input); end

  # @api public
  # @param options [Hash] The options hash provided to {Types.Rule} and combined
  #   using {&} with previous {#rule}
  # @return [Constrained]
  # @see Dry::Logic::Operators#and
  def constrained(options); end

  # @api public
  # @return [true]
  def constrained?; end

  # @api private
  def constructor_type; end

  # Build lax type. Constraints are not applicable to lax types hence unwrapping
  #
  # @api public
  # @return [Lax]
  def lax; end

  # @api public
  # @return [Dry::Logic::Rule]
  def rule; end

  # @api public
  # @see Nominal#to_ast
  def to_ast(meta: T.unsafe(nil)); end

  # Safe coercion attempt. It is similar to #call with a
  # block given but returns a Result instance with metadata
  # about errors (if any).
  #
  # @api public
  # @overload try
  # @overload try
  def try(input, &block); end

  private

  # @api private
  # @param response [Object]
  # @return [Boolean]
  def decorate?(response); end
end

# Common coercion-related API for constrained types
#
# @api public
class Dry::Types::Constrained::Coercible < ::Dry::Types::Constrained
  # @api private
  # @return [Object]
  def call_safe(input); end

  # @api private
  # @return [Object]
  def call_unsafe(input); end

  # @api public
  # @see Dry::Types::Constrained#try
  def try(input, &block); end
end

# @api public
class Dry::Types::ConstraintError < ::Dry::Types::CoercionError
  # @api public
  # @param result [String, #to_s]
  # @param input [Object]
  # @return [ConstraintError] a new instance of ConstraintError
  def initialize(result, input); end

  # @api public
  # @return [Object]
  def input; end

  # @api public
  # @return [String]
  def message; end

  # @api public
  # @return [String, #to_s]
  def result; end

  # @api public
  # @return [String]
  def to_s; end
end

# Constructor types apply a function to the input that is supposed to return
# a new value. Coercion is a common use case for constructor types.
#
# @api public
class Dry::Types::Constructor < ::Dry::Types::Nominal
  # Instantiate a new constructor type instance
  #
  # @api private
  # @param type [Type]
  # @param fn [Function]
  # @param options [Hash]
  # @return [Constructor] a new instance of Constructor
  def initialize(type, fn: T.unsafe(nil), **options); end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def >>(new_fn = T.unsafe(nil), **options, &block); end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def append(new_fn = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Object]
  def call_safe(input); end

  # @api private
  # @return [Object]
  def call_unsafe(input); end

  # @api private
  # @return [Class]
  def constrained_type; end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def constructor(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @return [#call]
  def fn; end

  # Build a lax type
  #
  # @api public
  # @return [Lax]
  def lax; end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @see Nominal#to_ast
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  def to_proc; end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Logic::Result, Types::Result]
  # @return [Object] if block given and try fails
  def try(input, &block); end

  # @api public
  # @return [Type]
  def type; end

  private

  # Delegates missing methods to {#type}
  #
  # @api private
  # @param method [Symbol]
  # @param args [Array]
  # @param block [#call, nil]
  def method_missing(method, *args, &block); end

  # @api private
  # @param meth [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  class << self
    # @api public
    # @param input [Builder, Object]
    # @param options [Hash]
    # @param block [#call, nil]
    def [](type, fn:, **options); end

    # @api public
    # @param input [Builder, Object]
    # @param options [Hash]
    # @param block [#call, nil]
    def new(input, **options, &block); end

    # @api private
    def wrapper_type; end
  end
end

# Function is used internally by Constructor types
#
# @api private
class Dry::Types::Constructor::Function
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Function] a new instance of Function
  def initialize(fn); end

  # @api private
  # @return [Function]
  def <<(other); end

  # @api private
  # @return [Function]
  def >>(other); end

  # @api private
  # @return [Object]
  def [](input, &block); end

  # @api private
  # @return [Integer]
  def arity; end

  # @api private
  # @return [Object]
  def call(input, &block); end

  # @api private
  def fn; end

  # @api private
  # @return [Array]
  def to_ast; end

  # @api private
  # @return [Boolean]
  def wrapper?; end

  class << self
    # Choose or build specialized invokation code for a callable
    #
    # @api private
    # @param fn [#call]
    # @raise [::ArgumentError]
    # @return [Function]
    def [](fn); end

    # @api private
    # @return [Boolean]
    def yields_block?(fn); end
  end
end

# Coercion via a method call on a known object
#
# @api private
class Dry::Types::Constructor::Function::MethodCall < ::Dry::Types::Constructor::Function
  # @api private
  # @return [MethodCall] a new instance of MethodCall
  def initialize(fn); end

  # @api private
  def name; end

  # @api private
  def target; end

  # @api private
  def to_ast; end

  class << self
    # @api private
    # @return [MethodCall]
    def [](fn, safe); end

    # Choose or build the base class
    #
    # @api private
    # @return [Function]
    def call_class(method, public, safe); end
  end
end

# Coercion via a private method call
#
# @api private
class Dry::Types::Constructor::Function::MethodCall::PrivateCall < ::Dry::Types::Constructor::Function::MethodCall
  # @api private
  def call(input, &block); end
end

# Coercion via an unsafe private method call
#
# @api private
class Dry::Types::Constructor::Function::MethodCall::PrivateSafeCall < ::Dry::Types::Constructor::Function::MethodCall::PrivateCall
  # @api private
  def call(input, &block); end
end

# Coercion with a publicly accessible method call
#
# @api private
class Dry::Types::Constructor::Function::MethodCall::PublicCall < ::Dry::Types::Constructor::Function::MethodCall
  class << self
    # Choose or build the interface
    #
    # @api private
    # @return [::Module]
    def call_interface(method, safe); end
  end
end

# Wrapper for unsafe coercion functions
#
# @api private
class Dry::Types::Constructor::Function::Safe < ::Dry::Types::Constructor::Function
  # @api private
  def call(input, &block); end
end

# @api private
class Dry::Types::Constructor::Function::Wrapper < ::Dry::Types::Constructor::Function
  # @api private
  # @return [Object]
  def [](input, type, &block); end

  # @api private
  def arity; end

  # @api private
  # @return [Object]
  def call(input, type, &block); end
end

# @api public
module Dry::Types::Constructor::Wrapper
  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def append(constructor = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Object]
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  def call_unsafe(input); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # @api public
  # @return [Constructor]
  def lax; end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Logic::Result, Types::Result]
  # @return [Object] if block given and try fails
  def try(input, &block); end

  private

  # Replace underlying type
  #
  # @api private
  def __new__(type); end
end

# Internal container for the built-in types
#
# @api private
class Dry::Types::Container
  include ::Dry::Container::Mixin::Initializer
  include ::Dry::Container::Mixin
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  def config; end
end

# Common API for types
#
# @api public
module Dry::Types::Decorator
  include ::Dry::Types::Options

  # @api public
  # @param type [Type]
  def initialize(type, *_arg1, **_arg2); end

  # @api public
  # @return [Boolean]
  def constrained?; end

  # @api public
  # @return [Boolean]
  def default?; end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  def to_proc; end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @return [Object] if block given and try fails
  def try(input, &block); end

  # @api public
  # @return [Type]
  def type; end

  private

  # Replace underlying type
  #
  # @api private
  def __new__(type); end

  # @api private
  # @param response [Object]
  # @return [Boolean]
  def decorate?(response); end

  # Delegates missing methods to {#type}
  #
  # @api private
  # @param meth [Symbol]
  # @param args [Array]
  # @param block [#call, nil]
  def method_missing(meth, *args, **_arg2, &block); end

  # @api public
  # @param meth [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# Default types are useful when a missing value should be replaced by a default one
#
# @api public
class Dry::Types::Default
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param type [Type]
  # @param value [Object]
  # @return [Default] a new instance of Default
  def initialize(type, value, **options); end

  # @api private
  # @param input [Object]
  # @return [Object] value passed through {#type} or {#default} value
  def call_safe(input = T.unsafe(nil), &block); end

  # @api private
  # @param input [Object]
  # @return [Object] value passed through {#type} or {#default} value
  def call_unsafe(input = T.unsafe(nil)); end

  # @api private
  # @return [false]
  def callable?; end

  # Build a constrained type
  #
  # @api public
  # @param args [Array] see {Dry::Types::Builder#constrained}
  # @return [Default]
  def constrained(*args); end

  # @api public
  # @return [true]
  def default?; end

  # @api public
  # @return [Object]
  def evaluate; end

  # @api public
  # @param input [Object]
  # @return [Result::Success]
  def try(input); end

  # @api public
  # @return [Boolean]
  def valid?(value = T.unsafe(nil)); end

  # @api public
  # @return [Object]
  def value; end

  class << self
    # @api private
    # @param value [Object, #call]
    # @return [Class] {Default} or {Default::Callable}
    def [](value); end
  end
end

# @api private
class Dry::Types::Default::Callable < ::Dry::Types::Default
  # @api private
  # @return [true]
  def callable?; end

  # Evaluates given callable
  #
  # @api private
  # @return [Object]
  def evaluate; end
end

# @api public
Dry::Types::Definition = Dry::Types::Nominal

Dry::Types::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Dry::Types::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Dry::Types::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)
Dry::Types::EMPTY_SET = T.let(T.unsafe(nil), Set)
Dry::Types::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Enum types can be used to define an enum on top of an existing type
#
# @api public
class Dry::Types::Enum
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder

  # @api private
  # @option options
  # @param type [Type]
  # @param options [Hash]
  # @return [Enum] a new instance of Enum
  def initialize(type, **options); end

  # @api private
  # @return [Object]
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  def call_unsafe(input); end

  # @api private
  def default(*_arg0); end

  # Check whether a value is in the enum
  #
  # @api public
  def include?(input = T.unsafe(nil)); end

  # @api public
  # @return [String]
  def inspect; end

  # @api public
  # @return [Hash]
  def inverted_mapping; end

  # @api public
  # @return [Hash]
  def mapping; end

  # @api public
  # @see Nominal#to_ast
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @return [String]
  def to_s; end

  # @api public
  # @see Dry::Types::Constrained#try
  def try(input); end

  # @api public
  # @return [Array]
  def values; end

  private

  # Maps a value
  #
  # @api private
  # @param input [Object]
  # @return [Object]
  def map_value(input); end
end

# Internal container for constructor functions used by the built-in types
#
# @api private
class Dry::Types::FnContainer
  class << self
    # @api private
    def [](fn_name); end

    # @api private
    def container; end

    # @api private
    def register(function = T.unsafe(nil), &block); end

    # @api private
    def register_name(function); end
  end
end

# Hash types can be used to define maps and schemas
#
# @api public
class Dry::Types::Hash < ::Dry::Types::Nominal
  # @api private
  def constructor_type; end

  # Build a map type
  #
  # @api public
  # @param key_type [Type]
  # @param value_type [Type]
  # @return [Map]
  def map(key_type, value_type); end

  # @api private
  def permissive(*_arg0); end

  # @api public
  # @overload schema
  # @overload schema
  def schema(keys_or_map, meta = T.unsafe(nil)); end

  # @api private
  def strict(*_arg0); end

  # @api private
  def strict_with_defaults(*_arg0); end

  # @api private
  def symbolized(*_arg0); end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  def to_ast(meta: T.unsafe(nil)); end

  # Whether the type transforms types of schemas created by {Dry::Types::Hash#schema}
  #
  # @api public
  # @return [Boolean]
  def transform_types?; end

  # @api private
  def weak(*_arg0); end

  # Injects a type transformation function for building schemas
  #
  # @api public
  # @param proc [#call, nil]
  # @param block [#call, nil]
  # @raise [ArgumentError]
  # @return [Hash]
  def with_type_transform(proc = T.unsafe(nil), &block); end

  private

  # @api private
  def build_keys(type_map); end

  # @api private
  def key_name(key); end

  # @api private
  def resolve_type(type); end
end

# @api public
class Dry::Types::Hash::Constructor < ::Dry::Types::Constructor
  # @api private
  def constructor_type; end

  # @api public
  # @return [Lax]
  def lax; end

  # @api public
  # @see Dry::Types::Array#of
  def schema(*args); end
end

# @api public
Dry::Types::Hash::NOT_REQUIRED = T.let(T.unsafe(nil), Hash)

Dry::Types::IDENTITY = T.let(T.unsafe(nil), Proc)

# @api public
Dry::Types::Inflector = T.let(T.unsafe(nil), Dry::Inflector)

# Primitives with {Kernel} coercion methods
#
# @api public
Dry::Types::KERNEL_COERCIBLE = T.let(T.unsafe(nil), Hash)

# Lax types rescue from type-related errors when constructors fail
#
# @api public
class Dry::Types::Lax
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param input [Object]
  # @return [Object]
  def [](input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  def call(input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  def call_safe(input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  def call_unsafe(input); end

  # @api public
  # @return [Lax]
  def lax; end

  # @api public
  # @see Nominal#to_ast
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  def try(input, &block); end

  private

  # @api private
  # @param response [Object, Dry::Types::Constructor]
  # @return [Boolean]
  def decorate?(response); end
end

# Primitives with coercions through by convention `to_*` methods
#
# @api public
Dry::Types::METHOD_COERCIBLE = T.let(T.unsafe(nil), Hash)

# By convention methods to coerce {METHOD_COERCIBLE} primitives
#
# @api public
Dry::Types::METHOD_COERCIBLE_METHODS = T.let(T.unsafe(nil), Hash)

# Homogeneous mapping. It describes a hash with unknown keys that match a certain type.
#
# @api public
# @example
#   type = Dry::Types['hash'].map(
#   Dry::Types['integer'].constrained(gteq: 1, lteq: 10),
#   Dry::Types['string']
#   )
#
#   type.(1 => 'right')
#   # => {1 => 'right'}
#
#   type.('1' => 'wrong')
#   # Dry::Types::MapError: "1" violates constraints (type?(Integer, "1") AND gteq?(1, "1") AND lteq?(10, "1") failed)
#
#   type.(11 => 'wrong')
#   # Dry::Types::MapError: 11 violates constraints (lteq?(10, 11) failed)
class Dry::Types::Map < ::Dry::Types::Nominal
  # @api public
  # @return [Map] a new instance of Map
  def initialize(_primitive, key_type: T.unsafe(nil), value_type: T.unsafe(nil), meta: T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash]
  def call_safe(hash); end

  # @api private
  # @param hash [Hash]
  # @return [Hash]
  def call_unsafe(hash); end

  # @api public
  # @return [Boolean]
  def constrained?; end

  # @api public
  # @return [Type]
  def key_type; end

  # @api public
  # @return [String]
  def name; end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param hash [Hash]
  # @return [Result]
  # @yield [result]
  def try(hash); end

  # @api public
  # @return [Type]
  def value_type; end

  private

  # @api private
  def coerce(input); end
end

# @api public
class Dry::Types::MapError < ::Dry::Types::CoercionError; end

# Storage for meta-data
#
# @api public
module Dry::Types::Meta
  # @api public
  def initialize(*args, meta: T.unsafe(nil), **options); end

  # @api public
  # @overload meta
  # @overload meta
  def meta(data = T.unsafe(nil)); end

  # Resets meta
  #
  # @api public
  # @return [Dry::Types::Type]
  def pristine; end

  # @api public
  # @param options [Hash] new_options
  # @return [Type]
  def with(**options); end
end

# @api public
class Dry::Types::MissingKeyError < ::Dry::Types::SchemaKeyError
  # @api public
  # @param key [String, Symbol]
  # @return [MissingKeyError] a new instance of MissingKeyError
  def initialize(key); end

  # @api public
  # @return [Symbol]
  def key; end
end

# Export types registered in a container as module constants.
#
# @api public
# @example
#   module Types
#   include Dry::Types(:strict, :coercible, :nominal, default: :strict)
#   end
#
#   Types.constants
#   # => [:Class, :Strict, :Symbol, :Integer, :Float, :String, :Array, :Hash,
#   #     :Decimal, :Nil, :True, :False, :Bool, :Date, :Nominal, :DateTime, :Range,
#   #     :Coercible, :Time]
class Dry::Types::Module < ::Module
  # @api public
  # @return [Module] a new instance of Module
  def initialize(registry, *args, **kwargs); end

  # @api private
  def registry_tree; end

  # @api private
  def type_constants(*namespaces, default: T.unsafe(nil), **aliases); end

  private

  # @api private
  def check_parameters(*namespaces, default: T.unsafe(nil), **aliases); end

  # @api private
  def define_constants(constants, mod = T.unsafe(nil)); end
end

# Collection of multiple errors
#
# @api public
class Dry::Types::MultipleError < ::Dry::Types::CoercionError
  # @api public
  # @param errors [Array<CoercionError>]
  # @return [MultipleError] a new instance of MultipleError
  def initialize(errors); end

  # @api public
  # @return [Array<CoercionError>]
  def errors; end

  # @api public
  # @return string
  def message; end

  # @api public
  # @return [Array]
  def meta; end
end

# Primitives that are non-coercible
#
# @api public
Dry::Types::NON_COERCIBLE = T.let(T.unsafe(nil), Hash)

# All built-in primitives except {NilClass}
#
# @api public
Dry::Types::NON_NIL = T.let(T.unsafe(nil), Hash)

# Nominal types define a primitive class and do not apply any constructors or constraints
#
# Use these types for annotations and the base for building more complex types on top of them.
#
# @api public
class Dry::Types::Nominal
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param primitive [Type, Class]
  # @param options [Hash]
  # @return [Nominal] a new instance of Nominal
  def initialize(primitive, **options); end

  # @api private
  # @param input [BasicObject]
  # @return [BasicObject]
  def call_safe(input); end

  # @api private
  # @param input [BasicObject]
  # @return [BasicObject]
  def call_unsafe(input); end

  # @api private
  def coerce(input, &_block); end

  # @api public
  # @return [false]
  def constrained?; end

  # @api public
  # @return [false]
  def default?; end

  # @api public
  # @raise [ArgumentError]
  # @return [Result::Failure]
  def failure(input, error); end

  # Return self. Nominal types are lax by definition
  #
  # @api public
  # @return [Nominal]
  def lax; end

  # @api public
  # @return [String]
  def name; end

  # @api public
  # @return [false]
  def optional?; end

  # @api public
  # @return [Class]
  def primitive; end

  # Checks whether value is of a #primitive class
  #
  # @api public
  # @param value [Object]
  # @return [Boolean]
  def primitive?(value); end

  # @api public
  # @return [Result::Success]
  def success(input); end

  # Return AST representation of a type nominal
  #
  # @api public
  # @return [Array]
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  def to_proc; end

  # @api public
  # @param input [Object]
  # @return [Result, Logic::Result] when a block is not provided
  # @return [nil] otherwise
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  def try(input); end

  # @api private
  def try_coerce(input); end

  class << self
    # @api private
    # @param primitive [Class]
    # @return [Type]
    def [](primitive); end
  end
end

# @api public
Dry::Types::Nominal::ALWAYS = T.let(T.unsafe(nil), Proc)

# Common API for types with options
#
# @api private
module Dry::Types::Options
  # @api private
  # @see Nominal#initialize
  def initialize(*args, **options); end

  # @api private
  # @return [Hash]
  def options; end

  # @api private
  # @param new_options [Hash]
  # @return [Type]
  def with(**new_options); end
end

# @api public
Dry::Types::PRINTER = T.let(T.unsafe(nil), Dry::Types::Printer)

# @api private
module Dry::Types::Printable
  # @api private
  # @return [String]
  def inspect; end

  # @api private
  # @return [String]
  def to_s; end
end

# @api private
class Dry::Types::Printer
  # @api private
  def call(type); end

  # @api private
  def visit(type, &block); end

  # @api private
  # @yield ["Any"]
  def visit_any(_); end

  # @api private
  def visit_array(type); end

  # @api private
  def visit_array_member(array); end

  # @api private
  def visit_callable(callable); end

  # @api private
  def visit_constrained(constrained); end

  # @api private
  def visit_constructor(constructor); end

  # @api private
  def visit_default(default); end

  # @api private
  def visit_enum(enum); end

  # @api private
  def visit_hash(hash); end

  # @api private
  def visit_key(key); end

  # @api private
  def visit_lax(lax); end

  # @api private
  def visit_map(map); end

  # @api private
  def visit_nominal(type); end

  # @api private
  def visit_options(options, meta = T.unsafe(nil)); end

  # @api private
  def visit_schema(schema); end

  # @api private
  def visit_struct_constructor(constructor); end

  # @api private
  def visit_struct_sum(sum); end

  # @api private
  def visit_sum(sum); end

  # @api private
  def visit_sum_constructors(sum); end
end

# @api private
Dry::Types::Printer::MAPPING = T.let(T.unsafe(nil), Hash)

# Result class used by {Type#try}
#
# @api public
class Dry::Types::Result
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param input [Object]
  # @return [Result] a new instance of Result
  def initialize(input); end

  # @api public
  # @return [Object]
  def input; end
end

# Failure result
#
# @api public
class Dry::Types::Result::Failure < ::Dry::Types::Result
  # @api private
  # @param input [Object]
  # @param error [#to_s]
  # @return [Failure] a new instance of Failure
  def initialize(input, error); end

  # @api public
  # @return [#to_s]
  def error; end

  # @api public
  # @return [true]
  def failure?; end

  # @api public
  # @return [false]
  def success?; end

  # @api private
  # @return [String]
  def to_s; end
end

# Success result
#
# @api public
class Dry::Types::Result::Success < ::Dry::Types::Result
  # @api public
  # @return [false]
  def failure?; end

  # @api public
  # @return [true]
  def success?; end
end

# @api public
Dry::Types::Safe = Dry::Types::Lax

# The built-in Hash type can be defined in terms of keys and associated types
# its values can contain. Such definitions are named {Schema}s and defined
# as lists of {Key} types.
#
# {Schema} evaluates default values for keys missing in input hash
#
# {Schema} implements Enumerable using its keys as collection.
#
# @api public
# @see Dry::Types::Schema::Key
# @see Dry::Types::Default#evaluate
# @see Dry::Types::Default::Callable#evaluate
class Dry::Types::Schema < ::Dry::Types::Hash
  include ::Enumerable

  # @api private
  # @option options
  # @option options
  # @param _primitive [Class]
  # @param options [Hash]
  # @return [Schema] a new instance of Schema
  def initialize(_primitive, **options); end

  # @api public
  # @option options
  # @option options
  # @param hash [Hash]
  # @param options [Hash] a customizable set of options
  # @return [Hash{Symbol => Object}]
  def apply(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash{Symbol => Object}]
  def call_safe(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash{Symbol => Object}]
  def call_unsafe(hash, options = T.unsafe(nil)); end

  # Empty schema with the same options
  #
  # @api public
  # @return [Schema]
  def clear; end

  # @api public
  # @return [Boolean]
  def constrained?; end

  # Iterate over each key type
  #
  # @api public
  # @return [Array<Dry::Types::Schema::Key>, Enumerator]
  def each(&block); end

  # Fetch key type by a key name
  #
  # Behaves as ::Hash#fetch
  #
  # @api public
  # @overload key
  # @overload key
  def key(name, fallback = T.unsafe(nil), &block); end

  # Whether the schema has the given key
  #
  # @api public
  # @param name [Symbol] Key name
  # @return [Boolean]
  def key?(name); end

  # @api public
  # @return [Array[Dry::Types::Schema::Key]]
  def keys; end

  # @api public
  # @return [Lax]
  def lax; end

  # Merge given schema keys into current schema
  #
  # A new instance is returned.
  #
  # @api public
  # @param other [Schema] schema
  # @return [Schema]
  def merge(other); end

  # @api public
  # @return [Hash[Symbol, Dry::Types::Schema::Key]]
  def name_key_map; end

  # @api public
  # @overload schema
  # @overload schema
  def schema(keys_or_map); end

  # Make the schema intolerant to unknown keys
  #
  # @api public
  # @return [Schema]
  def strict(strict = T.unsafe(nil)); end

  # Whether the schema rejects unknown keys
  #
  # @api public
  # @return [Boolean]
  def strict?; end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @return [#call]
  def transform_key; end

  # Whether the schema transforms input keys
  #
  # @api public
  # @return [Boolean]
  def transform_keys?; end

  # @api public
  # @param input [Hash] hash
  # @return [Logic::Result]
  # @return [Object] if coercion fails and a block is given
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  def try(input); end

  # Inject a key transformation function
  #
  # @api public
  # @param proc [#call, nil]
  # @param block [#call, nil]
  # @raise [ArgumentError]
  # @return [Schema]
  def with_key_transform(proc = T.unsafe(nil), &block); end

  private

  # @api private
  # @param keys [Array<Dry::Types::Schema::Keys>]
  # @return [Dry::Types::Schema]
  def merge_keys(*keys); end

  # @api private
  # @return [MissingKeyError]
  def missing_key(key); end

  # Try to add missing keys to the hash
  #
  # @api private
  def resolve_missing_keys(hash, options); end

  # Validate and coerce a hash. Call a block and halt on any error
  #
  # @api private
  # @return [Hash]
  def resolve_safe(hash, options = T.unsafe(nil), &block); end

  # Validate and coerce a hash. Raise an exception on any error
  #
  # @api private
  # @return [Hash]
  def resolve_unsafe(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash_keys [Array<Symbol>]
  # @return [UnknownKeysError]
  def unexpected_keys(hash_keys); end
end

# Proxy type for schema keys. Contains only key name and
# whether it's required or not. All other calls deletaged
# to the wrapped type.
#
# @api public
# @see Dry::Types::Schema
class Dry::Types::Schema::Key
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Key] a new instance of Key
  def initialize(type, name, required: T.unsafe(nil), **options); end

  # @api private
  def call_safe(input, &block); end

  # @api private
  def call_unsafe(input); end

  # Turn key into a lax type. Lax types are not strict hence such keys are not required
  #
  # @api public
  # @return [Lax]
  def lax; end

  # @api public
  # @see Dry::Types::Meta#meta
  def meta(data = T.unsafe(nil)); end

  # @api public
  # @return [Symbol]
  def name; end

  # Make key not required
  #
  # @api public
  # @return [Dry::Types::Schema::Key]
  def omittable; end

  # Make wrapped type optional
  #
  # @api public
  # @return [Key]
  def optional; end

  # Control whether the key is required
  #
  # @api public
  # @overload required
  # @overload required
  def required(required = T.unsafe(nil)); end

  # Whether the key is required in schema input
  #
  # @api public
  # @return [Boolean]
  def required?; end

  # Dump to internal AST representation
  #
  # @api public
  # @return [Array]
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @see Dry::Types::Nominal#try
  def try(input, &block); end

  private

  # @api private
  # @return [Boolean]
  def decorate?(response); end
end

# @api public
Dry::Types::Schema::NO_TRANSFORM = T.let(T.unsafe(nil), String)

# @api public
Dry::Types::Schema::SYMBOLIZE_KEY = T.let(T.unsafe(nil), String)

# @api public
class Dry::Types::SchemaError < ::Dry::Types::CoercionError
  # @api public
  # @param key [String, Symbol]
  # @param value [Object]
  # @param result [String, #to_s]
  # @return [SchemaError] a new instance of SchemaError
  def initialize(key, value, result); end
end

# @api public
class Dry::Types::SchemaKeyError < ::Dry::Types::CoercionError; end

Dry::Types::Self = T.let(T.unsafe(nil), Proc)

# Sum type
#
# @api public
class Dry::Types::Sum
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param left [Type]
  # @param right [Type]
  # @param options [Hash]
  # @return [Sum] a new instance of Sum
  def initialize(left, right, **options); end

  # @api private
  # @param input [Object]
  # @return [Object]
  def call_safe(input, &block); end

  # @api private
  # @param input [Object]
  # @return [Object]
  def call_unsafe(input); end

  # @api public
  # @param options [Hash]
  # @return [Constrained, Sum]
  # @see Builder#constrained
  def constrained(options); end

  # @api public
  # @return [false]
  def constrained?; end

  # @api public
  # @return [false]
  def default?; end

  # @api private
  def failure(input, _error = T.unsafe(nil)); end

  # @api public
  # @return [Type]
  def left; end

  # Manage metadata to the type. If the type is an optional, #meta delegates
  # to the right branch
  #
  # @api public
  # @see [Meta#meta]
  def meta(data = T.unsafe(nil)); end

  # @api public
  # @return [String]
  def name; end

  # @api public
  # @return [Boolean]
  def optional?; end

  # @api private
  # @param value [Object]
  # @return [Boolean]
  def primitive?(value); end

  # @api public
  # @return [Type]
  def right; end

  # @api private
  def success(input); end

  # @api public
  # @see Nominal#to_ast
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  def to_proc; end

  # @api public
  # @param input [Object]
  def try(input); end
end

# @api private
class Dry::Types::Sum::Constrained < ::Dry::Types::Sum
  # @api private
  # @return [true]
  def constrained?; end

  # @api private
  # @return [Dry::Logic::Operations::Or]
  def rule; end
end

# @api public
Dry::Types::TYPE_SPEC_REGEX = T.let(T.unsafe(nil), Regexp)

# Common Type module denoting an object is a Type
#
# @api public
module Dry::Types::Type
  extend ::Dry::Core::Deprecations::Interface

  # Whether a value is a valid member of the type
  # Anything can be coerced matches
  #
  # @api private
  # @return [Boolean]
  def ===(input = T.unsafe(nil)); end

  # Apply type to a value
  #
  # @api public
  # @overload call
  # @overload call
  def [](input = T.unsafe(nil), &block); end

  # Apply type to a value
  #
  # @api public
  # @overload call
  # @overload call
  def call(input = T.unsafe(nil), &block); end

  def safe(*args, &block); end

  # Whether a value is a valid member of the type
  #
  # @api private
  # @return [Boolean]
  def valid?(input = T.unsafe(nil)); end
end

Dry::Types::Undefined = T.let(T.unsafe(nil), Object)

# @api public
class Dry::Types::UnknownKeysError < ::Dry::Types::SchemaKeyError
  # @api public
  # @param keys [<String, Symbol>]
  # @return [UnknownKeysError] a new instance of UnknownKeysError
  def initialize(keys); end

  # @api public
  # @return [Array<Symbol>]
  def keys; end
end

# @api public
Dry::Types::VERSION = T.let(T.unsafe(nil), String)
